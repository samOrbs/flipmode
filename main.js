/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BJJFlipmodePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/header-asset.ts
var FLIPMODE_HEADER_BASE64 = `data:image/png;base64,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`;

// src/main.ts
var DEFAULT_SETTINGS = {
  serverUrl: "http://localhost:5005",
  apiToken: "",
  syncFolder: "Flipmode",
  autoSync: false,
  syncInterval: 30,
  userId: "default",
  // Mode defaults
  mode: "local",
  queueServiceUrl: "https://flipmode-d2c51311485b.herokuapp.com",
  athleteToken: "",
  pollInterval: 10,
  // Coach mode defaults
  coachToken: "",
  // Season/Episode tracking
  currentSeason: 1,
  currentEpisode: 1,
  // Athlete identity
  athleteName: "Athlete",
  // Concepts folder structure
  conceptsSubfolder: "concepts",
  // Shared canvases
  sharedCanvases: {}
};
var RemoteQueueClient = class {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
  }
  async submitQuery(query, therapyContext) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/submit`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.token}`
      },
      body: JSON.stringify({
        query_text: query,
        therapy_context: therapyContext
      })
    });
    return { jobId: response.json.job_id };
  }
  async checkStatus(jobId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/status/${jobId}`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    return {
      status: response.json.status,
      progress: response.json.started_at ? "Processing..." : "Queued"
    };
  }
  async getResult(jobId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/result/${jobId}`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    const data = response.json;
    if (data.status === "error") {
      return { article: "", sources: [], error: data.error };
    }
    return {
      article: data.result_article || "",
      sources: data.result_sources || [],
      rlm_session_id: data.rlm_session_id
    };
  }
  async listJobs() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/jobs`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    return response.json.jobs || [];
  }
  async syncGraph(graphData) {
    await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/graph/sync`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.token}`
      },
      body: JSON.stringify(graphData)
    });
  }
  async getConcepts() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/concepts`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    return response.json.concepts || [];
  }
  async checkHealth() {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/health`,
        method: "GET"
      });
      return response.json.status === "healthy";
    } catch (e) {
      return false;
    }
  }
  async getCanvases(since) {
    const url = since ? `${this.baseUrl}/api/queue/canvases?since=${encodeURIComponent(since)}` : `${this.baseUrl}/api/queue/canvases`;
    const response = await (0, import_obsidian.requestUrl)({
      url,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    return response.json.canvases || {};
  }
};
var CoachQueueClient = class {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
  }
  async getAthletes() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/roster`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json.athletes || [];
  }
  async addAthlete(discordId, displayName) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/roster`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ discord_id: discordId, display_name: displayName })
    });
    return response.json;
  }
  async getPendingJobs() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/pending`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json.jobs || [];
  }
  async getAthleteGraph(athleteId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/graph/${athleteId}`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json;
  }
  async claimJob(jobId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/claim/${jobId}`,
      method: "POST",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json;
  }
  async completeJob(jobId, article, sources) {
    try {
      await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/api/queue/complete/${jobId}`,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          result_article: article,
          result_sources: sources,
          rlm_session_id: `coach_${jobId}`
        })
      });
      return true;
    } catch (e) {
      return false;
    }
  }
  async getStats() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/stats`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json;
  }
  async checkHealth() {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/health`,
        method: "GET"
      });
      return response.json.status === "healthy";
    } catch (e) {
      return false;
    }
  }
  async pushConcepts(athleteId, concepts) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/concepts/push`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        athlete_id: athleteId,
        concepts
      })
    });
    return response.json;
  }
  async shareConceptGraph(athleteId, conceptName, conceptSummary, graphData) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/share-concept-graph`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        athlete_id: athleteId,
        concept_name: conceptName,
        concept_summary: conceptSummary,
        graph_data: graphData
      })
    });
    return response.json;
  }
  async syncCanvas(athleteId, canvasName, canvasData) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/sync-canvas`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        athlete_id: athleteId,
        canvas_name: canvasName,
        canvas_data: canvasData
      })
    });
    return response.json;
  }
};
var BJJFlipmodePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    // Remote mode (athlete)
    this.pendingJobs = /* @__PURE__ */ new Map();
    this.pollIntervalId = null;
    this.queueClient = null;
    // Coach mode
    this.coachClient = null;
    // Track last canvas sync time
    this.lastCanvasSync = null;
    this.canvasPollIntervalId = null;
  }
  async onload() {
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("Disconnected");
    this.addRibbonIcon("brain-circuit", "Flipmode", async () => {
      await this.showFlipmodeMenu();
    });
    this.registerObsidianProtocolHandler("flipmode-sync", async (params) => {
      const conceptName = params.concept;
      if (conceptName) {
        await this.syncAndOpenConcept(conceptName);
      }
    });
    this.addCommand({
      id: "flipmode-voice-note",
      name: "Record training voice note",
      callback: () => this.showVoiceNoteModal()
    });
    this.addCommand({
      id: "flipmode-research",
      name: "Research a technique",
      callback: () => this.showResearchModal()
    });
    this.addCommand({
      id: "flipmode-sync",
      name: "Sync with Flipmode",
      callback: () => this.syncWithFlipmode()
    });
    this.addCommand({
      id: "flipmode-quick-note",
      name: "Quick training note",
      editorCallback: (editor, view) => {
        this.insertTrainingTemplate(editor);
      }
    });
    this.addCommand({
      id: "flipmode-check-connection",
      name: "Check Flipmode connection",
      callback: () => this.checkConnection()
    });
    this.addCommand({
      id: "flipmode-view-pending-jobs",
      name: "View pending coach queries",
      callback: () => this.showPendingJobsModal()
    });
    this.addCommand({
      id: "flipmode-connect-discord",
      name: "Connect with Discord (remote mode)",
      callback: () => this.connectWithDiscord()
    });
    this.addCommand({
      id: "flipmode-coach-sync",
      name: "Coach: Sync all athletes",
      callback: () => this.coachSyncAthletes()
    });
    this.addCommand({
      id: "flipmode-coach-pending",
      name: "Coach: View pending queries",
      callback: () => this.coachShowPending()
    });
    this.addCommand({
      id: "flipmode-coach-generate",
      name: "Coach: Generate article for current query",
      editorCallback: (editor, view) => this.coachGenerateArticle(view)
    });
    this.addCommand({
      id: "flipmode-coach-push",
      name: "Coach: Push article to athlete",
      editorCallback: (editor, view) => this.coachPushArticle(view)
    });
    this.addCommand({
      id: "flipmode-coach-push-concepts",
      name: "Coach: Push concepts to athlete",
      callback: () => this.coachPushConcepts()
    });
    this.addCommand({
      id: "flipmode-coach-add-athlete",
      name: "Coach: Add athlete to roster",
      callback: () => this.coachAddAthlete()
    });
    this.addCommand({
      id: "flipmode-dive-deeper-session",
      name: "Dive Deeper on this session",
      editorCallback: async (editor, view) => {
        await this.diveDeepOnSession(view);
      }
    });
    this.addCommand({
      id: "flipmode-generate-training-review",
      name: "Generate Training Review (from Training Notes)",
      editorCallback: async (editor, view) => {
        await this.generateTrainingReview(view);
      }
    });
    this.addCommand({
      id: "flipmode-publish-training-review",
      name: "Publish Training Review (send to athlete)",
      editorCallback: async (editor, view) => {
        await this.publishTrainingReview(view);
      }
    });
    this.addCommand({
      id: "flipmode-open-audio-player",
      name: "Open Audio Player",
      editorCallback: async (editor, view) => {
        await this.openAudioPlayer(view);
      }
    });
    this.addCommand({
      id: "flipmode-sync-from-coach",
      name: "Sync from Oracle (fetch completed research)",
      callback: async () => {
        await this.syncFromCoach();
      }
    });
    this.addCommand({
      id: "flipmode-find-video-canvas",
      name: "Find Video for Selected Concept (Canvas)",
      checkCallback: (checking) => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if (canvasView && canvasView.getViewType() === "canvas") {
          if (!checking) {
            this.findVideoForCanvasNode(canvasView);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "flipmode-rlm-pipeline",
      name: "RLM: Enrich & Rebuild Canvas",
      checkCallback: (checking) => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if (canvasView && canvasView.getViewType() === "canvas") {
          if (!checking) {
            this.runRLMPipeline(canvasView);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "flipmode-generate-variables-canvas",
      name: "Generate Variables Canvas",
      checkCallback: (checking) => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if (canvasView && canvasView.getViewType() === "canvas") {
          if (!checking) {
            this.generateVariablesCanvas(canvasView);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "flipmode-toggle-canvas",
      name: "Toggle RLM/Variables Canvas",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "v" }],
      checkCallback: (checking) => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if (canvasView && canvasView.getViewType() === "canvas") {
          if (!checking) {
            this.toggleRLMVariablesCanvas(canvasView);
          }
          return true;
        }
        return false;
      }
    });
    this.addSettingTab(new BJJFlipmodeSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const selection = editor.getSelection();
        if (selection && selection.trim().length > 0) {
          menu.addItem((item) => {
            item.setTitle("Generate Training Review").setIcon("graduation-cap").onClick(async () => {
              await this.generateTrainingReviewFromSelection(editor, view, selection);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Generate Skill Development").setIcon("dumbbell").onClick(async () => {
              await this.generateTrainingPlanFromSelection(editor, view, selection);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Dive Deeper").setIcon("search").onClick(async () => {
              await this.diveDeeper(editor, view, selection);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Explode to Concept Graph").setIcon("git-branch").onClick(async () => {
              await this.explodeToConceptGraph(editor, view, selection);
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("canvas:node-menu", (menu, node) => {
        var _a, _b, _c;
        let hasLinkedSources = false;
        let sessionId = null;
        if (node.file) {
          const cache = this.app.metadataCache.getFileCache(node.file);
          if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.source_rlm_session) {
            hasLinkedSources = true;
            sessionId = cache.frontmatter.source_rlm_session;
          }
        }
        if (hasLinkedSources && sessionId) {
          menu.addItem((item) => {
            item.setTitle("View Source Videos").setIcon("library").onClick(async () => {
              await this.showArticleBibliography(node, sessionId);
            });
          });
        }
        menu.addItem((item) => {
          item.setTitle("Search Videos (Semantic)").setIcon("search").onClick(async () => {
            await this.findVideoForCanvasNodeDirect(node);
          });
        });
        menu.addItem((item) => {
          item.setTitle("Explore Full Series").setIcon("layers").onClick(async () => {
            await this.exploreSeriesForCanvasNode(node);
          });
        });
        menu.addItem((item) => {
          item.setTitle("Cross-Reference with Catalog").setIcon("git-compare").onClick(async () => {
            await this.openCrossReferenceCatalog(node);
          });
        });
        if (node.file) {
          const cache = this.app.metadataCache.getFileCache(node.file);
          if (((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b.type) === "checkpoint") {
            menu.addItem((item) => {
              item.setTitle("Enrich Checkpoint (RLM)").setIcon("sparkles").onClick(async () => {
                await this.openEnrichCheckpoint(node);
              });
            });
          }
          if ((_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c.video_id) {
            if (cache.frontmatter.timestamp) {
              menu.addItem((item) => {
                item.setTitle(`Extract Clip at ${cache.frontmatter.timestamp}`).setIcon("video").onClick(async () => {
                  await this.extractClipDirect(node, cache.frontmatter);
                });
              });
            }
            menu.addItem((item) => {
              item.setTitle("Browse All Timestamps").setIcon("list").onClick(async () => {
                await this.openConceptCacheForClips(node, cache.frontmatter);
              });
            });
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("canvas:menu", (menu, canvas) => {
        var _a;
        if (this.settings.mode !== "coach" || !this.coachClient)
          return;
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if (!canvasView || canvasView.getViewType() !== "canvas")
          return;
        const canvasFile = canvasView.file;
        if (!canvasFile)
          return;
        const isShared = ((_a = this.settings.sharedCanvases[canvasFile.path]) == null ? void 0 : _a.length) > 0;
        menu.addItem((item) => {
          item.setTitle(isShared ? "Update Shared Canvas" : "Share Canvas with Athlete").setIcon("send").onClick(async () => {
            await this.shareCanvasWithAthlete(canvasFile);
          });
        });
        if (isShared) {
          menu.addItem((item) => {
            item.setTitle("Stop Sharing Canvas").setIcon("x").onClick(async () => {
              delete this.settings.sharedCanvases[canvasFile.path];
              await this.saveSettings();
              new import_obsidian.Notice("Canvas unshared");
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (!(file instanceof import_obsidian.TFile))
          return;
        if (file.extension !== "canvas")
          return;
        if (this.settings.mode !== "coach" || !this.coachClient)
          return;
        const sharedWith = this.settings.sharedCanvases[file.path];
        if (!sharedWith || sharedWith.length === 0)
          return;
        if (this._canvasSyncTimeout) {
          clearTimeout(this._canvasSyncTimeout);
        }
        this._canvasSyncTimeout = setTimeout(async () => {
          await this.syncSharedCanvas(file, sharedWith);
        }, 2e3);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        var _a;
        if (!(file instanceof import_obsidian.TFile))
          return;
        if (file.extension === "canvas") {
          if (this.settings.mode === "coach" && this.coachClient) {
            const isShared = ((_a = this.settings.sharedCanvases[file.path]) == null ? void 0 : _a.length) > 0;
            menu.addItem((item) => {
              item.setTitle(isShared ? "Update Shared Canvas" : "Share Canvas with Athlete").setIcon("send").onClick(async () => {
                await this.shareCanvasWithAthlete(file);
              });
            });
            if (isShared) {
              menu.addItem((item) => {
                item.setTitle("Stop Sharing").setIcon("x").onClick(async () => {
                  delete this.settings.sharedCanvases[file.path];
                  await this.saveSettings();
                  new import_obsidian.Notice("Canvas unshared");
                });
              });
            }
          }
          return;
        }
        if (file.extension !== "md")
          return;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        const isCanvasView = activeView && activeView.getViewType() === "canvas";
        if (isCanvasView) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Get Training Drills").setIcon("dumbbell").onClick(async () => {
            await this.getTrainingDrillsForConcept(file);
          });
        });
        menu.addItem((item) => {
          item.setTitle("Research This Concept").setIcon("search").onClick(async () => {
            await this.researchConcept(file);
          });
        });
        if (this.settings.mode === "coach" && this.coachClient) {
          menu.addItem((item) => {
            item.setTitle("Share with Athlete via Discord").setIcon("send").onClick(async () => {
              await this.shareConceptGraphWithAthlete(file);
            });
          });
        }
      })
    );
    this.checkConnection();
    if (this.settings.autoSync) {
      this.startAutoSync();
    }
    if (this.settings.mode === "remote" && this.settings.queueServiceUrl && this.settings.athleteToken) {
      this.initRemoteMode();
    }
    if (this.settings.mode === "coach" && this.settings.queueServiceUrl && this.settings.coachToken) {
      this.initCoachMode();
    }
  }
  // Coach mode methods
  initCoachMode() {
    this.coachClient = new CoachQueueClient(
      this.settings.queueServiceUrl,
      this.settings.coachToken
    );
    this.updateStatusBar("Coach Mode");
  }
  isCoachMode() {
    return this.settings.mode === "coach" && !!this.coachClient;
  }
  async coachSyncAthletes() {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    new import_obsidian.Notice("Syncing athletes...");
    try {
      const athletes = await this.coachClient.getAthletes();
      const athletesFolder = `${this.settings.syncFolder}/Athletes`;
      await this.ensureFolder(athletesFolder);
      for (const athlete of athletes) {
        const name = athlete.display_name || athlete.discord_username || `Athlete_${athlete.id}`;
        const safeName = name.replace(/[\\/:*?"<>|]/g, "_");
        const athleteFolder = `${athletesFolder}/${safeName}`;
        await this.ensureFolder(athleteFolder);
        const graphData = await this.coachClient.getAthleteGraph(athlete.id);
        const graph = (graphData == null ? void 0 : graphData.graph_data) || { sessions: [], queries: [], topics: [] };
        const summaryContent = this.createAthleteSummary(name, athlete, graph);
        await this.saveNote(`${athleteFolder}/summary.md`, summaryContent);
      }
      const pending = await this.coachClient.getPendingJobs();
      const inboxFolder = `${this.settings.syncFolder}/Inbox`;
      await this.ensureFolder(inboxFolder);
      for (const job of pending) {
        const filename = `${inboxFolder}/${job.job_id.substring(0, 8)} - ${job.athlete_name || "Unknown"}.md`;
        if (await this.app.vault.adapter.exists(filename))
          continue;
        const content = this.createPendingQueryNote(job);
        await this.saveNote(filename, content);
      }
      new import_obsidian.Notice(`Synced ${athletes.length} athletes, ${pending.length} pending queries`);
    } catch (error) {
      console.error("Sync error:", error);
      new import_obsidian.Notice("Sync failed - check connection");
    }
  }
  createAthleteSummary(name, athlete, graph) {
    const sessions = graph.sessions || [];
    const queries = graph.queries || [];
    const topics = graph.topics || [];
    let content = `---
type: athlete-summary
athlete_id: ${athlete.id}
discord_id: ${athlete.discord_id}
updated: ${new Date().toISOString().split("T")[0]}
---

# ${name}

## Overview

- **Sessions:** ${sessions.length}
- **Queries:** ${queries.length}
- **Topics:** ${topics.length}

## Topics Explored

${topics.length > 0 ? topics.map((t) => `- ${t}`).join("\n") : "*No topics yet*"}

## Recent Queries

`;
    const sortedQueries = [...queries].sort(
      (a, b) => (b.date || "").localeCompare(a.date || "")
    ).slice(0, 10);
    for (const q of sortedQueries) {
      const status = q.pending ? "\u23F3" : "\u2713";
      content += `- [${status}] ${q.topic || "Unknown"} (${q.date || "N/A"})
`;
    }
    content += `
## Recent Sessions

`;
    const sortedSessions = [...sessions].sort(
      (a, b) => (b.date || "").localeCompare(a.date || "")
    ).slice(0, 10);
    for (const s of sortedSessions) {
      const tags = (s.tags || []).join(", ");
      content += `- ${s.date || "Unknown"} - ${tags || "No tags"}
`;
    }
    return content;
  }
  createPendingQueryNote(job) {
    return `---
type: pending-query
job_id: ${job.job_id}
athlete_id: ${job.athlete_id}
athlete_name: ${job.athlete_name || "Unknown"}
submitted: ${job.submitted_at}
status: pending
---

# Query from ${job.athlete_name || "Unknown"}

**Submitted:** ${job.submitted_at}

## Question

${job.query_text}

---

## Actions

1. Run command: **Coach: Generate article for current query**
2. Edit the generated article below
3. Run command: **Coach: Push article to athlete**

---

## Generated Article

*Run "Coach: Generate article" to populate this section*

`;
  }
  async shareConceptGraphWithAthlete(file) {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const fm = frontmatterMatch[1];
    const isCluster = fm.includes("type: cluster-index");
    const isConcept = fm.includes("type: concept");
    if (!isCluster && !isConcept) {
      new import_obsidian.Notice("This file is not a concept or cluster file");
      return;
    }
    try {
      const athletes = await this.coachClient.getAthletes();
      if (athletes.length === 0) {
        new import_obsidian.Notice("No athletes found. Add athletes first.");
        return;
      }
      const modal = new AthleteSelectModal(this.app, athletes, async (selectedAthlete) => {
        var _a;
        if (!selectedAthlete)
          return;
        let graphData = {};
        let conceptName = file.basename;
        let conceptSummary = "";
        if (isCluster) {
          const clusterFolder = ((_a = file.parent) == null ? void 0 : _a.path) || "";
          const conceptFiles = this.app.vault.getMarkdownFiles().filter(
            (f) => f.path.startsWith(clusterFolder) && f.path !== file.path
          );
          const concepts = [];
          for (const cf of conceptFiles) {
            const cfContent = await this.app.vault.read(cf);
            concepts.push({
              name: cf.basename,
              content: cfContent
            });
          }
          graphData = {
            type: "cluster",
            clusterName: conceptName,
            concepts,
            indexContent: content
          };
          const summaryMatch = content.match(/## Summary\n\n([\s\S]*?)(?=\n## |$)/);
          conceptSummary = summaryMatch ? summaryMatch[1].trim().substring(0, 200) : "";
        } else {
          graphData = {
            type: "concept",
            conceptName,
            content
          };
          const summaryMatch = content.match(/## Summary\n\n([\s\S]*?)(?=\n## |$)/);
          conceptSummary = summaryMatch ? summaryMatch[1].trim().substring(0, 200) : "";
        }
        new import_obsidian.Notice(`Sharing "${conceptName}" with ${selectedAthlete.display_name || selectedAthlete.discord_username}...`);
        try {
          const result = await this.coachClient.shareConceptGraph(
            selectedAthlete.id,
            conceptName,
            conceptSummary,
            graphData
          );
          if (result.success) {
            new import_obsidian.Notice(`Shared with ${selectedAthlete.display_name || selectedAthlete.discord_username}`);
          } else {
            new import_obsidian.Notice(`Saved but Discord notification failed: ${result.message}`);
          }
        } catch (error) {
          new import_obsidian.Notice(`Failed to share: ${error.message}`);
        }
      });
      modal.open();
    } catch (error) {
      new import_obsidian.Notice(`Failed to get athletes: ${error.message}`);
    }
  }
  async shareCanvasWithAthlete(file) {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    const content = await this.app.vault.read(file);
    let canvasData;
    try {
      canvasData = JSON.parse(content);
    } catch (e) {
      new import_obsidian.Notice("Invalid canvas file");
      return;
    }
    const canvasName = file.basename;
    try {
      const athletes = await this.coachClient.getAthletes();
      if (athletes.length === 0) {
        new import_obsidian.Notice("No athletes found. Add athletes first.");
        return;
      }
      const modal = new AthleteSelectModal(this.app, athletes, async (selectedAthlete) => {
        if (!selectedAthlete)
          return;
        new import_obsidian.Notice(`Sharing canvas "${canvasName}" with ${selectedAthlete.display_name || selectedAthlete.discord_username}...`);
        try {
          const result = await this.coachClient.shareConceptGraph(
            selectedAthlete.id,
            canvasName + " (Timeline)",
            "Visual timeline canvas for training sequence",
            {
              type: "canvas",
              canvasName,
              nodes: canvasData.nodes || [],
              edges: canvasData.edges || []
            }
          );
          if (result.success) {
            if (!this.settings.sharedCanvases[file.path]) {
              this.settings.sharedCanvases[file.path] = [];
            }
            if (!this.settings.sharedCanvases[file.path].includes(selectedAthlete.id)) {
              this.settings.sharedCanvases[file.path].push(selectedAthlete.id);
            }
            await this.saveSettings();
            new import_obsidian.Notice(`Shared with ${selectedAthlete.display_name || selectedAthlete.discord_username}! Changes will auto-sync.`);
          } else {
            new import_obsidian.Notice(`Saved but Discord notification failed: ${result.message}`);
          }
        } catch (error) {
          new import_obsidian.Notice(`Failed to share: ${error.message}`);
        }
      });
      modal.open();
    } catch (error) {
      new import_obsidian.Notice(`Failed to get athletes: ${error.message}`);
    }
  }
  /**
   * Sync a shared canvas to all athletes it's shared with.
   * Called automatically when a shared canvas is modified.
   */
  async syncSharedCanvas(file, athleteIds) {
    if (!this.coachClient)
      return;
    const content = await this.app.vault.read(file);
    let canvasData;
    try {
      canvasData = JSON.parse(content);
    } catch (e) {
      return;
    }
    const canvasName = file.basename;
    for (const athleteId of athleteIds) {
      try {
        await this.coachClient.syncCanvas(
          athleteId,
          canvasName,
          {
            type: "canvas",
            canvasName,
            nodes: canvasData.nodes || [],
            edges: canvasData.edges || [],
            updatedAt: Date.now()
          }
        );
      } catch (error) {
        console.error(`Failed to sync canvas to athlete ${athleteId}:`, error);
      }
    }
    new import_obsidian.Notice(`Canvas synced to ${athleteIds.length} athlete(s)`);
  }
  /**
   * Extract WebM video clips from a Training Review article and create a Canvas with embedded clips.
   * Non-destructive: original videos are never modified, clips are created as new files.
   */
  async extractVideoClipsToCanvas(file) {
    var _a, _b;
    const content = await this.app.vault.read(file);
    if (!content.includes("type: training-review")) {
      new import_obsidian.Notice("This command works on Training Review files");
      return;
    }
    const frontmatterEnd = content.indexOf("---", 4);
    if (frontmatterEnd === -1) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const articleContent = content.substring(frontmatterEnd + 3);
    new import_obsidian.Notice("Extracting video clips... This may take a moment.", 5e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/extract-clips-webm-from-article`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          article_html: articleContent,
          duration: 60
          // 1 minute clips
        })
      });
      const data = response.json;
      const clips = data.clips || [];
      if (clips.length === 0) {
        new import_obsidian.Notice("No video clips found in article");
        return;
      }
      new import_obsidian.Notice(`Found ${clips.length} clips. Downloading...`, 5e3);
      const reviewName = file.basename;
      const clipsFolder = `${((_a = file.parent) == null ? void 0 : _a.path) || this.settings.syncFolder}/clips/${reviewName}`;
      await this.ensureFolder(clipsFolder);
      const savedClips = [];
      for (let i = 0; i < clips.length; i++) {
        const clip = clips[i];
        const clipFilename = `${clip.video_id}_${clip.start_time}s.webm`;
        const clipPath = `${clipsFolder}/${clipFilename}`;
        try {
          const clipResponse = await (0, import_obsidian.requestUrl)({
            url: `${this.settings.serverUrl}${clip.clip_url}`,
            method: "GET"
          });
          await this.app.vault.adapter.writeBinary(clipPath, clipResponse.arrayBuffer);
          savedClips.push({ path: clipPath, clip });
          new import_obsidian.Notice(`Downloaded clip ${i + 1}/${clips.length}`, 2e3);
        } catch (clipErr) {
          console.error(`Failed to download clip ${clip.clip_id}:`, clipErr);
        }
      }
      if (savedClips.length === 0) {
        new import_obsidian.Notice("Failed to download any clips");
        return;
      }
      const canvasPath = `${((_b = file.parent) == null ? void 0 : _b.path) || this.settings.syncFolder}/${reviewName} - Video Clips.canvas`;
      const nodes = [];
      const edges = [];
      let nodeId = 1;
      const clipWidth = 400;
      const clipHeight = 300;
      const spacing = 50;
      const cols = 3;
      for (let i = 0; i < savedClips.length; i++) {
        const { path, clip } = savedClips[i];
        const row = Math.floor(i / cols);
        const col = i % cols;
        nodes.push({
          id: `video-${nodeId++}`,
          type: "file",
          file: path,
          x: col * (clipWidth + spacing),
          y: row * (clipHeight + spacing + 80),
          width: clipWidth,
          height: clipHeight,
          color: "5"
          // Cyan for videos
        });
        nodes.push({
          id: `label-${nodeId++}`,
          type: "text",
          text: `**${clip.instructor}**
${clip.title}
_at ${clip.timestamp}_`,
          x: col * (clipWidth + spacing),
          y: row * (clipHeight + spacing + 80) + clipHeight + 10,
          width: clipWidth,
          height: 70,
          color: "0"
        });
      }
      nodes.unshift({
        id: "title",
        type: "text",
        text: `# Video Clips: ${reviewName}

${savedClips.length} clips extracted from training review`,
        x: 0,
        y: -120,
        width: cols * (clipWidth + spacing) - spacing,
        height: 100,
        color: "6"
        // Purple for title
      });
      const canvasContent = JSON.stringify({ nodes, edges }, null, 2);
      const existingCanvas = this.app.vault.getAbstractFileByPath(canvasPath);
      if (existingCanvas instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingCanvas, canvasContent);
      } else {
        await this.app.vault.create(canvasPath, canvasContent);
      }
      new import_obsidian.Notice(`Created video canvas with ${savedClips.length} clips!`, 5e3);
      const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
      if (canvasFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(canvasFile);
      }
    } catch (error) {
      console.error("Video clip extraction error:", error);
      new import_obsidian.Notice(`Failed to extract clips: ${error.message}`, 5e3);
    }
  }
  /**
   * Search videos for checkpoint/concept demonstrations.
   * Uses semantic search to find videos that demonstrate a specific technique.
   */
  async searchVideosForConcept(conceptName, context) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/search-videos-for-concept`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          concept: conceptName,
          context: context || "",
          max_results: 5
        })
      });
      return response.json.videos || [];
    } catch (error) {
      console.error("Video search error:", error);
      return [];
    }
  }
  /**
   * Find videos demonstrating a concept and create a canvas with clips.
   * Uses semantic search (separate from Oracle) to find matching videos.
   */
  async findVideosForConcept(file) {
    var _a, _b;
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const conceptName = file.basename;
    const summaryMatch = content.match(/## Summary\n\n([^\n#]+)/);
    const context = summaryMatch ? summaryMatch[1].trim() : "";
    new import_obsidian.Notice(`Searching for videos demonstrating "${conceptName}"...`, 5e3);
    try {
      const videos = await this.searchVideosForConcept(conceptName, context);
      if (videos.length === 0) {
        new import_obsidian.Notice(`No videos found for "${conceptName}"`, 3e3);
        return;
      }
      new import_obsidian.Notice(`Found ${videos.length} videos! Creating canvas...`, 3e3);
      const clipsFolder = `${((_a = file.parent) == null ? void 0 : _a.path) || this.settings.syncFolder}/clips/${conceptName}`;
      await this.ensureFolder(clipsFolder);
      const savedClips = [];
      for (let i = 0; i < videos.length; i++) {
        const video = videos[i];
        if (!video.clip_url)
          continue;
        const clipFilename = `${video.video_id}_${video.timestamp_seconds || 0}s.webm`;
        const clipPath = `${clipsFolder}/${clipFilename}`;
        try {
          const clipResponse = await (0, import_obsidian.requestUrl)({
            url: `${this.settings.serverUrl}${video.clip_url}`,
            method: "GET"
          });
          await this.app.vault.adapter.writeBinary(clipPath, clipResponse.arrayBuffer);
          savedClips.push({ path: clipPath, video });
          new import_obsidian.Notice(`Downloaded clip ${i + 1}/${videos.length}`, 2e3);
        } catch (err) {
          console.error(`Failed to download clip:`, err);
        }
      }
      if (savedClips.length === 0) {
        new import_obsidian.Notice("Failed to download any clips");
        return;
      }
      const canvasPath = `${((_b = file.parent) == null ? void 0 : _b.path) || this.settings.syncFolder}/${conceptName} - Videos.canvas`;
      const nodes = [];
      let nodeId = 1;
      const clipWidth = 400;
      const clipHeight = 300;
      const spacing = 50;
      const cols = 2;
      nodes.push({
        id: "title",
        type: "text",
        text: `# Videos: ${conceptName}

${savedClips.length} videos demonstrating this technique`,
        x: 0,
        y: -120,
        width: cols * (clipWidth + spacing) - spacing,
        height: 100,
        color: "6"
      });
      for (let i = 0; i < savedClips.length; i++) {
        const { path, video } = savedClips[i];
        const row = Math.floor(i / cols);
        const col = i % cols;
        nodes.push({
          id: `video-${nodeId++}`,
          type: "file",
          file: path,
          x: col * (clipWidth + spacing),
          y: row * (clipHeight + spacing + 80),
          width: clipWidth,
          height: clipHeight,
          color: "5"
        });
        nodes.push({
          id: `label-${nodeId++}`,
          type: "text",
          text: `**${video.instructor || "Unknown"}**
${video.title || ""}
_at ${video.timestamp || "0:00"}_

${video.relevance_quote || ""}`,
          x: col * (clipWidth + spacing),
          y: row * (clipHeight + spacing + 80) + clipHeight + 10,
          width: clipWidth,
          height: 100,
          color: "0"
        });
      }
      const canvasContent = JSON.stringify({ nodes, edges: [] }, null, 2);
      const existingCanvas = this.app.vault.getAbstractFileByPath(canvasPath);
      if (existingCanvas instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingCanvas, canvasContent);
      } else {
        await this.app.vault.create(canvasPath, canvasContent);
      }
      new import_obsidian.Notice(`Created video canvas for "${conceptName}"!`, 5e3);
      const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
      if (canvasFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(canvasFile);
      }
    } catch (error) {
      console.error("Find videos error:", error);
      new import_obsidian.Notice(`Failed to find videos: ${error.message}`, 5e3);
    }
  }
  /**
   * Video Explorer: Show video breakdown with clickable timestamps.
   * Click a timestamp to generate a clip on-demand.
   */
  async exploreVideoForConcept(file) {
    const content = await this.app.vault.read(file);
    const conceptName = file.basename;
    const summaryMatch = content.match(/## Summary\n\n([^\n#]+)/);
    const context = summaryMatch ? summaryMatch[1].trim() : "";
    new import_obsidian.Notice(`Searching for videos about "${conceptName}"...`, 3e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/explore-video`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          concept: conceptName,
          context
        })
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`No videos found for "${conceptName}"`, 3e3);
        return;
      }
      const modal = new VideoExplorerModal(
        this.app,
        this,
        data,
        file
      );
      modal.open();
    } catch (error) {
      console.error("Video explorer error:", error);
      new import_obsidian.Notice(`Failed to explore videos: ${error.message}`, 5e3);
    }
  }
  /**
   * Find video for Canvas node (right-click menu).
   * First tries to find linked sources from parent article, falls back to semantic search.
   */
  async findVideoForCanvasNodeDirect(node) {
    var _a;
    let conceptName = "";
    let sourceFile = null;
    let sessionId = null;
    if (node.file) {
      sourceFile = node.file;
      conceptName = sourceFile.basename;
      const cache = this.app.metadataCache.getFileCache(sourceFile);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.source_rlm_session) {
        sessionId = cache.frontmatter.source_rlm_session;
      }
    } else if (node.text) {
      const text = node.text;
      const match = text.match(/\*\*([^*]+)\*\*/) || text.match(/^#*\s*(.+)$/m);
      conceptName = match ? match[1].trim() : text.substring(0, 50).trim();
    } else if (node.label) {
      conceptName = node.label;
    }
    if (!conceptName) {
      new import_obsidian.Notice("Could not get concept name from node");
      return;
    }
    if (sessionId) {
      new import_obsidian.Notice(`Finding linked sources for "${conceptName}"...`, 3e3);
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: `${this.settings.serverUrl}/api/obsidian/sources-for-concept`,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.settings.apiToken}`
          },
          body: JSON.stringify({
            session_id: sessionId,
            concept_name: conceptName
          })
        });
        const data = response.json;
        if (data.sources && data.sources.length > 0) {
          new import_obsidian.Notice(`Found ${data.sources.length} linked sources!`, 3e3);
          const modal = new LinkedSourcesModal(
            this.app,
            this,
            data,
            sourceFile || { path: this.settings.syncFolder, parent: null, basename: conceptName }
          );
          modal.open();
          return;
        } else {
          new import_obsidian.Notice("No linked sources found, trying semantic search...", 2e3);
        }
      } catch (error) {
        console.error("Linked sources error:", error);
        new import_obsidian.Notice("Linked sources failed, trying semantic search...", 2e3);
      }
    }
    new import_obsidian.Notice(`Searching for "${conceptName}"...`, 3e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/explore-video`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({ concept: conceptName })
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`No video found for "${conceptName}"`, 3e3);
        return;
      }
      const modal = new VideoExplorerModal(
        this.app,
        this,
        data,
        sourceFile || { path: this.settings.syncFolder, parent: null, basename: conceptName }
      );
      modal.open();
    } catch (error) {
      console.error("Canvas video finder error:", error);
      new import_obsidian.Notice(`Failed: ${error.message}`, 5e3);
    }
  }
  /**
   * Explore series for Canvas node (right-click menu).
   * Uses linked sources from parent article when available.
   */
  async exploreSeriesForCanvasNode(node) {
    var _a;
    let conceptName = "";
    let sourceFile = null;
    let sessionId = null;
    if (node.file) {
      sourceFile = node.file;
      conceptName = sourceFile.basename;
      const cache = this.app.metadataCache.getFileCache(sourceFile);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.source_rlm_session) {
        sessionId = cache.frontmatter.source_rlm_session;
      }
    } else if (node.text) {
      const text = node.text;
      const match = text.match(/\*\*([^*]+)\*\*/) || text.match(/^#*\s*(.+)$/m);
      conceptName = match ? match[1].trim() : text.substring(0, 50).trim();
    } else if (node.label) {
      conceptName = node.label;
    }
    if (!conceptName) {
      new import_obsidian.Notice("Could not get concept name from node");
      return;
    }
    new import_obsidian.Notice(`Finding series for "${conceptName}"${sessionId ? " (using linked sources)" : ""}...`, 3e3);
    try {
      const requestBody = { concept: conceptName };
      if (sessionId) {
        requestBody.session_id = sessionId;
      }
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/explore-series`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify(requestBody)
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`No series found for "${conceptName}"`, 3e3);
        return;
      }
      new import_obsidian.Notice(`Found ${data.total_volumes} volumes!`, 3e3);
      const modal = new SeriesExplorerModal(
        this.app,
        this,
        data,
        sourceFile || { path: this.settings.syncFolder, parent: null, basename: conceptName }
      );
      modal.open();
    } catch (error) {
      console.error("Canvas series finder error:", error);
      new import_obsidian.Notice(`Failed: ${error.message}`, 5e3);
    }
  }
  /**
   * Show the complete bibliography of videos from the parent Oracle article.
   * User can select any video to see its full concept cache.
   */
  async showArticleBibliography(node, sessionId) {
    let sourceFile = null;
    if (node.file) {
      sourceFile = node.file;
    }
    new import_obsidian.Notice("Loading article bibliography...", 2e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/article-bibliography`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({ session_id: sessionId })
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`Error: ${data.error}`, 3e3);
        return;
      }
      new import_obsidian.Notice(`Found ${data.total_videos} source videos!`, 3e3);
      const modal = new ArticleBibliographyModal(
        this.app,
        this,
        data,
        sourceFile || { path: this.settings.syncFolder, parent: null, basename: "Article" }
      );
      modal.open();
    } catch (error) {
      console.error("Article bibliography error:", error);
      new import_obsidian.Notice(`Failed: ${error.message}`, 5e3);
    }
  }
  /**
   * Open the catalog browser for cross-reference research.
   * User can select videos to cross-reference with the concept.
   */
  async openCrossReferenceCatalog(node) {
    var _a;
    let conceptName = "";
    let conceptContext = "";
    let sourceFile = null;
    if (node.file) {
      sourceFile = node.file;
      conceptName = sourceFile.basename;
      const cache = this.app.metadataCache.getFileCache(sourceFile);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.cluster) {
        conceptContext = `Part of ${cache.frontmatter.cluster}`;
      }
    } else if (node.text) {
      const text = node.text;
      const match = text.match(/\*\*([^*]+)\*\*/) || text.match(/^#*\s*(.+)$/m);
      conceptName = match ? match[1].trim() : text.substring(0, 50).trim();
    } else if (node.label) {
      conceptName = node.label;
    }
    if (!conceptName) {
      new import_obsidian.Notice("Could not get concept name from node");
      return;
    }
    new import_obsidian.Notice(`Opening catalog for "${conceptName}"...`, 2e3);
    const modal = new CatalogBrowserModal(
      this.app,
      this,
      conceptName,
      conceptContext,
      sourceFile || { path: this.settings.syncFolder, parent: null, basename: conceptName }
    );
    modal.open();
  }
  /**
   * Open RLM Enrichment for a checkpoint.
   * Parses the checkpoint file, lets user select videos, enriches with new knowledge.
   */
  async openEnrichCheckpoint(node) {
    if (!node.file) {
      new import_obsidian.Notice("Checkpoint file not found");
      return;
    }
    const sourceFile = node.file;
    const cache = this.app.metadataCache.getFileCache(sourceFile);
    if (!(cache == null ? void 0 : cache.frontmatter) || cache.frontmatter.type !== "checkpoint") {
      new import_obsidian.Notice("This is not a checkpoint file");
      return;
    }
    const content = await this.app.vault.read(sourceFile);
    const invariablesMatch = content.match(/## INVARIABLES[\s\S]*?\|[\s\S]*?\|([\s\S]*?)(?=\n---|\n##|$)/);
    const currentInvariables = [];
    if (invariablesMatch) {
      const links = invariablesMatch[1].match(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g) || [];
      for (const link of links) {
        const nameMatch = link.match(/\[\[(?:[^\]|]+\|)?([^\]]+)\]\]/);
        if (nameMatch && nameMatch[1] !== "none") {
          currentInvariables.push(nameMatch[1].trim());
        }
      }
    }
    const variablesMatch = content.match(/## VARIABLES[\s\S]*?((?:- \*\*IF.*\n?)+)/);
    const currentVariables = [];
    if (variablesMatch) {
      const lines = variablesMatch[1].match(/- \*\*IF[^*]+\*\*[^\n]+/g) || [];
      currentVariables.push(...lines.map((l) => l.replace(/^- /, "").trim()));
    }
    const goalMatch = content.match(/## Goal\n\n([^\n]+)/);
    const goal = goalMatch ? goalMatch[1].trim() : "";
    const successMatch = content.match(/## Success Test\n\n> ([^\n]+)/);
    const successTest = successMatch ? successMatch[1].trim() : "";
    new import_obsidian.Notice(`Opening enrichment for "${sourceFile.basename}"...`, 2e3);
    const modal = new EnrichCheckpointModal(
      this.app,
      this,
      {
        name: sourceFile.basename,
        cluster: cache.frontmatter.cluster || "",
        currentInvariables,
        currentVariables,
        goal,
        successTest
      },
      sourceFile
    );
    modal.open();
  }
  /**
   * RLM Pipeline - Single button for: Backup  Enrich  Rebuild Canvas
   */
  async runRLMPipeline(canvasView) {
    var _a;
    try {
      const canvas = canvasView.canvas;
      if (!canvas) {
        new import_obsidian.Notice("Could not access canvas");
        return;
      }
      const canvasFile = canvasView.file;
      if (!canvasFile) {
        new import_obsidian.Notice("Could not determine canvas file");
        return;
      }
      const parentFolder = canvasFile.parent;
      if (!parentFolder) {
        new import_obsidian.Notice("Could not determine folder");
        return;
      }
      const canvasBasename = canvasFile.basename;
      const subfolderPath = `${parentFolder.path}/${canvasBasename}`;
      const subfolder = this.app.vault.getAbstractFileByPath(subfolderPath);
      const targetFolderPath = subfolder && subfolder instanceof import_obsidian.TFolder ? subfolderPath : parentFolder.path;
      console.log("Canvas:", canvasFile.path);
      console.log("Looking for checkpoints in:", targetFolderPath);
      const checkpointFiles = [];
      for (const file of this.app.vault.getFiles()) {
        if (file.extension !== "md")
          continue;
        if (((_a = file.parent) == null ? void 0 : _a.path) !== targetFolderPath)
          continue;
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache == null ? void 0 : cache.frontmatter;
        if ((frontmatter == null ? void 0 : frontmatter.type) === "checkpoint") {
          checkpointFiles.push(file);
          console.log("Found checkpoint:", file.basename);
        }
      }
      checkpointFiles.sort((a, b) => {
        var _a2, _b, _c, _d;
        const cacheA = this.app.metadataCache.getFileCache(a);
        const cacheB = this.app.metadataCache.getFileCache(b);
        const orderA = ((_a2 = cacheA == null ? void 0 : cacheA.frontmatter) == null ? void 0 : _a2.order) || parseInt(((_b = a.basename.match(/\[(\d+)\]/)) == null ? void 0 : _b[1]) || "99");
        const orderB = ((_c = cacheB == null ? void 0 : cacheB.frontmatter) == null ? void 0 : _c.order) || parseInt(((_d = b.basename.match(/\[(\d+)\]/)) == null ? void 0 : _d[1]) || "99");
        return orderA - orderB;
      });
      console.log("Found checkpoints:", checkpointFiles.map((f) => f.basename));
      if (checkpointFiles.length === 0) {
        new import_obsidian.Notice(`No checkpoint files found in ${targetFolderPath}. Files need frontmatter: type: checkpoint`);
        return;
      }
      const targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
      const modal = new RLMPipelineModal(
        this.app,
        this,
        canvasFile,
        targetFolder,
        checkpointFiles
      );
      modal.open();
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("RLM Pipeline error:", error);
    }
  }
  /**
   * Generate Variables canvas from current canvas folder.
   */
  async generateVariablesCanvas(canvasView) {
    try {
      const canvasFile = canvasView.file;
      if (!canvasFile) {
        new import_obsidian.Notice("Could not determine canvas file");
        return;
      }
      const parentFolder = canvasFile.parent;
      if (!parentFolder) {
        new import_obsidian.Notice("Could not determine folder");
        return;
      }
      const canvasBasename = canvasFile.basename.replace(/ - RLM$/, "").replace(/ - Variables$/, "");
      const subfolderPath = `${parentFolder.path}/${canvasBasename}`;
      const subfolder = this.app.vault.getAbstractFileByPath(subfolderPath);
      const targetFolderPath = subfolder && subfolder instanceof import_obsidian.TFolder ? subfolderPath : parentFolder.path;
      const targetFolder = this.app.vault.getAbstractFileByPath(targetFolderPath);
      new import_obsidian.Notice("Generating Variables canvas...");
      const tempModal = new RLMPipelineModal(this.app, this, canvasFile, targetFolder, []);
      const variablesPath = await tempModal.generateVariablesCanvasOnly(targetFolder, canvasBasename);
      new import_obsidian.Notice(`Variables canvas created: ${variablesPath}`);
      const varCanvasFile = this.app.vault.getAbstractFileByPath(variablesPath);
      if (varCanvasFile) {
        await this.app.workspace.getLeaf().openFile(varCanvasFile);
      }
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Generate variables canvas error:", error);
    }
  }
  /**
   * Toggle between RLM and Variables canvas.
   */
  async toggleRLMVariablesCanvas(canvasView) {
    var _a;
    try {
      const canvasFile = canvasView.file;
      if (!canvasFile) {
        new import_obsidian.Notice("Could not determine canvas file");
        return;
      }
      const currentName = canvasFile.basename;
      const folderPath = ((_a = canvasFile.parent) == null ? void 0 : _a.path) || "";
      let targetPath;
      if (currentName.endsWith(" - RLM")) {
        const baseName = currentName.replace(/ - RLM$/, "");
        targetPath = `${folderPath}/${baseName} - Variables.canvas`;
      } else if (currentName.endsWith(" - Variables")) {
        const baseName = currentName.replace(/ - Variables$/, "");
        targetPath = `${folderPath}/${baseName} - RLM.canvas`;
      } else {
        const rlmPath = `${folderPath}/${currentName} - RLM.canvas`;
        const varPath = `${folderPath}/${currentName} - Variables.canvas`;
        if (this.app.vault.getAbstractFileByPath(rlmPath)) {
          targetPath = rlmPath;
        } else if (this.app.vault.getAbstractFileByPath(varPath)) {
          targetPath = varPath;
        } else {
          new import_obsidian.Notice("No RLM or Variables canvas found");
          return;
        }
      }
      const targetFile = this.app.vault.getAbstractFileByPath(targetPath);
      if (targetFile && targetFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(targetFile);
      } else {
        new import_obsidian.Notice(`Canvas not found: ${targetPath}`);
      }
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Toggle canvas error:", error);
    }
  }
  /**
   * Rebuild Canvas from checkpoint files - proper layout with all connections.
   * This regenerates the entire canvas from the enriched markdown files.
   */
  async rebuildCanvasFromCheckpoints() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("Open a file in the checkpoint folder first");
      return;
    }
    const folder = activeFile.parent;
    if (!folder) {
      new import_obsidian.Notice("Could not determine folder");
      return;
    }
    new import_obsidian.Notice(`Scanning ${folder.path} for checkpoints...`);
    try {
      const checkpoints = [];
      const methods = [];
      for (const file of this.app.vault.getFiles()) {
        if (!file.path.startsWith(folder.path) || file.extension !== "md")
          continue;
        const cache = this.app.metadataCache.getFileCache(file);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const type = cache.frontmatter.type;
        if (type === "checkpoint") {
          const content = await this.app.vault.read(file);
          const order = cache.frontmatter.order || parseInt(((_a = file.basename.match(/^\[?(\d+)/)) == null ? void 0 : _a[1]) || "99");
          const invariables = [];
          const invMatch = content.match(/## INVARIABLES[\s\S]*?\|([\s\S]*?)(?=\n##|\n---)/);
          if (invMatch) {
            const links = invMatch[1].match(/\[\[([^\]|]+)/g) || [];
            for (const link of links) {
              const name = link.replace("[[", "").trim();
              if (name && name !== "none") {
                invariables.push(name);
              }
            }
          }
          const navigation = [];
          const navMatch = content.match(/## Navigation[\s\S]*?((?:\[\[[^\]]+\]\][^\n]*\n?)+)/);
          if (navMatch) {
            const navLinks = navMatch[1].match(/\[\[([^\]|]+)/g) || [];
            for (const link of navLinks) {
              navigation.push(link.replace("[[", "").trim());
            }
          }
          checkpoints.push({
            file,
            order,
            cluster: cache.frontmatter.cluster || "",
            invariables,
            navigation
          });
        } else if (type === "method" || type === "concept") {
          methods.push({
            file,
            tier: cache.frontmatter.tier || "REFINEMENT",
            cluster: cache.frontmatter.cluster || ""
          });
        }
      }
      if (checkpoints.length === 0) {
        new import_obsidian.Notice("No checkpoint files found in this folder");
        return;
      }
      checkpoints.sort((a, b) => a.order - b.order);
      new import_obsidian.Notice(`Found ${checkpoints.length} checkpoints, ${methods.length} methods. Building canvas...`);
      const canvasData = {
        nodes: [],
        edges: []
      };
      const checkpointWidth = 300;
      const checkpointHeight = 150;
      const methodWidth = 200;
      const methodHeight = 80;
      const horizontalGap = 400;
      const verticalGap = 200;
      const methodOffsetX = 350;
      const methodGap = 100;
      let currentX = 100;
      const checkpointY = 300;
      const nodeIdMap = /* @__PURE__ */ new Map();
      for (let i = 0; i < checkpoints.length; i++) {
        const cp = checkpoints[i];
        const nodeId = `checkpoint-${i}`;
        nodeIdMap.set(cp.file.basename, nodeId);
        canvasData.nodes.push({
          id: nodeId,
          type: "file",
          file: cp.file.path,
          x: currentX,
          y: checkpointY,
          width: checkpointWidth,
          height: checkpointHeight,
          color: "4"
          // Blue for checkpoints
        });
        let methodY = checkpointY - methodGap - methodHeight;
        for (const invName of cp.invariables) {
          const methodFile = methods.find((m) => m.file.basename === invName);
          if (methodFile) {
            const methodId = `method-${nodeIdMap.size}`;
            nodeIdMap.set(invName, methodId);
            canvasData.nodes.push({
              id: methodId,
              type: "file",
              file: methodFile.file.path,
              x: currentX + methodOffsetX,
              y: methodY,
              width: methodWidth,
              height: methodHeight,
              color: methodFile.tier === "CRITICAL" ? "1" : methodFile.tier === "IMPORTANT" ? "6" : "0"
            });
            canvasData.edges.push({
              id: `edge-${canvasData.edges.length}`,
              fromNode: nodeId,
              fromSide: "right",
              toNode: methodId,
              toSide: "left"
            });
            methodY -= methodHeight + 30;
          }
        }
        if (i < checkpoints.length - 1) {
          canvasData.edges.push({
            id: `edge-cp-${i}`,
            fromNode: nodeId,
            fromSide: "right",
            toNode: `checkpoint-${i + 1}`,
            toSide: "left",
            color: "5"
          });
        }
        currentX += horizontalGap;
      }
      for (const cp of checkpoints) {
        const fromId = nodeIdMap.get(cp.file.basename);
        for (const navTarget of cp.navigation) {
          const toId = nodeIdMap.get(navTarget);
          if (fromId && toId && fromId !== toId) {
            const exists = canvasData.edges.some(
              (e) => e.fromNode === fromId && e.toNode === toId
            );
            if (!exists) {
              canvasData.edges.push({
                id: `edge-nav-${canvasData.edges.length}`,
                fromNode: fromId,
                fromSide: "bottom",
                toNode: toId,
                toSide: "top",
                color: "3"
                // Green for navigation
              });
            }
          }
        }
      }
      const canvasPath = `${folder.path}/${folder.name} - Generated.canvas`;
      const canvasContent = JSON.stringify(canvasData, null, 2);
      const existingCanvas = this.app.vault.getAbstractFileByPath(canvasPath);
      if (existingCanvas) {
        await this.app.vault.modify(existingCanvas, canvasContent);
      } else {
        await this.app.vault.create(canvasPath, canvasContent);
      }
      new import_obsidian.Notice(`Canvas created: ${canvasPath}`);
      const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
      if (canvasFile) {
        await this.app.workspace.getLeaf().openFile(canvasFile);
      }
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Rebuild canvas error:", error);
    }
  }
  /**
   * Extract WebM clip from a method node - shows clip browser with options.
   */
  async extractClipFromMethod(file, frontmatter) {
    const { video_id, source_instructor } = frontmatter;
    const conceptName = file.basename;
    if (!video_id) {
      new import_obsidian.Notice("No video_id found - cannot extract clip");
      return;
    }
    new import_obsidian.Notice(`Finding clip options for "${conceptName}"...`);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/clip-options`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          video_id,
          concept: conceptName,
          instructor: source_instructor || ""
        })
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`Error: ${data.error}`);
        return;
      }
      const modal = new ClipBrowserModal(
        this.app,
        this,
        file,
        data
      );
      modal.open();
    } catch (error) {
      new import_obsidian.Notice(`Error finding clips: ${error.message}`);
      console.error("Clip options error:", error);
    }
  }
  /**
   * Actually extract a WebM clip after user selects it.
   */
  /**
   * Fetch a 60s clip and attach it as a new node on the canvas.
   */
  async fetchClipAndAttachNode(node, frontmatter) {
    var _a;
    const { video_id, timestamp } = frontmatter;
    const file = node.file;
    if (!video_id) {
      new import_obsidian.Notice("No video_id in frontmatter");
      return;
    }
    let startSeconds = 0;
    if (timestamp) {
      const parts = timestamp.split(":").map((p) => parseInt(p, 10));
      if (parts.length === 3) {
        startSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
      } else if (parts.length === 2) {
        startSeconds = parts[0] * 60 + parts[1];
      }
    }
    new import_obsidian.Notice(`Fetching 60s clip from ${timestamp || "0:00"}...`);
    try {
      const parentPath = ((_a = file.parent) == null ? void 0 : _a.path) || "";
      const vaultFolder = `${parentPath}/clips`;
      const clipName = `${file.basename}_clip_${(timestamp == null ? void 0 : timestamp.replace(/:/g, "-")) || "start"}`;
      const clipPath = await this.doExtractClip(video_id, startSeconds, 60, clipName, vaultFolder);
      if (!clipPath) {
        new import_obsidian.Notice("Failed to extract clip");
        return;
      }
      new import_obsidian.Notice(`Clip extracted: ${clipPath}`);
      const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
      if (!canvasView || canvasView.getViewType() !== "canvas") {
        new import_obsidian.Notice("Canvas not active - clip saved but node not added");
        return;
      }
      const canvas = canvasView.canvas;
      if (!canvas) {
        new import_obsidian.Notice("Could not access canvas");
        return;
      }
      const clipFile = this.app.vault.getAbstractFileByPath(clipPath);
      if (clipFile && clipFile instanceof import_obsidian.TFile) {
        const newNode = canvas.createFileNode({
          file: clipFile,
          pos: {
            x: node.x + node.width + 50,
            y: node.y
          },
          size: {
            width: 320,
            height: 240
          }
        });
        try {
          if (canvas.createEdge) {
            canvas.createEdge({
              fromNode: node,
              fromSide: "right",
              toNode: newNode,
              toSide: "left"
            });
          }
        } catch (e) {
        }
        canvas.requestSave();
        new import_obsidian.Notice(`Clip node added to canvas`);
      } else {
        new import_obsidian.Notice(`Clip saved at ${clipPath} but file not found in vault`);
      }
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Fetch clip error:", error);
    }
  }
  /**
   * Extract clip directly at the timestamp specified in frontmatter.
   * Adds the clip as a new canvas node.
   */
  async extractClipDirect(node, frontmatter) {
    var _a;
    const { video_id, timestamp } = frontmatter;
    const file = node.file;
    if (!video_id) {
      new import_obsidian.Notice("No video_id in frontmatter");
      return;
    }
    if (!timestamp) {
      new import_obsidian.Notice("No timestamp in frontmatter");
      return;
    }
    const parts = timestamp.split(":").map((p) => parseInt(p, 10));
    let startSeconds = 0;
    if (parts.length === 3) {
      startSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
    } else if (parts.length === 2) {
      startSeconds = parts[0] * 60 + parts[1];
    }
    new import_obsidian.Notice(`Extracting 2min clip at ${timestamp}...`);
    try {
      const parentPath = ((_a = file.parent) == null ? void 0 : _a.path) || "";
      const vaultFolder = `${parentPath}/clips`;
      const safeName = `${file.basename}_${timestamp.replace(/:/g, "-")}`;
      const clipPath = await this.doExtractClip(video_id, startSeconds, 120, safeName, vaultFolder);
      if (!clipPath) {
        new import_obsidian.Notice("Failed to extract clip");
        return;
      }
      new import_obsidian.Notice(`Clip extracted: ${clipPath}`);
      const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
      if (!canvasView || canvasView.getViewType() !== "canvas") {
        new import_obsidian.Notice("Canvas not active - clip saved but node not added");
        return;
      }
      const canvas = canvasView.canvas;
      if (!canvas) {
        new import_obsidian.Notice("Could not access canvas");
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
      const clipFile = this.app.vault.getAbstractFileByPath(clipPath);
      if (clipFile && clipFile instanceof import_obsidian.TFile) {
        const clipNode = canvas.createFileNode({
          file: clipFile,
          pos: {
            x: node.x + node.width + 30,
            y: node.y + 20
          },
          size: {
            width: 200,
            height: 150
          }
        });
        if (clipNode) {
          canvas.addEdge({
            fromNode: node,
            fromSide: "right",
            toNode: clipNode,
            toSide: "left"
          });
        }
        canvas.requestSave();
        new import_obsidian.Notice(`Clip linked at ${timestamp}`);
      } else {
        new import_obsidian.Notice(`Clip saved but not found in vault: ${clipPath}`);
      }
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Extract clip error:", error);
    }
  }
  /**
   * Open Concept Cache viewer with clickable timestamps for clip extraction.
   * Clicking a timestamp extracts a clip and adds it as a canvas node.
   */
  async openConceptCacheForClips(node, frontmatter) {
    const { video_id } = frontmatter;
    const file = node.file;
    if (!video_id) {
      new import_obsidian.Notice("No video_id in frontmatter");
      return;
    }
    new import_obsidian.Notice(`Loading concept cache for ${video_id}...`);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/concept-cache/${video_id}`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.apiToken}`
        }
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`Error: ${data.error}`);
        return;
      }
      const modal = new ConceptCacheClipsModal(
        this.app,
        this,
        node,
        file,
        data
      );
      modal.open();
    } catch (error) {
      new import_obsidian.Notice(`Error loading concept cache: ${error.message}`);
      console.error("Concept cache error:", error);
    }
  }
  async doExtractClip(videoId, startTime, duration, outputName, vaultFolder) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/extract-clip`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          video_id: videoId,
          start_time: startTime,
          duration,
          output_name: outputName,
          vault_folder: vaultFolder || ""
        })
      });
      const data = response.json;
      if (data.clip_path) {
        return data.clip_path;
      }
      return null;
    } catch (error) {
      console.error("Extract clip error:", error);
      return null;
    }
  }
  /**
   * Find video for selected Canvas node.
   * Shows concept cache with clickable timestamps.
   */
  async findVideoForCanvasNode(canvasView) {
    try {
      const canvas = canvasView.canvas;
      if (!canvas) {
        new import_obsidian.Notice("Could not access canvas");
        return;
      }
      const selection = canvas.selection;
      if (!selection || selection.size === 0) {
        new import_obsidian.Notice("Select a concept node in the canvas first");
        return;
      }
      const selectedNode = Array.from(selection)[0];
      let conceptName = "";
      let sourceFile = null;
      if (selectedNode.file) {
        sourceFile = selectedNode.file;
        conceptName = sourceFile.basename;
      } else if (selectedNode.text) {
        const text = selectedNode.text;
        const match = text.match(/\*\*([^*]+)\*\*/) || text.match(/^#*\s*(.+)$/m);
        conceptName = match ? match[1].trim() : text.substring(0, 50).trim();
      } else {
        new import_obsidian.Notice("Select a concept node (file or text node)");
        return;
      }
      if (!conceptName) {
        new import_obsidian.Notice("Could not determine concept name from node");
        return;
      }
      new import_obsidian.Notice(`Finding video for "${conceptName}"...`, 3e3);
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/explore-video`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          concept: conceptName
        })
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`No video found for "${conceptName}"`, 3e3);
        return;
      }
      const tempFile = sourceFile || this.app.vault.getAbstractFileByPath(
        `${this.settings.syncFolder}/temp-concept.md`
      );
      const modal = new VideoExplorerModal(
        this.app,
        this,
        data,
        tempFile || { path: this.settings.syncFolder, parent: null, basename: conceptName }
      );
      modal.open();
    } catch (error) {
      console.error("Canvas video finder error:", error);
      new import_obsidian.Notice(`Failed to find video: ${error.message}`, 5e3);
    }
  }
  /**
   * Series Explorer: Show all volumes in a video series with clickable timestamps.
   */
  async exploreSeriesForConcept(file) {
    const content = await this.app.vault.read(file);
    const conceptName = file.basename;
    new import_obsidian.Notice(`Searching for video series about "${conceptName}"...`, 3e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/explore-series`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          concept: conceptName
        })
      });
      const data = response.json;
      if (data.error) {
        new import_obsidian.Notice(`No video series found for "${conceptName}"`, 3e3);
        return;
      }
      new import_obsidian.Notice(`Found ${data.total_volumes} volumes in "${data.series_name}"!`, 3e3);
      const modal = new SeriesExplorerModal(
        this.app,
        this,
        data,
        file
      );
      modal.open();
    } catch (error) {
      console.error("Series explorer error:", error);
      new import_obsidian.Notice(`Failed to explore series: ${error.message}`, 5e3);
    }
  }
  /**
   * Generate a clip on-demand and save to vault.
   */
  async generateClipOnDemand(videoId, timestampSeconds, targetFolder) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/generate-clip-on-demand`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          video_id: videoId,
          timestamp_seconds: timestampSeconds,
          duration: 60
        })
      });
      const clipData = response.json;
      if (!clipData.clip_url) {
        return null;
      }
      const clipResponse = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}${clipData.clip_url}`,
        method: "GET"
      });
      const clipFilename = `${videoId}_${timestampSeconds}s.webm`;
      const clipPath = `${targetFolder}/${clipFilename}`;
      await this.ensureFolder(targetFolder);
      await this.app.vault.adapter.writeBinary(clipPath, clipResponse.arrayBuffer);
      return clipPath;
    } catch (error) {
      console.error("Clip generation error:", error);
      return null;
    }
  }
  async coachShowPending() {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    try {
      const pending = await this.coachClient.getPendingJobs();
      if (pending.length === 0) {
        new import_obsidian.Notice("No pending queries");
        return;
      }
      const inboxFolder = `${this.settings.syncFolder}/Inbox`;
      await this.ensureFolder(inboxFolder);
      for (const job of pending) {
        const filename = `${inboxFolder}/${job.job_id.substring(0, 8)} - ${job.athlete_name || "Unknown"}.md`;
        if (!await this.app.vault.adapter.exists(filename)) {
          const content = this.createPendingQueryNote(job);
          await this.saveNote(filename, content);
        }
      }
      new import_obsidian.Notice(`${pending.length} pending queries in Inbox`);
      const firstFile = this.app.vault.getAbstractFileByPath(
        `${inboxFolder}/${pending[0].job_id.substring(0, 8)} - ${pending[0].athlete_name || "Unknown"}.md`
      );
      if (firstFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(firstFile);
      }
    } catch (error) {
      console.error("Error fetching pending:", error);
      new import_obsidian.Notice("Failed to fetch pending queries");
    }
  }
  async coachGenerateArticle(view) {
    var _a, _b;
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    const file = view.file;
    if (!file)
      return;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!(frontmatter == null ? void 0 : frontmatter.job_id)) {
      new import_obsidian.Notice("Not a pending query note (no job_id in frontmatter)");
      return;
    }
    const jobId = frontmatter.job_id;
    const query = frontmatter.query_text || await this.extractQueryFromNote(view);
    if (!query) {
      new import_obsidian.Notice("Could not find query text");
      return;
    }
    new import_obsidian.Notice("Claiming job and generating article...");
    try {
      await this.coachClient.claimJob(jobId);
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/research`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, user_id: "coach" })
      });
      const article = response.json.article || ((_a = response.json.research) == null ? void 0 : _a.article_raw) || "";
      const sources = response.json.sources || ((_b = response.json.research) == null ? void 0 : _b.sources) || [];
      let content = await this.app.vault.read(file);
      const placeholder = '*Run "Coach: Generate article" to populate this section*';
      if (content.includes(placeholder)) {
        content = content.replace(placeholder, article);
      } else {
        content += `

${article}`;
      }
      content = content.replace("status: pending", "status: draft");
      await this.app.vault.modify(file, content);
      const draftsFolder = `${this.settings.syncFolder}/Drafts`;
      await this.ensureFolder(draftsFolder);
      const newPath = `${draftsFolder}/${file.name}`;
      await this.app.fileManager.renameFile(file, newPath);
      new import_obsidian.Notice("Article generated! Edit and then push to athlete.");
    } catch (error) {
      console.error("Generate error:", error);
      new import_obsidian.Notice("Failed to generate article");
    }
  }
  async extractQueryFromNote(view) {
    const content = view.getViewData();
    const match = content.match(/## Question\n\n([\s\S]*?)(?=\n---|\n##|$)/);
    return match ? match[1].trim() : null;
  }
  async coachPushArticle(view) {
    var _a;
    console.log("[Flipmode] coachPushArticle called");
    new import_obsidian.Notice("Starting push...");
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured - check settings");
      console.log("[Flipmode] coachClient is null, mode:", this.settings.mode, "token:", (_a = this.settings.coachToken) == null ? void 0 : _a.substring(0, 8));
      return;
    }
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      console.log("[Flipmode] No file in view");
      return;
    }
    const content = await this.app.vault.read(file);
    console.log("[Flipmode] Push article - file:", file.path);
    let jobId = null;
    let athleteName = null;
    let sourceFile = null;
    let fileType = null;
    const fmMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
    if (fmMatch) {
      const fmContent = fmMatch[1];
      const typeMatch = fmContent.match(/type:\s*(.+)/);
      const jobIdMatch = fmContent.match(/job_id:\s*(.+)/);
      const athleteMatch = fmContent.match(/athlete_name:\s*(.+)/);
      const sourceMatch = fmContent.match(/source_file:\s*"?\[\[([^\]]+)\]\]"?/);
      if (typeMatch)
        fileType = typeMatch[1].trim();
      if (jobIdMatch)
        jobId = jobIdMatch[1].trim();
      if (athleteMatch)
        athleteName = athleteMatch[1].trim();
      if (sourceMatch)
        sourceFile = sourceMatch[1].trim();
    }
    console.log("[Flipmode] File type:", fileType, "job_id:", jobId, "source_file:", sourceFile);
    if (fileType === "training-review" && sourceFile && !jobId) {
      console.log("[Flipmode] Training Review - looking up source query:", sourceFile);
      const sourceFilePath = this.app.metadataCache.getFirstLinkpathDest(sourceFile, file.path);
      if (sourceFilePath) {
        const sourceContent = await this.app.vault.read(sourceFilePath);
        const sourceFmMatch = sourceContent.match(/^---\r?\n([\s\S]*?)\r?\n---/);
        if (sourceFmMatch) {
          const sourceFm = sourceFmMatch[1];
          const sourceJobId = sourceFm.match(/job_id:\s*(.+)/);
          const sourceAthlete = sourceFm.match(/athlete_name:\s*(.+)/);
          if (sourceJobId)
            jobId = sourceJobId[1].trim();
          if (sourceAthlete)
            athleteName = sourceAthlete[1].trim();
          console.log("[Flipmode] Got from source - job_id:", jobId, "athlete:", athleteName);
        }
      } else {
        console.log("[Flipmode] Could not find source file:", sourceFile);
      }
    }
    if (!jobId) {
      new import_obsidian.Notice("Cannot push: no job_id found (check source query link)");
      return;
    }
    let article;
    if (fileType === "training-review") {
      const contentAfterFm = content.replace(/^---\r?\n[\s\S]*?\r?\n---\r?\n/, "");
      article = contentAfterFm.replace(/> \[!warning\][\s\S]*?(?=\n## |\n# )/g, "").replace(/## Listen to Review[\s\S]*?(?=\n## |\n# )/g, "").replace(/## Deep Dive[\s\S]*?(?=\n## |$)/g, "").replace(/## Links[\s\S]*$/g, "").trim();
    } else {
      const articleMatch = content.match(/## Generated Article\n\n([\s\S]*?)$/);
      article = articleMatch ? articleMatch[1].trim() : "";
    }
    if (!article || article.includes('Run "Coach: Generate article"')) {
      new import_obsidian.Notice("No article content to push");
      return;
    }
    console.log("[Flipmode] Article length:", article.length);
    new import_obsidian.Notice("Pushing to athlete...");
    try {
      try {
        await this.coachClient.claimJob(jobId);
        console.log("[Flipmode] Job claimed");
      } catch (claimErr) {
        console.log("[Flipmode] Claim skipped (may already be processing):", claimErr);
      }
      const success = await this.coachClient.completeJob(jobId, article, []);
      if (success) {
        let updatedContent = content.replace("status: draft", "status: synced");
        updatedContent = updatedContent.replace("status: pending", "status: synced");
        await this.app.vault.modify(file, updatedContent);
        const sentFolder = `${this.settings.syncFolder}/Sent`;
        await this.ensureFolder(sentFolder);
        const baseName = file.basename.replace(/ \[synced\]$/, "");
        const newFileName = `${baseName} [synced].md`;
        const newPath = `${sentFolder}/${newFileName}`;
        await this.app.fileManager.renameFile(file, newPath);
        if (sourceFile) {
          const sourceFilePath = this.app.metadataCache.getFirstLinkpathDest(sourceFile, file.path);
          if (sourceFilePath) {
            const sourceContent = await this.app.vault.read(sourceFilePath);
            const updatedSource = sourceContent.replace("status: pending", "status: synced");
            await this.app.vault.modify(sourceFilePath, updatedSource);
          }
        }
        new import_obsidian.Notice(`Pushed to ${athleteName || "athlete"}!`);
      } else {
        new import_obsidian.Notice("Failed to push - check connection");
      }
    } catch (error) {
      console.error("Push error:", error);
      new import_obsidian.Notice("Failed to push article");
    }
  }
  async coachPushConcepts() {
    var _a, _b;
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    const conceptsFolder = `${this.settings.syncFolder}/${this.settings.conceptsSubfolder}`;
    const conceptFiles = this.app.vault.getMarkdownFiles().filter(
      (f) => f.path.startsWith(conceptsFolder) && !f.basename.startsWith("_")
    );
    if (conceptFiles.length === 0) {
      new import_obsidian.Notice('No concepts found. Use "Explode to Concept Graph" first.');
      return;
    }
    const concepts = [];
    for (const file of conceptFiles) {
      const content = await this.app.vault.read(file);
      const fmMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
      if (!fmMatch)
        continue;
      const fm = fmMatch[1];
      const name = file.basename;
      const category = ((_a = fm.match(/tags:.*?(\w+)\]$/m)) == null ? void 0 : _a[1]) || "technique";
      const parent = ((_b = fm.match(/parent:\s*"([^"]+)"/)) == null ? void 0 : _b[1]) || null;
      const summaryMatch = content.match(/## Summary\n\n([\s\S]*?)(?=\n## |$)/);
      const summary = summaryMatch ? summaryMatch[1].trim() : "";
      const prereqMatch = content.match(/## Prerequisites\n\n([\s\S]*?)(?=\n## |$)/);
      const leadsToMatch = content.match(/## Leads To\n\n([\s\S]*?)(?=\n## |$)/);
      const countersMatch = content.match(/## Counters\n\n([\s\S]*?)(?=\n## |$)/);
      const relatedMatch = content.match(/## Related Concepts\n\n([\s\S]*?)(?=\n## |$)/);
      const extractLinks = (text) => {
        if (!text)
          return [];
        const links = text.match(/\[\[([^\]]+)\]\]/g) || [];
        return links.map((l) => l.replace(/\[\[|\]\]/g, ""));
      };
      concepts.push({
        name,
        category,
        parent,
        summary,
        prerequisites: extractLinks(prereqMatch == null ? void 0 : prereqMatch[1]),
        leads_to: extractLinks(leadsToMatch == null ? void 0 : leadsToMatch[1]),
        counters: extractLinks(countersMatch == null ? void 0 : countersMatch[1]),
        related: extractLinks(relatedMatch == null ? void 0 : relatedMatch[1])
      });
    }
    if (concepts.length === 0) {
      new import_obsidian.Notice("No valid concepts found");
      return;
    }
    new CoachPushConceptsModal(this.app, this, concepts).open();
  }
  async coachAddAthlete() {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    new CoachAddAthleteModal(this.app, this).open();
  }
  async ensureFolder(path) {
    if (!await this.app.vault.adapter.exists(path)) {
      await this.app.vault.createFolder(path);
    }
  }
  async saveNote(path, content) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existing, content);
    } else {
      await this.app.vault.create(path, content);
    }
  }
  // Remote mode methods
  initRemoteMode() {
    this.queueClient = new RemoteQueueClient(
      this.settings.queueServiceUrl,
      this.settings.athleteToken
    );
    this.startResultPolling();
    this.startCanvasPolling();
    this.updateStatusBar("Remote Mode");
  }
  startCanvasPolling() {
    if (this.canvasPollIntervalId) {
      window.clearInterval(this.canvasPollIntervalId);
    }
    this.canvasPollIntervalId = window.setInterval(
      () => this.pollCanvasUpdates(),
      3e4
    );
    this.pollCanvasUpdates();
  }
  async pollCanvasUpdates() {
    if (!this.queueClient)
      return;
    try {
      const canvases = await this.queueClient.getCanvases(this.lastCanvasSync || void 0);
      if (Object.keys(canvases).length === 0)
        return;
      for (const [canvasName, canvasInfo] of Object.entries(canvases)) {
        await this.syncCanvasToVault(canvasName, canvasInfo.data);
      }
      this.lastCanvasSync = new Date().toISOString();
      new import_obsidian.Notice(`Synced ${Object.keys(canvases).length} canvas update(s) from coach`);
    } catch (error) {
      console.error("Canvas poll error:", error);
    }
  }
  async syncCanvasToVault(canvasName, canvasData) {
    const coachFolder = `${this.settings.syncFolder}/Coach`;
    await this.ensureFolder(coachFolder);
    const canvasPath = `${coachFolder}/${canvasName}.canvas`;
    const canvasContent = JSON.stringify({
      nodes: canvasData.nodes || [],
      edges: canvasData.edges || []
    }, null, 2);
    const existingFile = this.app.vault.getAbstractFileByPath(canvasPath);
    if (existingFile && existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, canvasContent);
    } else {
      await this.app.vault.create(canvasPath, canvasContent);
    }
    console.log(`[Canvas Sync] Saved ${canvasName} to ${canvasPath}`);
  }
  startResultPolling() {
    if (this.pollIntervalId) {
      window.clearInterval(this.pollIntervalId);
    }
    this.pollIntervalId = window.setInterval(
      () => this.pollPendingJobs(),
      this.settings.pollInterval * 1e3
    );
  }
  async pollPendingJobs() {
    if (!this.queueClient || this.pendingJobs.size === 0)
      return;
    for (const [jobId, job] of this.pendingJobs.entries()) {
      if (job.status === "complete" || job.status === "error")
        continue;
      try {
        const status = await this.queueClient.checkStatus(jobId);
        if (status.status === "complete") {
          const result = await this.queueClient.getResult(jobId);
          if (result.error) {
            job.status = "error";
            new import_obsidian.Notice(`Query failed: ${result.error}`);
          } else {
            job.status = "complete";
            const filename = await this.saveArticleToVault(job.query, result.article);
            new import_obsidian.Notice(`Research ready! Saved to ${filename}`);
            this.pendingJobs.delete(jobId);
          }
        } else if (status.status === "processing") {
          job.status = "processing";
        } else if (status.status === "error") {
          job.status = "error";
          this.pendingJobs.delete(jobId);
        }
      } catch (error) {
        console.error(`Error polling job ${jobId}:`, error);
      }
    }
  }
  async submitToCoach(query, therapyContext) {
    if (!this.queueClient) {
      new import_obsidian.Notice("Remote mode not configured. Check settings.");
      return null;
    }
    try {
      const { jobId } = await this.queueClient.submitQuery(query, therapyContext);
      this.pendingJobs.set(jobId, {
        jobId,
        query,
        submittedAt: new Date(),
        status: "pending"
      });
      await this.createPendingJobNote(jobId, query);
      new import_obsidian.Notice("Query sent to Oracle! You'll be notified when ready.");
      return jobId;
    } catch (error) {
      console.error("Failed to submit query:", error);
      new import_obsidian.Notice("Failed to send query to Oracle. Check your connection.");
      return null;
    }
  }
  async createPendingJobNote(jobId, query) {
    const date = new Date().toISOString().split("T")[0];
    const time = new Date().toLocaleTimeString();
    const cleanQuery = query.substring(0, 40).replace(/[\\/:*?"<>|]/g, "-");
    const folder = `${this.settings.syncFolder}/Pending`;
    const folderObj = this.app.vault.getAbstractFileByPath(folder);
    if (!folderObj) {
      await this.app.vault.createFolder(folder);
    }
    const filename = `${folder}/${date} - ${cleanQuery}.md`;
    const content = `---
type: pending-query
job_id: ${jobId}
submitted: ${date} ${time}
status: pending
---

# Pending Query

**Submitted:** ${date} ${time}

**Query:** ${query}

---

*Waiting for Oracle to process...*

This note will be updated when results are ready.
`;
    await this.app.vault.create(filename, content);
  }
  showPendingJobsModal() {
    new PendingJobsModal(this.app, this).open();
  }
  async connectWithDiscord() {
    if (!this.settings.queueServiceUrl) {
      new import_obsidian.Notice("Configure Queue Service URL in settings first");
      return;
    }
    const authUrl = `${this.settings.queueServiceUrl}/auth/discord`;
    window.open(authUrl, "_blank");
    new import_obsidian.Notice("Complete Discord login in browser, then paste your token in settings");
  }
  async syncGraphToCoach() {
    if (!this.queueClient)
      return;
    try {
      const files = this.app.vault.getMarkdownFiles();
      const flipmodeFiles = files.filter((f) => f.path.startsWith(this.settings.syncFolder));
      const graphData = {
        sessions: [],
        queries: [],
        topics: []
      };
      for (const file of flipmodeFiles) {
        const cache = this.app.metadataCache.getFileCache(file);
        const fm = (cache == null ? void 0 : cache.frontmatter) || {};
        const type = fm.type;
        if (type === "training-session") {
          graphData.sessions.push({
            date: fm.date,
            tags: fm.tags || []
          });
        }
        if (type === "research" && fm.topic) {
          graphData.queries.push({
            topic: fm.topic,
            date: fm.date
          });
          graphData.topics.push(fm.topic);
        }
        if (type === "pending-query") {
          graphData.queries.push({
            topic: fm.query || file.basename,
            date: fm.submitted,
            pending: true
          });
        }
      }
      graphData.topics = [...new Set(graphData.topics)];
      await this.queueClient.syncGraph(graphData);
      new import_obsidian.Notice(`Synced: ${graphData.sessions.length} sessions, ${graphData.queries.length} queries`);
    } catch (error) {
      console.error("Graph sync error:", error);
      new import_obsidian.Notice("Failed to sync graph");
    }
  }
  onunload() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    if (this.pollIntervalId) {
      window.clearInterval(this.pollIntervalId);
    }
    if (this.canvasPollIntervalId) {
      window.clearInterval(this.canvasPollIntervalId);
    }
  }
  async syncFromCoach() {
    if (!this.queueClient) {
      new import_obsidian.Notice("Remote mode not configured - check settings");
      return;
    }
    new import_obsidian.Notice("Checking for completed research...");
    try {
      const jobs = await this.queueClient.listJobs();
      const completedJobs = jobs.filter((j) => j.status === "complete");
      if (completedJobs.length === 0) {
        new import_obsidian.Notice("No completed research to sync");
        return;
      }
      let synced = 0;
      for (const job of completedJobs) {
        const existingFile = this.findFileByJobId(job.job_id);
        if (existingFile) {
          console.log("[Flipmode] Already synced:", job.job_id);
          continue;
        }
        const result = await this.queueClient.getResult(job.job_id);
        if (result.article) {
          const filename = await this.saveCoachArticleToVault(job, result);
          console.log("[Flipmode] Synced:", filename);
          synced++;
        }
      }
      let conceptsSynced = 0;
      try {
        const concepts = await this.queueClient.getConcepts();
        if (concepts.length > 0) {
          conceptsSynced = await this.syncConceptsToVault(concepts);
        }
      } catch (err) {
        console.log("[Flipmode] No concepts to sync or error:", err);
      }
      if (synced > 0 || conceptsSynced > 0) {
        const msg = [];
        if (synced > 0)
          msg.push(`${synced} research article(s)`);
        if (conceptsSynced > 0)
          msg.push(`${conceptsSynced} concept(s)`);
        new import_obsidian.Notice(`Synced ${msg.join(" and ")} from Oracle!`);
      } else {
        new import_obsidian.Notice("All research already synced");
      }
    } catch (error) {
      console.error("[Flipmode] Sync error:", error);
      new import_obsidian.Notice("Failed to sync from Oracle");
    }
  }
  async syncConceptsToVault(concepts) {
    var _a;
    const folder = `${this.settings.syncFolder}/${this.settings.conceptsSubfolder}`;
    await this.ensureFolder(folder);
    let created = 0;
    for (const concept of concepts) {
      const conceptName = concept.name.replace(/[^\w\s-]/g, "").trim();
      const conceptPath = `${folder}/${conceptName}.md`;
      const existing = this.app.vault.getAbstractFileByPath(conceptPath);
      if (existing)
        continue;
      const parentLink = concept.parent ? `[[${concept.parent}]]` : "Root concept";
      const prereqLinks = (concept.prerequisites || []).map((p) => `- [[${p}]]`).join("\n") || "- None";
      const leadsToLinks = (concept.leads_to || []).map((l) => `- [[${l}]]`).join("\n") || "- None";
      const counterLinks = (concept.counters || []).map((c) => `- [[${c}]]`).join("\n") || "- None";
      const relatedLinks = (concept.related || []).map((r) => `- [[${r}]]`).join("\n") || "- None";
      const content = `---
type: concept
parent: "${concept.parent || ""}"
tags: [concept, grappling, ${((_a = concept.category) == null ? void 0 : _a.toLowerCase()) || "technique"}]
---

# ${concept.name}

**Category:** ${concept.category || "Technique"}
**Parent:** ${parentLink}

## Summary

${concept.summary || "No summary available."}

## Prerequisites

${prereqLinks}

## Leads To

${leadsToLinks}

## Counters

${counterLinks}

## Related Concepts

${relatedLinks}
`;
      await this.app.vault.create(conceptPath, content);
      created++;
    }
    return created;
  }
  findFileByJobId(jobId) {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.job_id) === jobId) {
        return file;
      }
    }
    return null;
  }
  async saveCoachArticleToVault(job, result) {
    const folder = `${this.settings.syncFolder}/Research`;
    await this.ensureFolder(folder);
    const date = new Date().toISOString().split("T")[0];
    const shortQuery = (job.enriched_query || job.query_text || "Research").substring(0, 50).replace(/[^\w\s-]/g, "").trim();
    const filename = `${folder}/${date} - ${shortQuery}.md`;
    const content = `---
type: oracle-research
job_id: ${job.job_id}
query: "${job.enriched_query || job.query_text}"
received: ${new Date().toISOString()}
rlm_session_id: ${result.rlm_session_id || ""}
tags: [bjj, research, from-oracle]
---

# Research: ${shortQuery}

${result.article}

---
*Research provided by Oracle*
`;
    await this.app.vault.create(filename, content);
    return filename;
  }
  isRemoteMode() {
    return this.settings.mode === "remote" && !!this.queueClient;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  updateStatusBar(status) {
    this.statusBarItem.setText(`Flipmode: ${status}`);
  }
  // API Methods
  async apiRequest(endpoint, method = "GET", body) {
    const url = `${this.settings.serverUrl}/api/obsidian${endpoint}`;
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url,
        method,
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: body ? JSON.stringify(body) : void 0
      });
      return response.json;
    } catch (error) {
      console.error("Flipmode API error:", error);
      throw error;
    }
  }
  // Remote transcription for athletes (uses Heroku OpenAI Whisper)
  async remoteTranscribe(audioBlob) {
    var _a;
    if (!this.settings.queueServiceUrl || !this.settings.athleteToken) {
      throw new Error("Remote transcription requires queue service URL and athlete token");
    }
    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const dataUrl = reader.result;
        const base64Data = dataUrl.split(",")[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(audioBlob);
    });
    console.log("[Flipmode] Sending voice note to:", this.settings.queueServiceUrl);
    console.log("[Flipmode] Audio size:", audioBlob.size, "bytes, base64 length:", base64.length);
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.settings.queueServiceUrl}/api/voice/transcribe`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.athleteToken}`
      },
      body: JSON.stringify({ audio_base64: base64 })
    });
    if (response.status >= 400) {
      throw new Error(((_a = response.json) == null ? void 0 : _a.error) || "Transcription failed");
    }
    return response.json;
  }
  // Check voice note usage for today
  async getVoiceUsage() {
    if (!this.settings.queueServiceUrl || !this.settings.athleteToken) {
      throw new Error("Requires queue service URL and athlete token");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.settings.queueServiceUrl}/api/voice/usage`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.settings.athleteToken}`
      }
    });
    return response.json;
  }
  // Start remote therapy session (after transcription)
  async startRemoteTherapy(transcript) {
    var _a;
    if (!this.settings.queueServiceUrl || !this.settings.athleteToken) {
      throw new Error("Requires queue service URL and athlete token");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.settings.queueServiceUrl}/api/therapy/start`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.athleteToken}`
      },
      body: JSON.stringify({ transcript })
    });
    if (response.status >= 400) {
      throw new Error(((_a = response.json) == null ? void 0 : _a.error) || "Failed to start therapy session");
    }
    return response.json;
  }
  // Continue remote therapy session with answer
  async respondToRemoteTherapy(sessionId, answer) {
    var _a;
    if (!this.settings.queueServiceUrl || !this.settings.athleteToken) {
      throw new Error("Requires queue service URL and athlete token");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.settings.queueServiceUrl}/api/therapy/respond`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.athleteToken}`
      },
      body: JSON.stringify({ session_id: sessionId, answer })
    });
    if (response.status >= 400) {
      throw new Error(((_a = response.json) == null ? void 0 : _a.error) || "Failed to continue therapy session");
    }
    return response.json;
  }
  async checkConnection() {
    try {
      const response = await this.apiRequest("/health");
      if (response.status === "healthy") {
        this.updateStatusBar("Connected");
        return true;
      }
    } catch (error) {
      this.updateStatusBar("Disconnected");
    }
    return false;
  }
  // Save article to vault with frontmatter for graph view
  async saveArticleToVault(topic, articleContent) {
    const cleanTopic = topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
    const timestamp = new Date().toISOString().split("T")[0];
    const filename = `${this.settings.syncFolder}/${timestamp} - ${cleanTopic}.md`;
    const keywords = topic.toLowerCase().split(/\s+/).filter((w) => w.length > 3 && !["when", "from", "with", "that", "this", "what", "how"].includes(w)).slice(0, 5);
    const frontmatter = `---
type: research
topic: "[[${cleanTopic}]]"
date: ${timestamp}
tags: [bjj, flipmode${keywords.map((k) => `, ${k}`).join("")}]
---

`;
    const relatedLinks = `

---
## Related
- Topic: [[${cleanTopic}]]
- Training Plan: [[${timestamp} - ${cleanTopic} Plan]]

*Generated by Flipmode*
`;
    const fullContent = frontmatter + articleContent + relatedLinks;
    const folder = this.app.vault.getAbstractFileByPath(this.settings.syncFolder);
    if (!folder) {
      await this.app.vault.createFolder(this.settings.syncFolder);
    }
    const existingFile = this.app.vault.getAbstractFileByPath(filename);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, fullContent);
    } else {
      await this.app.vault.create(filename, fullContent);
    }
    return filename;
  }
  // Dive Deeper on a training session - uses notes as context
  async diveDeepOnSession(view) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    let topic = "";
    let fileType = "";
    let rlmSessionId = "";
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      const topicMatch = frontmatter.match(/topic:\s*"?\[\[([^\]]+)\]\]"?/) || frontmatter.match(/topic:\s*"([^"]+)"/);
      const typeMatch = frontmatter.match(/type:\s*(\S+)/);
      const rlmMatch = frontmatter.match(/rlm_session_id:\s*"([^"]+)"/);
      if (topicMatch)
        topic = topicMatch[1];
      if (typeMatch)
        fileType = typeMatch[1];
      if (rlmMatch)
        rlmSessionId = rlmMatch[1];
    }
    const reflectionSections = [];
    const whatWorkedMatch = content.match(/\*\*What worked:\*\*\s*\n([^\n*]+)/g);
    const whatToAdjustMatch = content.match(/\*\*What to adjust:\*\*\s*\n([^\n*]+)/g);
    const keyInsightMatch = content.match(/\*\*Key insight:\*\*\s*\n([^\n*]+)/g);
    if (whatWorkedMatch) {
      whatWorkedMatch.forEach((m) => {
        const text = m.replace("**What worked:**", "").trim();
        if (text && text.length > 2)
          reflectionSections.push(`What worked: ${text}`);
      });
    }
    if (whatToAdjustMatch) {
      whatToAdjustMatch.forEach((m) => {
        const text = m.replace("**What to adjust:**", "").trim();
        if (text && text.length > 2)
          reflectionSections.push(`Need to adjust: ${text}`);
      });
    }
    if (keyInsightMatch) {
      keyInsightMatch.forEach((m) => {
        const text = m.replace("**Key insight:**", "").trim();
        if (text && text.length > 2)
          reflectionSections.push(`Key insight: ${text}`);
      });
    }
    const notesMatch = content.match(/## Notes\n([\s\S]*?)(?=\n##|$)/);
    if (notesMatch && notesMatch[1].trim().length > 10) {
      reflectionSections.push(`Notes: ${notesMatch[1].trim().substring(0, 500)}`);
    }
    if (!topic) {
      const titleMatch = content.match(/# (?:Training Plan:|Research:)?\s*(.+)/);
      if (titleMatch)
        topic = titleMatch[1].trim();
    }
    if (!topic) {
      new import_obsidian.Notice("Could not find topic in this file");
      return;
    }
    const sessionContext = reflectionSections.length > 0 ? reflectionSections.join("\n") : "Training session completed";
    const modal = new DiveDeepModal(this.app, this, topic, sessionContext, rlmSessionId);
    modal.open();
    if (rlmSessionId) {
      new import_obsidian.Notice("Deep Dive session loaded!", 2e3);
    }
  }
  // Generate Training Review from Training Notes (coach side)
  async generateTrainingReview(view) {
    var _a;
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Is this a Training Notes file?");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const typeMatch = frontmatter.match(/type:\s*(\S+)/);
    if (!typeMatch || typeMatch[1] !== "training-notes") {
      new import_obsidian.Notice("This command only works on Training Notes files");
      return;
    }
    const sessionIdMatch = frontmatter.match(/session_id:\s*"([^"]+)"/);
    const sessionId = sessionIdMatch ? sessionIdMatch[1] : null;
    const focusMatch = frontmatter.match(/focus:\s*"([^"]+)"/);
    const focus = focusMatch ? focusMatch[1] : "general";
    const dateMatch = frontmatter.match(/date:\s*(\S+)/);
    const dateStr = dateMatch ? dateMatch[1] : new Date().toISOString().split("T")[0];
    const seasonMatch = frontmatter.match(/season:\s*(\d+)/);
    const episodeMatch = frontmatter.match(/episode:\s*(\d+)/);
    const season = seasonMatch ? parseInt(seasonMatch[1]) : this.settings.currentSeason;
    const episode = episodeMatch ? parseInt(episodeMatch[1]) : this.settings.currentEpisode;
    const folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || `${this.settings.syncFolder}/Athletes/Unknown/Season ${season}/Session ${episode}`;
    const notesFilename = file.basename;
    const reviewFilename = notesFilename.replace("TrainingNotes", "TrainingReview");
    const strugglesMatch = content.match(/## Struggles[\s\S]*?(?=##|$)/);
    const struggles = strugglesMatch ? strugglesMatch[0].replace("## Struggles", "").trim() : focus;
    new import_obsidian.Notice("Generating Training Review...", 3e3);
    try {
      const researchResponse = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/coach-review`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          query: struggles || focus,
          session_context: `Training session: ${focus}`
        })
      });
      const research = researchResponse.json;
      const articleContent = research.article || research.article_raw || "Research generation failed.";
      const topic = research.topic || focus;
      const rlmSessionId = research.rlm_session_id || "";
      const conversationUuid = research.conversation_uuid || "";
      const sourceCount = research.source_count || 0;
      const reviewContent = `---
type: training-review
season: ${season}
episode: ${episode}
date: ${dateStr}
focus: "${focus}"
topic: "${topic}"
training_notes: "[[${notesFilename}]]"
rlm_session_id: "${rlmSessionId}"
conversation_uuid: "${conversationUuid}"
source_count: ${sourceCount}
tags: [bjj, training-review, season-${season}, ${focus.replace(/_/g, "-")}]
---

# Training Review: ${topic}

${articleContent}

---
## Deep Dive
${rlmSessionId ? `> [!tip] Deep Dive Available
> Select text and right-click \u2192 "Dive Deeper" to explore specific topics.
> Or [View in Oracle](http://localhost:5002/c/${conversationUuid}) for the full interactive experience.` : "> No RLM session available for Deep Dive."}

## Links
- Training Notes: [[${notesFilename}]]
${conversationUuid ? `- [View in Oracle](http://localhost:5002/c/${conversationUuid})` : ""}
`;
      const reviewPath = `${folderPath}/${reviewFilename}.md`;
      const existingReview = this.app.vault.getAbstractFileByPath(reviewPath);
      if (existingReview instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingReview, reviewContent);
      } else {
        await this.app.vault.create(reviewPath, reviewContent);
      }
      await this.addTrainingReviewLink(file, reviewFilename);
      new import_obsidian.Notice(`Training Review saved: ${reviewFilename}`, 5e3);
      const reviewFile = this.app.vault.getAbstractFileByPath(reviewPath);
      if (reviewFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(reviewFile);
      }
    } catch (error) {
      console.error("Training review generation error:", error);
      new import_obsidian.Notice("Failed to generate Training Review. Check console for details.", 5e3);
    }
  }
  // Generate Training Review from selected text (right-click context menu)
  async generateTrainingReviewFromSelection(editor, view, selection) {
    var _a;
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const query = selection.trim();
    if (!query) {
      new import_obsidian.Notice("No text selected");
      return;
    }
    new import_obsidian.Notice(`Generating Training Review...`, 3e3);
    try {
      const content = await this.app.vault.read(file);
      const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      let sessionContext = "";
      let focus = "research";
      let dateStr = new Date().toISOString().split("T")[0];
      let season = this.settings.currentSeason;
      let episode = this.settings.currentEpisode;
      let athleteName = this.settings.athleteName || "Athlete";
      if (frontmatterMatch) {
        const frontmatter = frontmatterMatch[1];
        const focusMatch = frontmatter.match(/focus:\s*"([^"]+)"/);
        if (focusMatch)
          focus = focusMatch[1];
        const dateMatch = frontmatter.match(/date:\s*(\S+)/);
        if (dateMatch)
          dateStr = dateMatch[1];
        const seasonMatch = frontmatter.match(/season:\s*(\d+)/);
        if (seasonMatch)
          season = parseInt(seasonMatch[1]);
        const episodeMatch = frontmatter.match(/episode:\s*(\d+)/);
        if (episodeMatch)
          episode = parseInt(episodeMatch[1]);
        const strugglesMatch = content.match(/## Struggles[\s\S]*?(?=##|$)/);
        if (strugglesMatch) {
          sessionContext = strugglesMatch[0].replace("## Struggles", "").trim();
        }
      }
      const researchResponse = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/coach-review`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          query,
          athlete_name: athleteName,
          session_context: sessionContext
        })
      });
      const research = researchResponse.json;
      const articleContent = research.article_raw || research.article || "Research generation failed.";
      const topic = research.topic || query;
      const rlmSessionId = research.rlm_session_id || "";
      const sourceCount = research.source_count || 0;
      const articleSections = research.article_sections || [];
      const conversationUuid = research.conversation_uuid || "";
      const oracleUrl = conversationUuid ? `http://localhost:5002/c/${conversationUuid}` : `http://localhost:5002/?q=${encodeURIComponent(topic)}`;
      let audioSection = "";
      if (articleSections.length > 0) {
        audioSection = `## Listen to Review
`;
        audioSection += `> [!tip] Audio Player Available
`;
        audioSection += `> **${articleSections.length} audio sections** ready to play.
`;
        audioSection += `> Press \`Ctrl/Cmd + P\` and search "Open Audio Player" to listen.

`;
      }
      const safeQuery = query.substring(0, 40).replace(/[^a-zA-Z0-9]/g, "_").replace(/_+/g, "_");
      const reviewFilename = `TrainingReview-${dateStr}-${safeQuery}`;
      const folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || `${this.settings.syncFolder}/Athletes/${athleteName}/Season ${season}/Session ${episode}`;
      const audioSectionsYaml = articleSections.length > 0 ? `audio_sections_data:
${articleSections.map((s) => `  - title: "${s.title.replace(/"/g, "'")}"
    audio_url: "${s.audio_url}"`).join("\n")}` : "audio_sections_data: []";
      const reviewContent = `---
type: training-review
status: draft
season: ${season}
episode: ${episode}
date: ${dateStr}
query: "${query.replace(/"/g, "'")}"
topic: "${topic.replace(/"/g, "'")}"
source_file: "[[${file.basename}]]"
rlm_session_id: "${rlmSessionId}"
conversation_uuid: "${conversationUuid}"
source_count: ${sourceCount}
audio_sections: ${articleSections.length}
${audioSectionsYaml}
pipeline: "${research.pipeline || "multi_thinker"}"
thinkers_used: ${research.thinkers_used || 0}
tags: [bjj, training-review, season-${season}, research, draft]
---

# Training Review: ${topic}
> [!warning] DRAFT - Review and edit before publishing
> Use command "Flipmode: Publish Training Review" when ready to send to athlete.
> [View with Videos](${oracleUrl}) - Open in Oracle to verify sources

${audioSection}> **Query:** ${query}

${articleContent}

---
## Deep Dive
${rlmSessionId ? `> [!tip] Deep Dive Available
> Select text and right-click \u2192 "Dive Deeper" to explore specific topics.
> Or [View in Oracle](http://localhost:5002/c/${conversationUuid}) for the full interactive experience.` : "> No RLM session available for Deep Dive."}

## Links
- Source: [[${file.basename}]]
${conversationUuid ? `- [View in Oracle](http://localhost:5002/c/${conversationUuid})` : ""}
`;
      const reviewPath = `${folderPath}/${reviewFilename}.md`;
      const existingReview = this.app.vault.getAbstractFileByPath(reviewPath);
      if (existingReview instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingReview, reviewContent);
      } else {
        await this.app.vault.create(reviewPath, reviewContent);
      }
      await this.addTrainingReviewLink(file, reviewFilename);
      new import_obsidian.Notice(`Training Review saved: ${reviewFilename}`, 5e3);
      const reviewFile = this.app.vault.getAbstractFileByPath(reviewPath);
      if (reviewFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf("split").openFile(reviewFile);
      }
    } catch (error) {
      console.error("Training review from selection error:", error);
      new import_obsidian.Notice("Failed to generate Training Review. Check console for details.", 5e3);
    }
  }
  // Add backlink to source file for two-way graph connection
  async addTrainingReviewLink(sourceFile, reviewFilename) {
    try {
      const content = await this.app.vault.read(sourceFile);
      const reviewLink = `[[${reviewFilename}]]`;
      if (content.includes("## Training Reviews")) {
        if (!content.includes(reviewLink)) {
          const updatedContent = content.replace(
            /## Training Reviews\n/,
            `## Training Reviews
- ${reviewLink}
`
          );
          await this.app.vault.modify(sourceFile, updatedContent);
        }
      } else {
        const updatedContent = content + `
## Training Reviews
- ${reviewLink}
`;
        await this.app.vault.modify(sourceFile, updatedContent);
      }
    } catch (error) {
      console.error("Failed to add backlink:", error);
    }
  }
  // Dive Deeper - explore selected text using Oracle's RLM context
  async diveDeeper(editor, view, selection) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const focusText = selection.trim();
    if (!focusText) {
      new import_obsidian.Notice("No text selected");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Dive Deeper requires a Training Review file.");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const sessionIdMatch = frontmatter.match(/rlm_session_id:\s*"([^"]+)"/);
    if (!sessionIdMatch || !sessionIdMatch[1]) {
      new import_obsidian.Notice("No RLM session found. Generate a Training Review first.");
      return;
    }
    const sessionId = sessionIdMatch[1];
    const convUuidMatch = frontmatter.match(/conversation_uuid:\s*"([^"]+)"/);
    const conversationUuid = convUuidMatch ? convUuidMatch[1] : null;
    new import_obsidian.Notice(`Diving deeper on: ${focusText.substring(0, 40)}...`, 3e3);
    try {
      const oracleUrl = "http://localhost:5002";
      const response = await (0, import_obsidian.requestUrl)({
        url: `${oracleUrl}/api/internal/deep-dive`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session_id: sessionId,
          focus_text: focusText,
          conversation_uuid: conversationUuid
        })
      });
      const result = response.json;
      if (result.error) {
        new import_obsidian.Notice(`Deep Dive failed: ${result.error}`, 5e3);
        return;
      }
      const deepDiveContent = result.deep_dive_raw || result.deep_dive_html || "Deep Dive generation failed.";
      const focusArea = result.focus_area || focusText.substring(0, 50);
      const newSourcesCount = result.new_sources_count || 0;
      const timestamp = new Date().toLocaleTimeString();
      const deepDiveSection = `

---
## Deep Dive: ${focusArea}
*Generated at ${timestamp} | ${newSourcesCount} new sources*

${deepDiveContent}
`;
      const updatedContent = content + deepDiveSection;
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian.Notice(`Deep Dive complete: ${focusArea} (${newSourcesCount} new sources)`, 5e3);
      const newCursor = { line: editor.lineCount() - 1, ch: 0 };
      editor.setCursor(newCursor);
      editor.scrollIntoView({ from: newCursor, to: newCursor }, true);
    } catch (error) {
      console.error("Deep Dive error:", error);
      new import_obsidian.Notice("Deep Dive failed. Check console for details.", 5e3);
    }
  }
  // Explode article content into linked concept graph nodes
  async explodeToConceptGraph(editor, view, selection) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const contentToExplode = selection.trim();
    if (!contentToExplode || contentToExplode.length < 100) {
      new import_obsidian.Notice("Select more text to explode (at least a paragraph)");
      return;
    }
    const sourceContent = await this.app.vault.read(file);
    const frontmatterMatch = sourceContent.match(/^---\n([\s\S]*?)\n---/);
    let sourceRlmSessionId = "";
    if (frontmatterMatch) {
      const sessionMatch = frontmatterMatch[1].match(/rlm_session_id:\s*"([^"]+)"/);
      if (sessionMatch)
        sourceRlmSessionId = sessionMatch[1];
    }
    new import_obsidian.Notice("Exploding to concept graph...", 3e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/explode-concepts`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          content: contentToExplode,
          source_file: file.basename
        })
      });
      const result = response.json;
      if (result.error) {
        new import_obsidian.Notice(`Explode failed: ${result.error}`, 5e3);
        return;
      }
      const checkpoints = result.checkpoints || [];
      if (checkpoints.length === 0) {
        new import_obsidian.Notice("No checkpoints extracted");
        return;
      }
      const topicName = result.topic_name || file.basename;
      const topicTags = result.topic_tags || [];
      const clusterName = topicName.replace(/[^\w\s-]/g, "").trim();
      const conceptsBase = `${this.settings.syncFolder}/${this.settings.conceptsSubfolder}`;
      const conceptsFolder = `${conceptsBase}/${clusterName}`;
      await this.ensureFolder(conceptsFolder);
      const normalizeName = (name) => {
        if (!name)
          return "";
        let clean = name.replace(/[^\w\s-]/g, "").trim();
        clean = clean.replace(/^(The|A|An)\s+/i, "");
        return clean;
      };
      const topicTagsStr = topicTags.length > 0 ? topicTags.map((t) => t.toLowerCase().replace(/\s+/g, "-")).join(", ") : "";
      let createdCount = 0;
      const createdNames = /* @__PURE__ */ new Set();
      checkpoints.sort((a, b) => (a.order || 1) - (b.order || 1));
      for (let i = 0; i < checkpoints.length; i++) {
        const cp = checkpoints[i];
        const cpName = normalizeName(cp.name);
        if (!cpName || createdNames.has(cpName.toLowerCase()))
          continue;
        const cpPath = `${conceptsFolder}/${cpName}.md`;
        if (this.app.vault.getAbstractFileByPath(cpPath)) {
          createdNames.add(cpName.toLowerCase());
          continue;
        }
        const order = cp.order || i + 1;
        const prevCp = i > 0 ? normalizeName(checkpoints[i - 1].name) : null;
        const nextCp = i < checkpoints.length - 1 ? normalizeName(checkpoints[i + 1].name) : null;
        const invariables = cp.invariables || [];
        const tier1 = invariables.filter((inv) => inv.tier === "tier1");
        const tier2 = invariables.filter((inv) => inv.tier === "tier2");
        const tier3 = invariables.filter((inv) => inv.tier === "tier3" || !inv.tier);
        const formatTierLinks = (items) => items.length > 0 ? items.map((inv) => `[[${clusterName}/${normalizeName(inv.name)}|${normalizeName(inv.name)}]]`).join(" \xB7 ") : "*none*";
        const variables = cp.variables || [];
        const varLinks = variables.length > 0 ? variables.map((v) => `- **${v.trigger}** \u2192 [[${clusterName}/${normalizeName(v.name)}|${normalizeName(v.name)}]]`).join("\n") : "*No situational responses*";
        const content = `---
type: checkpoint
order: ${order}
cluster: "${clusterName}"
tags: [grappling, checkpoint${topicTagsStr ? ", " + topicTagsStr : ""}]
source_file: "${file.basename}"
source_rlm_session: "${sourceRlmSessionId}"
---

# [${order}] ${cpName}

> [!success] CHECKPOINT ${order} of ${checkpoints.length}

## Goal

${cp.goal || "No goal defined."}

## Success Test

> ${cp.success_test || "No test defined."}

---

## INVARIABLES (Always Do Together)

| Tier | Concepts |
|------|----------|
| CRITICAL | ${formatTierLinks(tier1)} |
| IMPORTANT | ${formatTierLinks(tier2)} |
| REFINEMENT | ${formatTierLinks(tier3)} |

---

## VARIABLES (IF/THEN)

${varLinks}

---

## Navigation

| Previous | Next |
|----------|------|
| ${prevCp ? `[[${clusterName}/${prevCp}|< ${prevCp}]]` : "*Start*"} | ${nextCp ? `[[${clusterName}/${nextCp}|${nextCp} >]]` : "*End*"} |
`;
        await this.app.vault.create(cpPath, content);
        createdNames.add(cpName.toLowerCase());
        createdCount++;
      }
      for (const cp of checkpoints) {
        const cpName = normalizeName(cp.name);
        const order = cp.order || 1;
        for (const inv of cp.invariables || []) {
          const invName = normalizeName(inv.name);
          if (!invName || createdNames.has(invName.toLowerCase()))
            continue;
          const invPath = `${conceptsFolder}/${invName}.md`;
          if (this.app.vault.getAbstractFileByPath(invPath)) {
            createdNames.add(invName.toLowerCase());
            continue;
          }
          const tier = inv.tier || "tier3";
          const tierLabel = tier === "tier1" ? "CRITICAL" : tier === "tier2" ? "IMPORTANT" : "REFINEMENT";
          const siblings = (cp.invariables || []).filter((i) => normalizeName(i.name).toLowerCase() !== invName.toLowerCase()).map((i) => `[[${clusterName}/${normalizeName(i.name)}|${normalizeName(i.name)}]]`).join(" \xB7 ");
          const content = `---
type: invariable
tier: "${tier}"
checkpoint: "${cpName}"
checkpoint_order: ${order}
cluster: "${clusterName}"
tags: [grappling, invariable, ${tier}${topicTagsStr ? ", " + topicTagsStr : ""}]
source_file: "${file.basename}"
source_rlm_session: "${sourceRlmSessionId}"
---

# ${invName}

> [!${tier === "tier1" ? "danger" : tier === "tier2" ? "warning" : "info"}] ${tierLabel} INVARIABLE
> Part of [[${clusterName}/${cpName}|Checkpoint ${order}: ${cpName}]]

## WHY

> ${inv.why || "See parent article."}

## HOW

${inv.how || "No explanation."}

## FEEL

> ${inv.feel || "No feel description."}

---

## Do Together With

${siblings || "*Only invariable at this checkpoint*"}

## Parent

[[${clusterName}/${cpName}|< ${cpName}]]
`;
          await this.app.vault.create(invPath, content);
          createdNames.add(invName.toLowerCase());
          createdCount++;
        }
      }
      for (const cp of checkpoints) {
        const cpName = normalizeName(cp.name);
        const order = cp.order || 1;
        for (const v of cp.variables || []) {
          const vName = normalizeName(v.name);
          if (!vName || createdNames.has(vName.toLowerCase()))
            continue;
          const vPath = `${conceptsFolder}/${vName}.md`;
          if (this.app.vault.getAbstractFileByPath(vPath)) {
            createdNames.add(vName.toLowerCase());
            continue;
          }
          const content = `---
type: variable
trigger: "${v.trigger || ""}"
checkpoint: "${cpName}"
checkpoint_order: ${order}
cluster: "${clusterName}"
tags: [grappling, variable${topicTagsStr ? ", " + topicTagsStr : ""}]
source_file: "${file.basename}"
source_rlm_session: "${sourceRlmSessionId}"
---

# ${vName}

> [!warning] VARIABLE - Situational Response
> Part of [[${clusterName}/${cpName}|Checkpoint ${order}: ${cpName}]]

## TRIGGER

> **${v.trigger || "When opponent reacts"}**

## ACTION

${v.action || "No action described."}

## WHY This Works

> ${v.why || "See parent article."}

---

## Parent

[[${clusterName}/${cpName}|< ${cpName}]]
`;
          await this.app.vault.create(vPath, content);
          createdNames.add(vName.toLowerCase());
          createdCount++;
        }
      }
      const clusterTag = `cluster/${clusterName.toLowerCase().replace(/\s+/g, "-")}`;
      const indexPath = `${conceptsBase}/${clusterName}.md`;
      const cpList = checkpoints.map((cp) => {
        const cpName = normalizeName(cp.name);
        const invCount = (cp.invariables || []).length;
        const varCount = (cp.variables || []).length;
        return `${cp.order || 1}. [[${clusterName}/${cpName}|${cpName}]] (${invCount} inv, ${varCount} var)`;
      }).join("\n");
      const totalInv = checkpoints.reduce((sum, cp) => sum + (cp.invariables || []).length, 0);
      const totalVar = checkpoints.reduce((sum, cp) => sum + (cp.variables || []).length, 0);
      let mermaidFlow = "flowchart LR\n";
      for (let i = 0; i < checkpoints.length; i++) {
        const cp = checkpoints[i];
        const cpId = `CP${i + 1}`;
        const cpName = normalizeName(cp.name).replace(/"/g, "");
        mermaidFlow += `    ${cpId}["[${i + 1}] ${cpName}"]
`;
      }
      for (let i = 0; i < checkpoints.length - 1; i++) {
        mermaidFlow += `    CP${i + 1} --> CP${i + 2}
`;
      }
      const indexContent = `---
type: sequence
cluster: "${clusterName}"
tags: [cluster, grappling, sequence, ${clusterTag}]
source_file: "${file.basename}"
checkpoints_count: ${checkpoints.length}
invariables_count: ${totalInv}
variables_count: ${totalVar}
---

# ${clusterName}

> [!tip] Sequential Checkpoints with Invariables and Variables

**Source:** [[${file.basename}]]
**Checkpoints:** ${checkpoints.length} | **Invariables:** ${totalInv} | **Variables:** ${totalVar}

---

## Flow Diagram

\`\`\`mermaid
${mermaidFlow}\`\`\`

---

## The Sequence

${cpList}

---

## How It Works

1. **Checkpoints** = Sequential milestones (complete 1 before 2)
2. **Invariables** = Always do (tiered by priority, do together)
3. **Variables** = IF/THEN responses at each checkpoint
`;
      if (!this.app.vault.getAbstractFileByPath(indexPath)) {
        await this.app.vault.create(indexPath, indexContent);
      }
      const canvasPath = `${conceptsBase}/${clusterName}.canvas`;
      if (!this.app.vault.getAbstractFileByPath(canvasPath)) {
        const nodes = [];
        const edges = [];
        let nodeId = 1;
        const cpWidth = 280;
        const cpHeight = 80;
        const conceptWidth = 220;
        const conceptHeight = 60;
        const cpSpacing = 350;
        const verticalGap = 100;
        const cpNodeIds = [];
        for (let i = 0; i < checkpoints.length; i++) {
          const cp = checkpoints[i];
          const cpName = normalizeName(cp.name);
          const cpId = `cp-${nodeId++}`;
          cpNodeIds.push(cpId);
          nodes.push({
            id: cpId,
            type: "file",
            file: `${conceptsFolder}/${cpName}.md`,
            x: i * cpSpacing,
            y: 0,
            width: cpWidth,
            height: cpHeight,
            color: "6"
          });
          const invariables = cp.invariables || [];
          for (let j = 0; j < invariables.length; j++) {
            const inv = invariables[j];
            const invName = normalizeName(inv.name);
            const invId = `inv-${nodeId++}`;
            const tier = inv.tier || "tier3";
            const color = tier === "tier1" ? "1" : tier === "tier2" ? "3" : "4";
            nodes.push({
              id: invId,
              type: "file",
              file: `${conceptsFolder}/${invName}.md`,
              x: i * cpSpacing + j * 120 - (invariables.length - 1) * 60,
              y: cpHeight + verticalGap,
              width: conceptWidth,
              height: conceptHeight,
              color
            });
            edges.push({
              id: `edge-${nodeId++}`,
              fromNode: cpId,
              toNode: invId,
              fromSide: "bottom",
              toSide: "top"
            });
          }
          const variables = cp.variables || [];
          for (let k = 0; k < variables.length; k++) {
            const v = variables[k];
            const vName = normalizeName(v.name);
            const vId = `var-${nodeId++}`;
            nodes.push({
              id: vId,
              type: "file",
              file: `${conceptsFolder}/${vName}.md`,
              x: i * cpSpacing + k * 120 - (variables.length - 1) * 60,
              y: cpHeight + verticalGap * 2 + conceptHeight,
              width: conceptWidth,
              height: conceptHeight,
              color: "2"
            });
            edges.push({
              id: `edge-${nodeId++}`,
              fromNode: cpId,
              toNode: vId,
              fromSide: "bottom",
              toSide: "top"
            });
          }
        }
        for (let i = 0; i < cpNodeIds.length - 1; i++) {
          edges.push({
            id: `edge-${nodeId++}`,
            fromNode: cpNodeIds[i],
            toNode: cpNodeIds[i + 1],
            fromSide: "right",
            toSide: "left"
          });
        }
        const canvasContent = JSON.stringify({ nodes, edges }, null, 2);
        await this.app.vault.create(canvasPath, canvasContent);
      }
      new import_obsidian.Notice(`Created "${clusterName}": ${checkpoints.length} checkpoints + Canvas timeline!`, 5e3);
    } catch (error) {
      console.error("Explode to Concept Graph error:", error);
      new import_obsidian.Notice("Failed to explode concepts. Check console.", 5e3);
    }
  }
  // Get training drills and games for a concept node
  // Uses RLM deep dive to search video library, falls back to AI-generated suggestions
  async getTrainingDrillsForConcept(file) {
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Is this a concept file?");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    if (!frontmatter.includes("type: concept")) {
      new import_obsidian.Notice("This command only works on concept files");
      return;
    }
    if (frontmatter.includes("has-drills")) {
      new import_obsidian.Notice("This concept already has training drills");
      return;
    }
    const conceptName = file.basename;
    const summaryMatch = content.match(/## Summary\n\n([^\n#]+)/);
    const conceptSummary = summaryMatch ? summaryMatch[1].trim() : conceptName;
    const sessionMatch = frontmatter.match(/source_rlm_session:\s*"([^"]+)"/);
    const rlmSessionId = sessionMatch ? sessionMatch[1] : "";
    new import_obsidian.Notice(`Finding training drills for: ${conceptName}...`, 3e3);
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/concept-drills`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          concept_name: conceptName,
          concept_summary: conceptSummary,
          rlm_session_id: rlmSessionId
        })
      });
      const result = response.json;
      if (result.error) {
        new import_obsidian.Notice(`Failed to get drills: ${result.error}`, 5e3);
        return;
      }
      const drills = result.drills || result.content || "No drills found.";
      const sourcesCount = result.sources_count || 0;
      const isGenerated = result.ai_generated || false;
      const updatedFrontmatter = frontmatter.replace(
        /tags: \[([^\]]+)\]/,
        "tags: [$1, has-drills]"
      );
      const timestamp = new Date().toLocaleTimeString();
      const sourceNote = isGenerated ? "*(AI-generated suggestions)*" : `*(${sourcesCount} sources from video library)*`;
      const drillsSection = `

---
## Training Drills & Games
*Generated at ${timestamp}* ${sourceNote}

${drills}
`;
      const updatedContent = content.replace(frontmatterMatch[0], `---
${updatedFrontmatter}
---`) + drillsSection;
      await this.app.vault.modify(file, updatedContent);
      const noticeText = isGenerated ? `Generated training suggestions for: ${conceptName}` : `Found ${sourcesCount} training drills for: ${conceptName}`;
      new import_obsidian.Notice(noticeText, 5e3);
    } catch (error) {
      console.error("Get Training Drills error:", error);
      new import_obsidian.Notice("Failed to get training drills. Check console.", 5e3);
    }
  }
  // Research a concept - dive deeper via Oracle RLM
  async researchConcept(file) {
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const conceptName = file.basename;
    const sessionMatch = frontmatter.match(/source_rlm_session:\s*"([^"]+)"/);
    const rlmSessionId = sessionMatch ? sessionMatch[1] : "";
    new import_obsidian.Notice(`Researching: ${conceptName}...`, 3e3);
    try {
      const oracleUrl = "http://localhost:5002";
      const response = await (0, import_obsidian.requestUrl)({
        url: `${oracleUrl}/api/internal/deep-dive`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          session_id: rlmSessionId || `concept_${conceptName}`,
          focus_text: `${conceptName}: key details, variations, common mistakes, and important nuances`
        })
      });
      const result = response.json;
      if (result.error) {
        new import_obsidian.Notice(`Research failed: ${result.error}`, 5e3);
        return;
      }
      const research = result.deep_dive_raw || result.deep_dive_html;
      const sourcesCount = result.new_sources_count || 0;
      if (!research || sourcesCount === 0) {
        new import_obsidian.Notice(`No content found for "${conceptName}" in your library`, 5e3);
        return;
      }
      const timestamp = new Date().toLocaleTimeString();
      const researchSection = `

---
## Research Findings
*Found ${sourcesCount} sources at ${timestamp}*

${research}
`;
      const updatedContent = content + researchSection;
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian.Notice(`Added research for: ${conceptName} (${sourcesCount} sources)`, 5e3);
    } catch (error) {
      console.error("Research concept error:", error);
      new import_obsidian.Notice("Research failed. Is Oracle running?", 5e3);
    }
  }
  // Generate Skill Development sessions from selected text (right-click context menu)
  // Creates 3 separate nodes: SkillDev1, SkillDev2, SkillDev3
  // Uses CLA (Constraints-Led Approach) science via Oracle's skill-dev endpoint
  async generateTrainingPlanFromSelection(editor, view, selection) {
    var _a;
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const fullSelection = selection.trim();
    if (!fullSelection) {
      new import_obsidian.Notice("No text selected");
      return;
    }
    const firstLine = fullSelection.split("\n")[0].replace(/^#+\s*/, "").trim();
    const shortTopic = firstLine.substring(0, 60);
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Skill Development requires a Training Review file.");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const sessionIdMatch = frontmatter.match(/rlm_session_id:\s*"([^"]+)"/);
    if (!sessionIdMatch || !sessionIdMatch[1]) {
      new import_obsidian.Notice("No RLM session found. Generate a Training Review first.");
      return;
    }
    const sessionId = sessionIdMatch[1];
    new import_obsidian.Notice(`Generating CLA Skill Development for: ${shortTopic}...`, 5e3);
    try {
      const oracleUrl = "http://localhost:5002";
      const response = await (0, import_obsidian.requestUrl)({
        url: `${oracleUrl}/api/internal/skill-dev`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session_id: sessionId,
          topic: fullSelection
          // Send full selection for Oracle context
        })
      });
      const plan = response.json;
      if (plan.error) {
        new import_obsidian.Notice(`Skill Development failed: ${plan.error}`, 5e3);
        return;
      }
      if (!plan.sessions || plan.sessions.length === 0) {
        new import_obsidian.Notice("Failed to generate skill development sessions");
        return;
      }
      const dateStr = new Date().toISOString().split("T")[0];
      const safeTopic = shortTopic.substring(0, 25).replace(/[^a-zA-Z0-9]/g, "_").replace(/_+/g, "_");
      const folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || this.settings.syncFolder;
      const folderExists = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folderExists) {
        await this.app.vault.createFolder(folderPath);
      }
      const createdFiles = [];
      for (let i = 0; i < plan.sessions.length; i++) {
        const session = plan.sessions[i];
        const sessionNum = session.session_number || i + 1;
        const filename = `SkillDev${sessionNum}-${dateStr}-${safeTopic}`;
        const sessionMarkdown = this.buildCLASkillDevMarkdown(
          shortTopic,
          session,
          file.basename,
          createdFiles
        );
        const filePath = `${folderPath}/${filename}.md`;
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile instanceof import_obsidian.TFile) {
          await this.app.vault.modify(existingFile, sessionMarkdown);
        } else {
          await this.app.vault.create(filePath, sessionMarkdown);
        }
        createdFiles.push(filename);
      }
      await this.addSkillDevLinks(file, createdFiles);
      new import_obsidian.Notice(`Created ${plan.sessions.length} CLA Skill Dev sessions for ${shortTopic}`, 5e3);
      const firstFile = this.app.vault.getAbstractFileByPath(`${folderPath}/${createdFiles[0]}.md`);
      if (firstFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf("split").openFile(firstFile);
      }
    } catch (error) {
      console.error("Skill development generation error:", error);
      new import_obsidian.Notice("Failed to generate Skill Development. Check console for details.", 5e3);
    }
  }
  // Build CLA-based skill development markdown from Oracle response
  buildCLASkillDevMarkdown(topic, session, sourceFile, siblingFiles) {
    const dateStr = new Date().toISOString().split("T")[0];
    const cleanTopic = topic.replace(/"/g, "'");
    const sessionNum = session.session_number || 1;
    const prevFile = sessionNum > 1 ? siblingFiles[sessionNum - 2] : null;
    const nextFile = sessionNum < 3 ? siblingFiles[sessionNum] : null;
    const sourceLink = sessionNum === 1 ? `
source: "[[${sourceFile}]]"` : "";
    const sourceLinkBody = sessionNum === 1 ? `- Source: [[${sourceFile}]]
` : "";
    let roundsList = "";
    if (session.rounds_text) {
      roundsList = session.rounds_text;
    } else if (session.rounds && session.rounds.length > 0) {
      for (const round of session.rounds) {
        const desc = round.description || round.start || "Positional sparring";
        const reason = round.reasoning || round.because || "";
        roundsList += `- **Round ${round.round}:** ${desc}`;
        if (reason)
          roundsList += ` \u2014 ${reason}`;
        roundsList += "\n";
      }
    } else {
      roundsList = "See source research for round details.\n";
    }
    const goals = session.goals && session.goals.length > 0 ? session.goals.map((g) => `- [ ] ${g}`).join("\n") : "- [ ] Complete all 5 rounds\n- [ ] Note what worked";
    return `---
type: skill-development
methodology: CLA
session: ${sessionNum}
topic: "${cleanTopic}"
date: ${dateStr}
resistance: "${session.resistance_level || "50%"}"
status: pending${sourceLink}
tags: [bjj, skill-dev, cla, session-${sessionNum}]
---

# SkillDev ${sessionNum}: ${session.title || "Session " + sessionNum}

**Resistance:** ${session.resistance_level || "50%"}
**Focus:** ${session.focus || "Skill development"}

${prevFile ? `Previous: [[${prevFile}]]` : ""}${prevFile && nextFile ? " | " : ""}${nextFile ? `Next: [[${nextFile}]]` : ""}

## Positional Sparring Rounds

${roundsList}

## Goals

${goals}

## Post-Session Notes

**What worked:**


**What to adjust:**


**Key insight:**

---

${sourceLinkBody}
`;
  }
  // Add backlink to source file - ONLY links to SkillDev1 for linear chain
  // Graph structure: TrainingReview  SkillDev1  SkillDev2  SkillDev3
  async addSkillDevLinks(sourceFile, filenames) {
    try {
      const content = await this.app.vault.read(sourceFile);
      const firstLink = `[[${filenames[0]}]]`;
      if (content.includes("## Skill Development")) {
        if (!content.includes(filenames[0])) {
          const updatedContent = content.replace(
            /## Skill Development\n/,
            `## Skill Development
- ${firstLink}
`
          );
          await this.app.vault.modify(sourceFile, updatedContent);
        }
      } else {
        const updatedContent = content + `
## Skill Development
- ${firstLink}
`;
        await this.app.vault.modify(sourceFile, updatedContent);
      }
    } catch (error) {
      console.error("Failed to add skill dev backlinks:", error);
    }
  }
  // Publish Training Review to athlete
  async publishTrainingReview(view) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const typeMatch = frontmatter.match(/type:\s*(\S+)/);
    if (!typeMatch || typeMatch[1] !== "training-review") {
      new import_obsidian.Notice("This command only works on Training Review files");
      return;
    }
    const statusMatch = frontmatter.match(/status:\s*(\S+)/);
    if (statusMatch && statusMatch[1] === "published") {
      new import_obsidian.Notice("This review is already published");
      return;
    }
    let updatedContent = content.replace(/status:\s*draft/, "status: published");
    updatedContent = updatedContent.replace(/tags:\s*\[(.*?)\]/, (match, tags) => {
      const tagList = tags.split(",").map((t) => t.trim()).filter((t) => t !== "draft");
      tagList.push("published");
      return `tags: [${tagList.join(", ")}]`;
    });
    updatedContent = updatedContent.replace(/> \[!warning\] DRAFT.*\n> Use command.*\n\n?/g, "");
    updatedContent = updatedContent.replace(/\[([^\]]+)\]\(http[^)]+\)/g, "$1");
    const publishDate = new Date().toISOString().split("T")[0];
    updatedContent = updatedContent.replace(
      /# Training Review:/,
      `> [!success] Published ${publishDate}

# Training Review:`
    );
    await this.app.vault.modify(file, updatedContent);
    new import_obsidian.Notice("Training Review published to athlete!", 5e3);
  }
  // Open Audio Player for Training Review files
  async openAudioPlayer(view) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const audioSectionsData = frontmatter.audio_sections_data;
    if (!audioSectionsData || audioSectionsData.length === 0) {
      new import_obsidian.Notice("No audio sections found in this file");
      return;
    }
    const topic = frontmatter.topic || frontmatter.query || file.basename;
    const rlmSessionId = frontmatter.rlm_session_id || null;
    const audioModal = new AudioPlayerModal(
      this.app,
      this,
      topic,
      audioSectionsData,
      rlmSessionId,
      "",
      // No article content needed - just playing audio
      []
      // No sources needed
    );
    audioModal.open();
  }
  // Sync Methods
  async syncWithFlipmode() {
    const connected = await this.checkConnection();
    if (!connected) {
      new import_obsidian.Notice("Cannot connect to Flipmode server");
      return;
    }
    new import_obsidian.Notice("Syncing with Flipmode...");
    try {
      const userId = this.settings.apiToken.substring(0, 8) || "default";
      const manifest = await this.apiRequest(`/sync/manifest/${userId}`);
      await this.ensureFoldersExist(manifest.directories);
      let syncedCount = 0;
      for (const file of manifest.files) {
        const synced = await this.syncFile(file);
        if (synced)
          syncedCount++;
      }
      new import_obsidian.Notice(`Synced ${syncedCount} files from Flipmode`);
    } catch (error) {
      console.error("Sync error:", error);
      new import_obsidian.Notice("Sync failed - check console for details");
    }
  }
  // Sync shared concept from coach and open it (called from Discord link)
  async syncAndOpenConcept(conceptName) {
    new import_obsidian.Notice(`Syncing "${conceptName}" from coach...`);
    try {
      if (this.settings.mode === "remote" && this.settings.athleteToken) {
        const response = await (0, import_obsidian.requestUrl)({
          url: `${this.settings.queueServiceUrl}/api/queue/shared-concepts`,
          method: "GET",
          headers: { "Authorization": `Bearer ${this.settings.athleteToken}` }
        });
        const sharedConcepts = response.json.shared_concepts || [];
        const concept = sharedConcepts.find(
          (c) => c.name === conceptName || c.name.includes(conceptName)
        );
        if (concept) {
          const conceptsBase = `${this.settings.syncFolder}/${this.settings.conceptsSubfolder}`;
          await this.ensureFolder(conceptsBase);
          const data = concept.data || {};
          if (data.type === "cluster" && data.clusterName) {
            const clusterFolder = `${conceptsBase}/${data.clusterName}`;
            await this.ensureFolder(clusterFolder);
            const indexPath = `${conceptsBase}/${data.clusterName}.md`;
            if (data.indexContent) {
              await this.saveNote(indexPath, data.indexContent);
            }
            for (const c of data.concepts || []) {
              const filePath2 = `${clusterFolder}/${c.name}.md`;
              await this.saveNote(filePath2, c.content);
            }
            new import_obsidian.Notice(`Synced "${conceptName}" - opening...`);
            await this.app.workspace.openLinkText(indexPath, "", true);
          } else if (data.type === "concept" && data.content) {
            const filePath2 = `${conceptsBase}/${conceptName}.md`;
            await this.saveNote(filePath2, data.content);
            new import_obsidian.Notice(`Synced "${conceptName}" - opening...`);
            await this.app.workspace.openLinkText(filePath2, "", true);
          } else {
            const filePath2 = `${conceptsBase}/${conceptName}.md`;
            const stubContent = `---
type: shared-concept
from_oracle: true
shared_at: "${concept.shared_at || new Date().toISOString()}"
---

# ${conceptName}

${concept.summary || "Concept shared from Oracle."}

---
*Full content pending - sync with Oracle for details.*
`;
            await this.saveNote(filePath2, stubContent);
            new import_obsidian.Notice(`Synced "${conceptName}" - opening...`);
            await this.app.workspace.openLinkText(filePath2, "", true);
          }
          return;
        }
      }
      const filePath = `${this.settings.syncFolder}/${this.settings.conceptsSubfolder}/${conceptName}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        await this.app.workspace.openLinkText(filePath, "", true);
        new import_obsidian.Notice(`Opened "${conceptName}"`);
      } else {
        new import_obsidian.Notice(`Concept "${conceptName}" not found. Sync with Oracle first.`);
      }
    } catch (error) {
      console.error("Sync and open error:", error);
      new import_obsidian.Notice(`Failed to sync: ${error.message}`);
    }
  }
  async ensureFoldersExist(paths) {
    for (const path of paths) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (!folder) {
        await this.app.vault.createFolder(path);
      }
    }
  }
  async syncFile(file) {
    try {
      const existingFile = this.app.vault.getAbstractFileByPath(file.path);
      if (existingFile instanceof import_obsidian.TFile) {
        const currentContent = await this.app.vault.read(existingFile);
        if (this.computeChecksum(currentContent) !== file.checksum) {
          await this.app.vault.modify(existingFile, file.content);
          return true;
        }
        return false;
      } else {
        await this.app.vault.create(file.path, file.content);
        return true;
      }
    } catch (error) {
      console.error(`Error syncing file ${file.path}:`, error);
      return false;
    }
  }
  computeChecksum(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(16).substring(0, 16);
  }
  startAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    this.syncIntervalId = window.setInterval(
      () => this.syncWithFlipmode(),
      this.settings.syncInterval * 60 * 1e3
    );
  }
  // UI Methods
  async showFlipmodeMenu() {
    new FlipmodeMenuModal(this.app, this).open();
  }
  async showResearchModal() {
    new ResearchModal(this.app, this).open();
  }
  async showVoiceNoteModal() {
    new VoiceNoteModal(this.app, this).open();
  }
  // Voice session method - Step 1: transcribe audio
  async startVoiceSession(audioBase64) {
    try {
      const response = await this.apiRequest("/session", "POST", {
        user_id: this.settings.userId,
        audio_base64: audioBase64,
        audio_format: "webm"
      });
      return response;
    } catch (error) {
      console.error("Voice session error:", error);
      throw error;
    }
  }
  // Voice session method - Step 2: confirm/edit transcript and process
  async confirmVoiceSession(confirmedText) {
    try {
      const response = await this.apiRequest("/session", "POST", {
        user_id: this.settings.userId,
        confirmed_text: confirmedText
      });
      return response;
    } catch (error) {
      console.error("Confirm voice session error:", error);
      throw error;
    }
  }
  // Continue conversation - Step 1: send audio for transcription
  async respondToSession(sessionId, text, audioBase64, selectedOption) {
    try {
      const body = {
        session_id: sessionId,
        user_id: this.settings.userId
      };
      if (audioBase64) {
        body.audio_base64 = audioBase64;
        body.audio_format = "webm";
      } else if (text) {
        body.text = text;
      } else if (selectedOption) {
        body.selected_option = selectedOption;
      }
      const response = await this.apiRequest("/respond", "POST", body);
      return response;
    } catch (error) {
      console.error("Respond error:", error);
      throw error;
    }
  }
  // Continue conversation - Step 2: confirm transcript and process
  async confirmRespondToSession(sessionId, confirmedText) {
    try {
      const response = await this.apiRequest("/respond", "POST", {
        session_id: sessionId,
        user_id: this.settings.userId,
        confirmed_text: confirmedText
      });
      return response;
    } catch (error) {
      console.error("Confirm respond error:", error);
      throw error;
    }
  }
  async saveSessionToVault(session) {
    var _a, _b, _c;
    try {
      const date = new Date().toISOString().split("T")[0];
      const folder = this.settings.syncFolder + "/Sessions";
      await this.ensureFoldersExist([folder]);
      let content = `---
type: training-session
date: ${date}
session_id: ${session.session_id}
tags: [bjj, training, voice-note]
---

# Training Session - ${date}

## Your Notes (Transcribed)

${session.transcript}

## Topics Identified

`;
      if (session.extracted_topics) {
        const topics = session.extracted_topics;
        if ((_a = topics.work_on) == null ? void 0 : _a.length) {
          content += `### Work On
`;
          for (const t of topics.work_on) {
            content += `- **${t.topic}**: ${t.context || ""}
`;
          }
          content += "\n";
        }
        if ((_b = topics.wins) == null ? void 0 : _b.length) {
          content += `### Wins
`;
          for (const t of topics.wins) {
            content += `- **${t.topic}**: ${t.context || ""}
`;
          }
          content += "\n";
        }
      }
      content += `## Coach Response

${session.response_text}

`;
      if ((_c = session.options) == null ? void 0 : _c.length) {
        content += `## Next Steps

`;
        for (const opt of session.options) {
          content += `- [ ] ${opt.label}
`;
        }
      }
      const filename = `${folder}/${date}-${session.session_id.substring(0, 8)}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filename);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filename, content);
      }
      const file = this.app.vault.getAbstractFileByPath(filename);
      if (file instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
      return filename;
    } catch (error) {
      console.error("Error saving session:", error);
      throw error;
    }
  }
  insertTrainingTemplate(editor) {
    const date = new Date().toISOString().split("T")[0];
    const template = `---
type: training-note
date: ${date}
tags: [bjj, training]
---

# Training Notes - ${date}

## What Worked Well


## What Needs Work


## Techniques Practiced


## Questions for Flipmode

`;
    editor.replaceSelection(template);
  }
  // Research method
  async research(topic, context = "") {
    try {
      const response = await this.apiRequest("/research", "POST", {
        topic,
        context,
        max_sources: 10
      });
      return response;
    } catch (error) {
      console.error("Research error:", error);
      throw error;
    }
  }
  async saveResearchToVault(topic, research) {
    try {
      const mdResponse = await this.apiRequest("/sync/research", "POST", {
        topic,
        article: research.article,
        sources: research.sources,
        context: research.context
      });
      const folder = this.settings.syncFolder + "/Research";
      await this.ensureFoldersExist([folder]);
      await this.syncFile({
        path: mdResponse.path,
        content: mdResponse.content,
        checksum: mdResponse.checksum
      });
      const file = this.app.vault.getAbstractFileByPath(mdResponse.path);
      if (file instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
      return mdResponse.path;
    } catch (error) {
      console.error("Error saving research:", error);
      throw error;
    }
  }
};
var FlipmodeMenuModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-modal");
    contentEl.createEl("h2", { text: "Flipmode" });
    const statusEl = contentEl.createEl("p", {
      text: "Checking connection...",
      cls: "flipmode-status"
    });
    this.plugin.checkConnection().then((connected) => {
      statusEl.setText(connected ? "Connected to Flipmode" : "Not connected");
      statusEl.addClass(connected ? "connected" : "disconnected");
    });
    const buttonContainer = contentEl.createDiv({ cls: "flipmode-buttons" });
    new import_obsidian.Setting(buttonContainer).setName("Research Technique").setDesc("Search the Flipmode for technique information").addButton((btn) => btn.setButtonText("Research").setCta().onClick(() => {
      this.close();
      this.plugin.showResearchModal();
    }));
    new import_obsidian.Setting(buttonContainer).setName("Sync with Flipmode").setDesc("Download latest sessions and notes").addButton((btn) => btn.setButtonText("Sync").onClick(() => {
      this.close();
      this.plugin.syncWithFlipmode();
    }));
    new import_obsidian.Setting(buttonContainer).setName("Settings").setDesc("Configure Flipmode connection").addButton((btn) => btn.setButtonText("Open Settings").onClick(() => {
      this.close();
      this.app.setting.open();
      this.app.setting.openTabById("flipmode");
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ResearchModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-research-modal");
    contentEl.createEl("h2", { text: "Research a Technique" });
    new import_obsidian.Setting(contentEl).setName("Technique").setDesc("What technique do you want to research?").addText((text) => {
      this.topicInput = text.inputEl;
      text.setPlaceholder("e.g., knee slice pass, arm drag, berimbolo");
    });
    new import_obsidian.Setting(contentEl).setName("Context (optional)").setDesc("Any specific situation or problem?").addTextArea((text) => {
      this.contextInput = text.inputEl;
      text.setPlaceholder("e.g., defending against it, from closed guard, against bigger opponents");
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Search Flipmode").setCta().onClick(() => this.doResearch()));
    this.resultEl = contentEl.createDiv({ cls: "flipmode-results" });
  }
  async doResearch() {
    const topic = this.topicInput.value.trim();
    if (!topic) {
      new import_obsidian.Notice("Please enter a technique to research");
      return;
    }
    this.resultEl.empty();
    this.resultEl.createEl("p", { text: "Searching Flipmode..." });
    try {
      const research = await this.plugin.research(topic, this.contextInput.value);
      this.resultEl.empty();
      if (research.source_count > 0) {
        this.resultEl.createEl("h3", {
          text: `Found ${research.source_count} sources`
        });
        const previewEl = this.resultEl.createEl("div", { cls: "research-preview" });
        previewEl.createEl("p", {
          text: research.article.substring(0, 300) + "..."
        });
        const sourcesList = this.resultEl.createEl("ul", { cls: "sources-list" });
        for (const source of research.sources.slice(0, 5)) {
          sourcesList.createEl("li", {
            text: `${source.instructor} - ${source.title}`
          });
        }
        new import_obsidian.Setting(this.resultEl).addButton((btn) => btn.setButtonText("Save to Vault").setCta().onClick(async () => {
          try {
            const path = await this.plugin.saveResearchToVault(topic, research);
            new import_obsidian.Notice(`Saved to ${path}`);
            this.close();
          } catch (error) {
            new import_obsidian.Notice("Failed to save research");
          }
        }));
      } else {
        this.resultEl.createEl("p", {
          text: "No sources found. Try a different search term."
        });
      }
    } catch (error) {
      this.resultEl.empty();
      this.resultEl.createEl("p", {
        text: "Research failed. Check your connection settings.",
        cls: "error"
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var VoiceNoteModal = class extends import_obsidian.Modal {
  // Track current session for continuations
  constructor(app, plugin) {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.timerInterval = null;
    this.recordingStartTime = 0;
    this.currentSessionId = null;
    // Track remote therapy session
    this.remoteTherapySessionId = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-voice-modal");
    const headerContainer = contentEl.createDiv({ cls: "flipmode-header" });
    headerContainer.style.textAlign = "center";
    headerContainer.style.margin = "0 0 15px 0";
    const headerImg = headerContainer.createEl("img");
    headerImg.src = FLIPMODE_HEADER_BASE64;
    headerImg.alt = "FLIPMODE";
    headerImg.style.maxWidth = "100%";
    headerImg.style.height = "auto";
    this.timerEl = contentEl.createEl("div", {
      text: "00:00",
      cls: "voice-timer"
    });
    this.timerEl.style.fontSize = "2em";
    this.timerEl.style.textAlign = "center";
    this.timerEl.style.margin = "20px 0";
    this.timerEl.style.fontFamily = "monospace";
    this.statusEl = contentEl.createEl("p", {
      text: "Click to start recording",
      cls: "voice-status"
    });
    this.statusEl.style.textAlign = "center";
    this.statusEl.style.color = "var(--text-muted)";
    this.resultEl = contentEl.createDiv({ cls: "voice-results" });
    const btnContainer = contentEl.createDiv({ cls: "voice-btn-container" });
    btnContainer.style.textAlign = "center";
    btnContainer.style.marginTop = "20px";
    this.recordBtn = btnContainer.createEl("button", {
      text: "START RECORDING"
    });
    this.recordBtn.style.cssText = `
            font-size: 16px;
            font-weight: 600;
            padding: 16px 32px;
            min-width: 200px;
            border: none;
            border-radius: 8px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
            transition: background 0.2s;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        `;
    this.recordBtn.onclick = () => this.toggleRecording();
  }
  async toggleRecording() {
    if (this.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  async startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.audioChunks = [];
      this.mediaRecorder = new MediaRecorder(stream, {
        mimeType: "audio/webm;codecs=opus"
      });
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        stream.getTracks().forEach((track) => track.stop());
        this.processRecording();
      };
      this.mediaRecorder.start(1e3);
      this.isRecording = true;
      this.recordingStartTime = Date.now();
      this.recordBtn.setText("STOP");
      this.recordBtn.style.background = "var(--text-error)";
      this.statusEl.setText("Recording... speak now");
      this.statusEl.style.color = "var(--text-error)";
      this.timerInterval = window.setInterval(() => {
        const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1e3);
        const mins = Math.floor(elapsed / 60).toString().padStart(2, "0");
        const secs = (elapsed % 60).toString().padStart(2, "0");
        this.timerEl.setText(`${mins}:${secs}`);
      }, 1e3);
    } catch (error) {
      console.error("Recording error:", error);
      new import_obsidian.Notice("Could not access microphone. Please allow microphone access.");
      this.statusEl.setText("Microphone access denied");
    }
  }
  async stopRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.isRecording = false;
      if (this.timerInterval) {
        window.clearInterval(this.timerInterval);
        this.timerInterval = null;
      }
      this.recordBtn.setText("PROCESSING...");
      this.recordBtn.disabled = true;
      this.recordBtn.style.background = "var(--text-muted)";
      this.statusEl.setText("Processing your voice note...");
      this.statusEl.style.color = "var(--text-accent)";
    }
  }
  async processRecording() {
    try {
      const audioBlob = new Blob(this.audioChunks, { type: "audio/webm" });
      if (this.plugin.settings.mode === "remote" && this.plugin.settings.athleteToken) {
        this.statusEl.setText("Transcribing via cloud (2min max, 5/day)...");
        try {
          const result = await this.plugin.remoteTranscribe(audioBlob);
          const usageInfo = `(${result.usage.remaining} voice notes remaining today)`;
          this.statusEl.setText(`Transcribed ${Math.round(result.duration)}s ${usageInfo}`);
          this.showRemoteTranscriptConfirmation(result.text, result.usage);
        } catch (error) {
          if (error.message.includes("Daily limit")) {
            this.statusEl.setText("Daily voice note limit reached (5/day)");
            new import_obsidian.Notice("You have used all 5 voice notes for today. Try again tomorrow!");
          } else if (error.message.includes("too long")) {
            this.statusEl.setText("Recording too long (max 2 minutes)");
            new import_obsidian.Notice("Voice notes are limited to 2 minutes. Please record a shorter message.");
          } else {
            throw error;
          }
          this.recordBtn.setText("TRY AGAIN");
          this.recordBtn.disabled = false;
          this.recordBtn.style.background = "var(--interactive-accent)";
          return;
        }
      } else {
        const base64 = await this.blobToBase64(audioBlob);
        this.statusEl.setText("Transcribing...");
        let response;
        if (this.currentSessionId) {
          response = await this.plugin.respondToSession(
            this.currentSessionId,
            void 0,
            base64,
            void 0
          );
          if (response.awaiting_confirmation) {
            this.showTranscriptConfirmation(response.transcript, response.message, this.currentSessionId);
          } else {
            this.displayResults(response);
          }
        } else {
          response = await this.plugin.startVoiceSession(base64);
          if (response.awaiting_confirmation) {
            this.showTranscriptConfirmation(response.transcript, response.message, null);
          } else {
            this.displayResults(response);
          }
        }
      }
    } catch (error) {
      console.error("Processing error:", error);
      this.statusEl.setText("Error processing recording");
      this.statusEl.style.color = "var(--text-error)";
      this.recordBtn.setText("TRY AGAIN");
      this.recordBtn.disabled = false;
      this.recordBtn.style.background = "var(--interactive-accent)";
      this.resultEl.empty();
      this.resultEl.createEl("p", {
        text: `Error: ${error.message || "Could not process recording"}`,
        cls: "error"
      });
    }
  }
  // Show transcript confirmation for remote (athlete) mode - starts therapy session
  async showRemoteTranscriptConfirmation(transcript, usage) {
    this.resultEl.empty();
    this.statusEl.setText("Starting therapy session...");
    this.statusEl.style.color = "var(--text-accent)";
    const usageEl = this.resultEl.createEl("p", {
      text: `Voice notes today: ${usage.count}/${usage.limit} (${usage.remaining} remaining)`
    });
    usageEl.style.textAlign = "center";
    usageEl.style.color = "var(--text-muted)";
    usageEl.style.fontSize = "0.85em";
    usageEl.style.marginBottom = "10px";
    try {
      const therapyResult = await this.plugin.startRemoteTherapy(transcript);
      if (therapyResult.state === "ready") {
        this.showEnrichedQueryConfirmation(therapyResult.enriched_query, transcript);
      } else {
        this.remoteTherapySessionId = therapyResult.session_id;
        this.showTherapyQuestion(therapyResult.question, transcript);
      }
    } catch (error) {
      console.error("Therapy start error:", error);
      this.showDirectSubmitForm(transcript, usage);
    }
  }
  // Show therapy question and let athlete respond
  showTherapyQuestion(question, originalTranscript) {
    this.resultEl.empty();
    this.statusEl.setText("Clarifying your training...");
    this.statusEl.style.color = "var(--text-accent)";
    const origEl = this.resultEl.createEl("p", {
      text: `"${originalTranscript.substring(0, 100)}${originalTranscript.length > 100 ? "..." : ""}"`
    });
    origEl.style.cssText = "font-style: italic; color: var(--text-muted); font-size: 0.9em; margin-bottom: 15px;";
    const questionEl = this.resultEl.createEl("p", { text: question });
    questionEl.style.cssText = "font-weight: 500; margin-bottom: 15px; line-height: 1.5;";
    const textarea = this.resultEl.createEl("textarea");
    textarea.placeholder = "Type your answer...";
    textarea.style.cssText = `
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-primary);
            color: var(--text-normal);
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        `;
    const btnContainer = this.resultEl.createDiv();
    btnContainer.style.cssText = "display: flex; gap: 10px; justify-content: center;";
    const answerBtn = btnContainer.createEl("button", { text: "Answer" });
    answerBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        `;
    answerBtn.onclick = async () => {
      const answer = textarea.value.trim();
      if (!answer) {
        new import_obsidian.Notice("Please type an answer");
        return;
      }
      answerBtn.disabled = true;
      answerBtn.setText("Processing...");
      try {
        const result = await this.plugin.respondToRemoteTherapy(
          this.remoteTherapySessionId,
          answer
        );
        if (result.state === "ready") {
          this.showEnrichedQueryConfirmation(result.enriched_query, originalTranscript);
        } else {
          this.showTherapyQuestion(result.question, originalTranscript);
        }
      } catch (error) {
        new import_obsidian.Notice(`Error: ${error.message}`);
        answerBtn.disabled = false;
        answerBtn.setText("Answer");
      }
    };
    const skipBtn = btnContainer.createEl("button", { text: "Skip & Submit" });
    skipBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--background-modifier-border);
            color: var(--text-normal);
            border: none;
            border-radius: 6px;
            cursor: pointer;
        `;
    skipBtn.onclick = () => {
      this.showEnrichedQueryConfirmation(originalTranscript, originalTranscript);
    };
    this.recordBtn.setText("VOICE ANSWER");
    this.recordBtn.disabled = false;
    this.recordBtn.style.background = "var(--interactive-accent)";
  }
  // Show enriched query for final confirmation before submitting
  showEnrichedQueryConfirmation(enrichedQuery, originalTranscript) {
    this.resultEl.empty();
    this.statusEl.setText("Ready to submit to analyst");
    this.statusEl.style.color = "var(--text-success)";
    const labelEl = this.resultEl.createEl("p", { text: "Your research query:" });
    labelEl.style.cssText = "font-weight: 500; margin-bottom: 10px;";
    const textarea = this.resultEl.createEl("textarea");
    textarea.value = enrichedQuery;
    textarea.style.cssText = `
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-primary);
            color: var(--text-normal);
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        `;
    const btnContainer = this.resultEl.createDiv();
    btnContainer.style.cssText = "display: flex; gap: 10px; justify-content: center;";
    const submitBtn = btnContainer.createEl("button", { text: "Submit to Analyst" });
    submitBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        `;
    submitBtn.onclick = async () => {
      var _a;
      const finalQuery = textarea.value.trim();
      if (!finalQuery) {
        new import_obsidian.Notice("Please enter a query");
        return;
      }
      submitBtn.disabled = true;
      submitBtn.setText("Submitting...");
      try {
        await ((_a = this.plugin.queueClient) == null ? void 0 : _a.submitQuery(finalQuery, {
          original_transcript: originalTranscript,
          therapy_session_id: this.remoteTherapySessionId
        }));
        new import_obsidian.Notice("Query submitted to analyst!");
        await this.saveRemoteVoiceNote(originalTranscript + "\n\n---\n\n**Research Query:** " + finalQuery);
        this.statusEl.setText("Submitted! Your analyst will process this.");
        this.statusEl.style.color = "var(--text-success)";
        this.recordBtn.setText("RECORD ANOTHER");
        this.recordBtn.disabled = false;
        this.recordBtn.style.background = "var(--interactive-accent)";
        this.remoteTherapySessionId = null;
      } catch (error) {
        new import_obsidian.Notice(`Submit failed: ${error.message}`);
        submitBtn.disabled = false;
        submitBtn.setText("Submit to Analyst");
      }
    };
    const saveOnlyBtn = btnContainer.createEl("button", { text: "Save Only" });
    saveOnlyBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--background-modifier-border);
            color: var(--text-normal);
            border: none;
            border-radius: 6px;
            cursor: pointer;
        `;
    saveOnlyBtn.onclick = async () => {
      await this.saveRemoteVoiceNote(originalTranscript + "\n\n---\n\n**Research Query:** " + textarea.value);
      new import_obsidian.Notice("Voice note saved to vault");
      this.close();
    };
    this.recordBtn.setText("RECORD NEW");
    this.recordBtn.disabled = false;
    this.recordBtn.style.background = "var(--interactive-accent)";
  }
  // Fallback: direct submit form (if therapy fails)
  showDirectSubmitForm(transcript, usage) {
    this.resultEl.empty();
    this.statusEl.setText("Review your transcription");
    this.statusEl.style.color = "var(--text-accent)";
    const textarea = this.resultEl.createEl("textarea");
    textarea.value = transcript;
    textarea.style.cssText = `
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-primary);
            color: var(--text-normal);
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        `;
    const btnContainer = this.resultEl.createDiv();
    btnContainer.style.cssText = "display: flex; gap: 10px; justify-content: center;";
    const submitBtn = btnContainer.createEl("button", { text: "Submit to Analyst" });
    submitBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        `;
    submitBtn.onclick = async () => {
      var _a;
      const finalText = textarea.value.trim();
      if (!finalText) {
        new import_obsidian.Notice("Please enter some text");
        return;
      }
      submitBtn.disabled = true;
      submitBtn.setText("Submitting...");
      try {
        await ((_a = this.plugin.queueClient) == null ? void 0 : _a.submitQuery(finalText));
        new import_obsidian.Notice("Query submitted to analyst!");
        await this.saveRemoteVoiceNote(finalText);
        this.statusEl.setText("Submitted! Your analyst will process this.");
        this.statusEl.style.color = "var(--text-success)";
        this.recordBtn.setText("RECORD ANOTHER");
        this.recordBtn.disabled = false;
        this.recordBtn.style.background = "var(--interactive-accent)";
      } catch (error) {
        new import_obsidian.Notice(`Submit failed: ${error.message}`);
        submitBtn.disabled = false;
        submitBtn.setText("Submit to Analyst");
      }
    };
    this.recordBtn.setText("RECORD MORE");
    this.recordBtn.disabled = false;
    this.recordBtn.style.background = "var(--interactive-accent)";
  }
  // Save voice note to vault (for remote mode)
  async saveRemoteVoiceNote(transcript) {
    const date = new Date().toISOString().split("T")[0];
    const time = new Date().toTimeString().split(" ")[0].replace(/:/g, "-");
    const folder = this.plugin.settings.syncFolder + "/VoiceNotes";
    await this.plugin.ensureFoldersExist([folder]);
    const content = `---
type: voice-note
date: ${date}
tags: [bjj, voice-note]
---

# Voice Note - ${date} ${time}

${transcript}
`;
    const fileName = `${folder}/Voice Note ${date} ${time}.md`;
    await this.app.vault.create(fileName, content);
  }
  showTranscriptConfirmation(transcript, message, sessionIdForContinuation) {
    this.resultEl.empty();
    const isContinuation = sessionIdForContinuation !== null;
    this.statusEl.setText("Review your transcription");
    this.statusEl.style.color = "var(--text-accent)";
    const messageEl = this.resultEl.createEl("p", {
      text: message || "Is this transcription correct? Edit if needed, then confirm."
    });
    messageEl.style.textAlign = "center";
    messageEl.style.color = "var(--text-muted)";
    messageEl.style.marginBottom = "15px";
    const textareaContainer = this.resultEl.createDiv({ cls: "transcript-edit-container" });
    textareaContainer.style.marginBottom = "20px";
    const textarea = textareaContainer.createEl("textarea", {
      cls: "transcript-textarea"
    });
    textarea.value = transcript;
    textarea.style.cssText = `
            width: 100%;
            min-height: 120px;
            padding: 12px;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            background: var(--background-primary);
            color: var(--text-normal);
            resize: vertical;
            font-family: inherit;
        `;
    const btnContainer = this.resultEl.createDiv({ cls: "confirm-btn-container" });
    btnContainer.style.textAlign = "center";
    btnContainer.style.display = "flex";
    btnContainer.style.gap = "10px";
    btnContainer.style.justifyContent = "center";
    const reRecordBtn = btnContainer.createEl("button", {
      text: "\u{1F3A4} Re-record"
    });
    reRecordBtn.style.cssText = `
            font-size: 14px;
            padding: 12px 24px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            background: var(--background-secondary);
            color: var(--text-normal);
            cursor: pointer;
        `;
    reRecordBtn.onclick = () => {
      this.isRecording = false;
      this.audioChunks = [];
      if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
        this.mediaRecorder.stop();
      }
      if (this.timerInterval) {
        clearInterval(this.timerInterval);
        this.timerInterval = null;
      }
      this.resultEl.empty();
      this.statusEl.setText(isContinuation ? "Record your answer" : "Click to start recording");
      this.statusEl.style.color = "var(--text-muted)";
      this.recordBtn.setText(isContinuation ? "ANSWER" : "START RECORDING");
      this.recordBtn.disabled = false;
      this.recordBtn.style.display = "inline-block";
      this.recordBtn.style.background = "var(--interactive-accent)";
      this.timerEl.setText("00:00");
    };
    const confirmBtn = btnContainer.createEl("button", {
      text: "\u2713 Confirm & Process"
    });
    confirmBtn.style.cssText = `
            font-size: 14px;
            font-weight: 600;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
        `;
    confirmBtn.onclick = async () => {
      const confirmedText = textarea.value.trim();
      if (!confirmedText) {
        new import_obsidian.Notice("Please enter your training notes");
        return;
      }
      confirmBtn.disabled = true;
      reRecordBtn.disabled = true;
      confirmBtn.setText("Processing...");
      this.statusEl.setText("Processing your training notes...");
      this.statusEl.style.color = "var(--text-accent)";
      try {
        let session;
        if (isContinuation) {
          session = await this.plugin.confirmRespondToSession(sessionIdForContinuation, confirmedText);
        } else {
          session = await this.plugin.confirmVoiceSession(confirmedText);
        }
        this.displayResults(session);
      } catch (error) {
        console.error("Confirm error:", error);
        this.statusEl.setText("Error processing. Try again.");
        this.statusEl.style.color = "var(--text-error)";
        confirmBtn.disabled = false;
        reRecordBtn.disabled = false;
        confirmBtn.setText("\u2713 Confirm & Process");
        new import_obsidian.Notice(`Error: ${error.message || "Could not process"}`);
      }
    };
    this.recordBtn.style.display = "none";
  }
  displayResults(session) {
    var _a, _b;
    this.resultEl.empty();
    this.currentSessionId = session.session_id;
    if ((_b = (_a = session.research) == null ? void 0 : _a.article_sections) == null ? void 0 : _b.length) {
      this.showArticlePlayer(session);
      return;
    }
    if (session.response_audio_url) {
      const audioUrl = `${this.plugin.settings.serverUrl}${session.response_audio_url}`;
      const audio = new Audio(audioUrl);
      audio.play().catch((err) => console.error("Audio error:", err));
      this.statusEl.setText("Oracle is speaking...");
      this.statusEl.style.color = "var(--text-accent)";
      audio.onended = () => {
        this.statusEl.setText("Your turn - record your answer");
        this.statusEl.style.color = "var(--text-success)";
      };
    }
    const questionContainer = this.resultEl.createDiv({ cls: "coach-question" });
    questionContainer.style.background = "var(--background-secondary)";
    questionContainer.style.padding = "20px";
    questionContainer.style.borderRadius = "12px";
    questionContainer.style.marginBottom = "20px";
    questionContainer.style.textAlign = "center";
    const questionText = questionContainer.createEl("p", {
      text: session.response_text
    });
    questionText.style.fontSize = "1.2em";
    questionText.style.margin = "0";
    questionText.style.lineHeight = "1.5";
    questionText.style.textAlign = "center";
    if (session.state === "RESEARCHING") {
      const isRemote = this.plugin.isRemoteMode();
      this.statusEl.setText(isRemote ? "Ready to send to Oracle!" : "Ready to generate wisdom!");
      this.statusEl.style.color = "var(--text-success)";
      const bigBtnContainer = this.resultEl.createDiv();
      bigBtnContainer.style.textAlign = "center";
      bigBtnContainer.style.marginTop = "30px";
      const generateBtn = bigBtnContainer.createEl("button", {
        text: isRemote ? "\u{1F4E4} Send to Oracle" : "\u2728 Generate Wisdom",
        cls: "mod-cta"
      });
      generateBtn.style.fontSize = "1.4em";
      generateBtn.style.padding = "20px 40px";
      generateBtn.style.borderRadius = "12px";
      generateBtn.onclick = async () => {
        var _a2, _b2, _c, _d, _e, _f, _g;
        const sessionId = this.currentSessionId;
        const plugin = this.plugin;
        const app = this.app;
        const topic = ((_a2 = session.selected_topic) == null ? void 0 : _a2.name) || "Research";
        if (isRemote) {
          const therapyContext = {
            conversation: session.conversation || [],
            selected_topic: session.selected_topic
          };
          const jobId = await plugin.submitToCoach(topic, therapyContext);
          if (jobId) {
            new import_obsidian.Notice("Query sent to Oracle! Check back later for results.", 5e3);
          }
          this.close();
          return;
        }
        new import_obsidian.Notice("Generating wisdom in background...", 3e3);
        this.close();
        try {
          const response = await plugin.respondToSession(
            sessionId,
            "generate",
            void 0,
            void 0
          );
          const responseTopic = ((_b2 = response.selected_topic) == null ? void 0 : _b2.name) || ((_c = response.research) == null ? void 0 : _c.topic) || ((_d = session.selected_topic) == null ? void 0 : _d.name) || "Research";
          if ((_e = response.research) == null ? void 0 : _e.article_raw) {
            const filename = await plugin.saveArticleToVault(responseTopic, response.research.article_raw);
            new import_obsidian.Notice(`Wisdom ready! Saved to ${filename}`, 3e3);
          }
          if (((_g = (_f = response.research) == null ? void 0 : _f.article_sections) == null ? void 0 : _g.length) > 0) {
            const articleContent = response.research.article || response.research.article_raw || "";
            const sources = response.research.sources || [];
            const playerModal = new AudioPlayerModal(app, plugin, responseTopic, response.research.article_sections, sessionId, articleContent, sources);
            playerModal.open();
          } else {
            new import_obsidian.Notice("Research complete! Check your Flipmode folder.", 5e3);
          }
        } catch (error) {
          console.error("Generate error:", error);
          new import_obsidian.Notice("Failed to generate wisdom. Try again.", 5e3);
        }
      };
      this.recordBtn.style.display = "none";
      return;
    }
    const answerBtnContainer = this.resultEl.createDiv({ cls: "answer-btn-container" });
    answerBtnContainer.style.textAlign = "center";
    answerBtnContainer.style.marginTop = "20px";
    answerBtnContainer.style.display = "flex";
    answerBtnContainer.style.justifyContent = "center";
    answerBtnContainer.style.gap = "15px";
    answerBtnContainer.appendChild(this.recordBtn);
    this.recordBtn.setText("ANSWER");
    this.recordBtn.disabled = false;
    this.recordBtn.style.display = "inline-flex";
    this.recordBtn.style.background = "var(--interactive-accent)";
    const doneBtn = answerBtnContainer.createEl("button", {
      text: "DONE",
      cls: "mod-cta"
    });
    doneBtn.style.cssText = `
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
        `;
    doneBtn.onclick = async () => {
      if (!this.currentSessionId) {
        new import_obsidian.Notice("No session to save", 3e3);
        this.close();
        return;
      }
      doneBtn.disabled = true;
      doneBtn.setText("Saving...");
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: `${this.plugin.settings.serverUrl}/api/obsidian/sync/session/${this.currentSessionId}`,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${this.plugin.settings.apiToken}`
          }
        });
        const data = response.json;
        if (data.content) {
          const season = this.plugin.settings.currentSeason;
          const episode = this.plugin.settings.currentEpisode;
          const athleteName = this.plugin.settings.athleteName || "Athlete";
          const dateStr = new Date().toISOString().split("T")[0];
          const frontmatter = data.frontmatter || {};
          const topics = frontmatter.topics || [];
          const wins = frontmatter.wins || [];
          let focus = frontmatter.selected_topic || topics[0] || wins[0] || "general";
          focus = focus.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "_").substring(0, 30);
          const baseFilename = `TrainingNotes-${dateStr}-${focus}`;
          const reviewFilename = `TrainingReview-${dateStr}-${focus}`;
          const folderPath = `${this.plugin.settings.syncFolder}/Athletes/${athleteName}/Season ${season}/Session ${episode}`;
          const fullPath = `${folderPath}/${baseFilename}.md`;
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (!folder) {
            await this.app.vault.createFolder(folderPath);
          }
          let previousSessionLink = "";
          if (episode > 1) {
            const prevFolderPath = `${this.plugin.settings.syncFolder}/Athletes/${athleteName}/Season ${season}/Session ${episode - 1}`;
            const prevFolder = this.app.vault.getAbstractFileByPath(prevFolderPath);
            if (prevFolder instanceof import_obsidian.TFolder) {
              const prevFiles = prevFolder.children.filter((f) => f instanceof import_obsidian.TFile && f.name.startsWith("TrainingNotes-"));
              if (prevFiles.length > 0) {
                previousSessionLink = `
previous_session: "[[${prevFiles[0].basename}]]"`;
              }
            }
          }
          const enhancedContent = `---
type: training-notes
season: ${season}
episode: ${episode}
date: ${dateStr}
focus: "${focus}"
session_id: "${this.currentSessionId}"${previousSessionLink}
tags: [bjj, training, season-${season}, ${focus.replace(/_/g, "-")}]
---

${data.content}
`;
          const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
          if (existingFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(existingFile, enhancedContent);
          } else {
            await this.app.vault.create(fullPath, enhancedContent);
          }
          this.plugin.settings.currentEpisode = episode + 1;
          await this.plugin.saveSettings();
          new import_obsidian.Notice(`Session saved: ${baseFilename}`, 3e3);
        } else {
          new import_obsidian.Notice("Session ended", 3e3);
        }
      } catch (error) {
        console.error("Error saving session:", error);
        new import_obsidian.Notice("Session ended (save failed)", 3e3);
      }
      this.close();
    };
  }
  showArticlePlayer(session) {
    this.statusEl.setText("Here's your wisdom");
    this.statusEl.style.color = "var(--text-success)";
    const titleEl = this.resultEl.createEl("h3", {
      text: session.research.topic || "Your Research"
    });
    titleEl.style.textAlign = "center";
    titleEl.style.marginBottom = "20px";
    const sectionsContainer = this.resultEl.createDiv({ cls: "article-sections" });
    sectionsContainer.style.background = "var(--background-secondary)";
    sectionsContainer.style.padding = "15px";
    sectionsContainer.style.borderRadius = "12px";
    sectionsContainer.style.marginBottom = "20px";
    let currentAudio = null;
    for (const section of session.research.article_sections) {
      const sectionDiv = sectionsContainer.createDiv({ cls: "section-item" });
      sectionDiv.style.display = "flex";
      sectionDiv.style.alignItems = "center";
      sectionDiv.style.gap = "12px";
      sectionDiv.style.padding = "10px";
      sectionDiv.style.cursor = "pointer";
      sectionDiv.style.borderRadius = "8px";
      const playBtn = sectionDiv.createEl("span", { text: "\u25B6" });
      playBtn.style.fontSize = "1.2em";
      playBtn.style.width = "24px";
      const titleEl2 = sectionDiv.createEl("span", { text: section.title });
      titleEl2.style.flex = "1";
      titleEl2.style.fontWeight = "500";
      const audioUrl = `${this.plugin.settings.serverUrl}${section.audio_url}`;
      const audio = new Audio(audioUrl);
      const playSection = () => {
        if (currentAudio && currentAudio !== audio) {
          currentAudio.pause();
        }
        currentAudio = audio;
        audio.play();
        playBtn.setText("\u23F8");
        sectionDiv.style.background = "var(--background-modifier-active-hover)";
      };
      sectionDiv.onclick = playSection;
      audio.onended = () => {
        playBtn.setText("\u25B6");
        sectionDiv.style.background = "";
      };
      audio.onpause = () => {
        playBtn.setText("\u25B6");
        sectionDiv.style.background = "";
      };
    }
    if (session.research.article_sections.length > 0) {
      const firstAudioUrl = `${this.plugin.settings.serverUrl}${session.research.article_sections[0].audio_url}`;
      const firstAudio = new Audio(firstAudioUrl);
      firstAudio.play().catch(() => {
      });
    }
    const actionsContainer = this.resultEl.createDiv();
    actionsContainer.style.display = "flex";
    actionsContainer.style.flexDirection = "column";
    actionsContainer.style.gap = "12px";
    actionsContainer.style.marginTop = "20px";
    const diveBtn = actionsContainer.createEl("button", {
      text: "DIVE DEEPER",
      cls: "mod-cta"
    });
    diveBtn.style.fontSize = "1.2em";
    diveBtn.style.padding = "15px 30px";
    diveBtn.onclick = () => {
      this.statusEl.setText("Record a follow-up question...");
      this.recordBtn.setText("RECORD FOLLOW-UP");
      this.recordBtn.disabled = false;
      this.recordBtn.style.display = "inline-block";
      this.recordBtn.scrollIntoView({ behavior: "smooth" });
    };
    const planBtn = actionsContainer.createEl("button", {
      text: "CREATE TRAINING PLAN"
    });
    planBtn.style.padding = "12px 24px";
    planBtn.onclick = async () => {
      var _a, _b, _c, _d;
      planBtn.disabled = true;
      planBtn.setText("Creating...");
      try {
        const topic = ((_a = session.research) == null ? void 0 : _a.topic) || ((_b = session.selected_topic) == null ? void 0 : _b.name) || "Training";
        const article = ((_c = session.research) == null ? void 0 : _c.article) || ((_d = session.research) == null ? void 0 : _d.article_raw) || "";
        const response = await this.plugin.apiRequest("/training-plan", "POST", {
          session_id: this.currentSessionId,
          user_id: this.plugin.settings.userId,
          topic,
          article
          // Pass article for training recommendations extraction
        });
        if (response.markdown) {
          const cleanTopic = topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 40);
          const date = new Date().toISOString().split("T")[0];
          const filename = `${this.plugin.settings.syncFolder}/Plans/${date} - ${cleanTopic} Plan.md`;
          const planFolder = `${this.plugin.settings.syncFolder}/Plans`;
          const folder = this.app.vault.getAbstractFileByPath(planFolder);
          if (!folder) {
            await this.app.vault.createFolder(planFolder);
          }
          const existingFile = this.app.vault.getAbstractFileByPath(filename);
          if (existingFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(existingFile, response.markdown);
          } else {
            await this.app.vault.create(filename, response.markdown);
          }
          const file = this.app.vault.getAbstractFileByPath(filename);
          if (file instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
          }
          new import_obsidian.Notice(`Training plan saved to ${filename}`);
        } else {
          new import_obsidian.Notice("Plan created but no content returned");
        }
      } catch (error) {
        console.error("Plan error:", error);
        new import_obsidian.Notice("Failed to create plan");
        planBtn.disabled = false;
        planBtn.setText("CREATE TRAINING PLAN");
      }
    };
    this.recordBtn.style.display = "none";
  }
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64 = reader.result.split(",")[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  onClose() {
    if (this.isRecording && this.mediaRecorder) {
      this.mediaRecorder.stop();
    }
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DiveDeepModal = class extends import_obsidian.Modal {
  constructor(app, plugin, topic, sessionContext, rlmSessionId = "") {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.plugin = plugin;
    this.topic = topic;
    this.sessionContext = sessionContext;
    this.rlmSessionId = rlmSessionId;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-dive-deep-modal");
    const titleEl = contentEl.createEl("h2", { text: "Dive Deeper" });
    titleEl.style.textAlign = "center";
    const topicEl = contentEl.createEl("p", { text: `Topic: ${this.topic}` });
    topicEl.style.textAlign = "center";
    topicEl.style.color = "var(--text-accent)";
    topicEl.style.fontWeight = "600";
    const contextContainer = contentEl.createDiv();
    contextContainer.style.background = "var(--background-secondary)";
    contextContainer.style.padding = "15px";
    contextContainer.style.borderRadius = "8px";
    contextContainer.style.marginBottom = "20px";
    contextContainer.style.maxHeight = "150px";
    contextContainer.style.overflowY = "auto";
    const contextLabel = contextContainer.createEl("p", { text: "Session Notes:" });
    contextLabel.style.fontWeight = "600";
    contextLabel.style.marginBottom = "8px";
    const contextText = contextContainer.createEl("p", { text: this.sessionContext });
    contextText.style.fontSize = "0.9em";
    contextText.style.whiteSpace = "pre-wrap";
    this.statusEl = contentEl.createEl("p", { text: "Record your follow-up question" });
    this.statusEl.style.textAlign = "center";
    this.statusEl.style.color = "var(--text-muted)";
    const btnContainer = contentEl.createDiv();
    btnContainer.style.textAlign = "center";
    btnContainer.style.marginTop = "20px";
    this.recordBtn = btnContainer.createEl("button", { text: "RECORD QUESTION", cls: "mod-cta" });
    this.recordBtn.style.padding = "16px 32px";
    this.recordBtn.style.fontSize = "1.1em";
    this.recordBtn.onclick = () => this.toggleRecording();
  }
  async toggleRecording() {
    if (this.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  async startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.audioChunks = [];
      this.mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });
      this.mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0)
          this.audioChunks.push(e.data);
      };
      this.mediaRecorder.onstop = async () => {
        stream.getTracks().forEach((t) => t.stop());
        await this.processRecording();
      };
      this.mediaRecorder.start();
      this.isRecording = true;
      this.recordBtn.setText("STOP");
      this.recordBtn.style.background = "var(--text-error)";
      this.statusEl.setText("Recording... speak your question");
    } catch (error) {
      new import_obsidian.Notice("Could not access microphone");
    }
  }
  async stopRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.isRecording = false;
    }
  }
  async processRecording() {
    var _a, _b;
    this.recordBtn.setText("PROCESSING...");
    this.recordBtn.disabled = true;
    this.statusEl.setText("Sending to Flipmode...");
    try {
      const audioBlob = new Blob(this.audioChunks, { type: "audio/webm" });
      const base64Audio = await this.blobToBase64(audioBlob);
      const sessionResponse = await this.plugin.apiRequest("/session", "POST", {
        user_id: this.plugin.settings.userId
      });
      const response = await this.plugin.apiRequest("/respond", "POST", {
        session_id: sessionResponse.session_id,
        audio_base64: base64Audio,
        audio_format: "webm",
        context: `Follow-up on ${this.topic}. Session notes: ${this.sessionContext}`
      });
      new import_obsidian.Notice("Researching in background...", 3e3);
      this.close();
      if (((_b = (_a = response.research) == null ? void 0 : _a.article_sections) == null ? void 0 : _b.length) > 0) {
        const articleContent = response.research.article || response.research.article_raw || "";
        const sources = response.research.sources || [];
        const playerModal = new AudioPlayerModal(
          this.app,
          this.plugin,
          this.topic + " - Follow-up",
          response.research.article_sections,
          sessionResponse.session_id,
          articleContent,
          sources
        );
        playerModal.open();
      }
    } catch (error) {
      console.error("Dive deep error:", error);
      new import_obsidian.Notice("Failed to process - try again");
      this.recordBtn.setText("RECORD QUESTION");
      this.recordBtn.disabled = false;
    }
  }
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result.split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  onClose() {
    if (this.isRecording && this.mediaRecorder) {
      this.mediaRecorder.stop();
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AudioPlayerModal = class extends import_obsidian.Modal {
  constructor(app, plugin, topic, sections, sessionId, articleContent, sources) {
    super(app);
    // Video sources with timestamps
    this.currentIndex = 0;
    this.currentAudio = null;
    this.isPlaying = false;
    this.volume = 0.8;
    this.sectionItems = [];
    this.savedFilePath = null;
    this.plugin = plugin;
    this.topic = topic;
    this.sections = sections;
    this.sessionId = sessionId || null;
    this.articleContent = articleContent || "";
    this.sources = sources || [];
  }
  async saveResearchToVault() {
    if (!this.articleContent) {
      return null;
    }
    try {
      const cleanTopic = this.topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
      const date = new Date().toISOString().split("T")[0];
      const baseFolder = this.plugin.settings.syncFolder;
      const researchFolder = `${baseFolder}/Research`;
      const topicAudioFolder = `${researchFolder}/audio/${cleanTopic}`;
      for (const folder of [baseFolder, researchFolder, `${researchFolder}/audio`, topicAudioFolder]) {
        const existing = this.app.vault.getAbstractFileByPath(folder);
        if (!existing) {
          await this.app.vault.createFolder(folder);
        }
      }
      const audioEmbeds = [];
      for (let i = 0; i < this.sections.length; i++) {
        const section = this.sections[i];
        const sectionNum = String(i + 1).padStart(2, "0");
        const cleanSectionTitle = section.title.replace(/[\\/:*?"<>|]/g, "-").substring(0, 40);
        const audioFilename = `${sectionNum}-${cleanSectionTitle}.mp3`;
        const audioPath = `${topicAudioFolder}/${audioFilename}`;
        try {
          const audioUrl = `${this.plugin.settings.serverUrl}${section.audio_url}`;
          const response = await fetch(audioUrl, {
            headers: {
              "Authorization": `Bearer ${this.plugin.settings.apiToken}`
            }
          });
          if (response.ok) {
            const audioBlob = await response.blob();
            const arrayBuffer = await audioBlob.arrayBuffer();
            const existingAudio = this.app.vault.getAbstractFileByPath(audioPath);
            if (existingAudio instanceof import_obsidian.TFile) {
              await this.app.vault.modifyBinary(existingAudio, arrayBuffer);
            } else {
              await this.app.vault.createBinary(audioPath, arrayBuffer);
            }
            audioEmbeds.push(`### ${section.title}
![[${audioPath}]]`);
          }
        } catch (err) {
          console.error(`Failed to download audio for section ${i}:`, err);
          audioEmbeds.push(`### ${section.title}
*Audio not available*`);
        }
      }
      const markdownContent = `---
topic: "${this.topic}"
date: ${date}
type: research
---

# ${this.topic}

${this.articleContent}

---

## \u{1F3A7} Audio Sections

${audioEmbeds.join("\n\n")}
`;
      const filename = `${researchFolder}/${date} - ${cleanTopic}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filename);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, markdownContent);
      } else {
        await this.app.vault.create(filename, markdownContent);
      }
      this.savedFilePath = filename;
      return filename;
    } catch (error) {
      console.error("Error saving research to vault:", error);
      return null;
    }
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-audio-player");
    const titleEl = contentEl.createEl("h2", { text: this.topic || "Research" });
    titleEl.style.textAlign = "center";
    titleEl.style.marginBottom = "10px";
    this.statusEl = contentEl.createEl("p", { text: this.articleContent ? "Saving to vault..." : "Ready to play" });
    this.statusEl.style.textAlign = "center";
    this.statusEl.style.color = "var(--text-muted)";
    this.statusEl.style.marginBottom = "20px";
    if (this.articleContent) {
      this.saveResearchToVault().then((savedPath) => {
        if (savedPath) {
          new import_obsidian.Notice(`Research saved to ${savedPath}`, 3e3);
        }
      });
    }
    const sectionsContainer = contentEl.createDiv({ cls: "audio-sections" });
    sectionsContainer.style.background = "var(--background-secondary)";
    sectionsContainer.style.padding = "15px";
    sectionsContainer.style.borderRadius = "12px";
    sectionsContainer.style.marginBottom = "20px";
    sectionsContainer.style.maxHeight = "300px";
    sectionsContainer.style.overflowY = "auto";
    this.sections.forEach((section, index) => {
      const sectionDiv = sectionsContainer.createDiv({ cls: "section-item" });
      sectionDiv.style.display = "flex";
      sectionDiv.style.alignItems = "center";
      sectionDiv.style.gap = "12px";
      sectionDiv.style.padding = "10px";
      sectionDiv.style.borderRadius = "8px";
      sectionDiv.style.cursor = "pointer";
      const indicator = sectionDiv.createEl("span", { text: "\u25CB" });
      indicator.style.fontSize = "1em";
      indicator.style.width = "20px";
      indicator.addClass("section-indicator");
      const titleSpan = sectionDiv.createEl("span", { text: section.title });
      titleSpan.style.flex = "1";
      sectionDiv.onclick = () => this.playSection(index);
      this.sectionItems.push(sectionDiv);
    });
    const controlsContainer = contentEl.createDiv();
    controlsContainer.style.display = "flex";
    controlsContainer.style.justifyContent = "center";
    controlsContainer.style.alignItems = "center";
    controlsContainer.style.gap = "10px";
    controlsContainer.style.marginTop = "20px";
    const transportControls = controlsContainer.createDiv();
    transportControls.style.display = "flex";
    transportControls.style.alignItems = "center";
    transportControls.style.gap = "5px";
    transportControls.style.background = "var(--background-secondary)";
    transportControls.style.borderRadius = "25px";
    transportControls.style.padding = "5px 10px";
    const prevBtn = transportControls.createEl("button", { text: "\u23EE" });
    prevBtn.style.padding = "10px 15px";
    prevBtn.style.fontSize = "1.2em";
    prevBtn.style.border = "none";
    prevBtn.style.background = "transparent";
    prevBtn.style.cursor = "pointer";
    prevBtn.title = "Previous section";
    prevBtn.onclick = () => {
      if (this.currentIndex > 0) {
        this.playSection(this.currentIndex - 1);
      }
    };
    const pauseBtn = transportControls.createEl("button", { text: "\u23F8" });
    pauseBtn.style.padding = "10px 20px";
    pauseBtn.style.fontSize = "1.4em";
    pauseBtn.style.border = "none";
    pauseBtn.style.background = "var(--interactive-accent)";
    pauseBtn.style.color = "var(--text-on-accent)";
    pauseBtn.style.borderRadius = "50%";
    pauseBtn.style.width = "50px";
    pauseBtn.style.height = "50px";
    pauseBtn.style.cursor = "pointer";
    pauseBtn.title = "Pause/Resume";
    pauseBtn.onclick = () => {
      if (this.currentAudio) {
        if (this.isPlaying) {
          this.currentAudio.pause();
          pauseBtn.setText("\u25B6");
          this.isPlaying = false;
        } else {
          this.currentAudio.play();
          pauseBtn.setText("\u23F8");
          this.isPlaying = true;
        }
      }
    };
    const nextBtn = transportControls.createEl("button", { text: "\u23ED" });
    nextBtn.style.padding = "10px 15px";
    nextBtn.style.fontSize = "1.2em";
    nextBtn.style.border = "none";
    nextBtn.style.background = "transparent";
    nextBtn.style.cursor = "pointer";
    nextBtn.title = "Next section";
    nextBtn.onclick = () => {
      if (this.currentIndex < this.sections.length - 1) {
        this.playSection(this.currentIndex + 1);
      }
    };
    const volumeContainer = controlsContainer.createDiv();
    volumeContainer.style.display = "flex";
    volumeContainer.style.alignItems = "center";
    volumeContainer.style.gap = "8px";
    const volumeIcon = volumeContainer.createEl("span", { text: "\u{1F50A}" });
    volumeIcon.style.fontSize = "1.2em";
    const volumeSlider = volumeContainer.createEl("input");
    volumeSlider.type = "range";
    volumeSlider.min = "0";
    volumeSlider.max = "100";
    volumeSlider.value = String(this.volume * 100);
    volumeSlider.style.width = "80px";
    volumeSlider.style.cursor = "pointer";
    volumeSlider.oninput = () => {
      this.volume = parseInt(volumeSlider.value) / 100;
      if (this.currentAudio) {
        this.currentAudio.volume = this.volume;
      }
      if (this.volume === 0) {
        volumeIcon.setText("\u{1F507}");
      } else if (this.volume < 0.5) {
        volumeIcon.setText("\u{1F509}");
      } else {
        volumeIcon.setText("\u{1F50A}");
      }
    };
    if (!this.articleContent) {
    } else {
      const planBtn = controlsContainer.createEl("button", { text: "TRAINING PLAN" });
      planBtn.style.padding = "12px 24px";
      planBtn.onclick = async () => {
        var _a, _b, _c;
        planBtn.disabled = true;
        planBtn.setText("Creating plan...");
        try {
          const response = await this.plugin.apiRequest("/training-plan", "POST", {
            session_id: this.sessionId,
            user_id: this.plugin.settings.userId,
            topic: this.topic,
            article: this.articleContent,
            sources: this.sources,
            // Pass sources for video clip extraction
            include_video_refs: true
          });
          if (response.markdown) {
            const cleanTopic = this.topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 40);
            const date = new Date().toISOString().split("T")[0];
            const planFilename = `${this.plugin.settings.syncFolder}/Plans/${date} - ${cleanTopic} Plan.md`;
            const planFolder = `${this.plugin.settings.syncFolder}/Plans`;
            const folder = this.app.vault.getAbstractFileByPath(planFolder);
            if (!folder) {
              await this.app.vault.createFolder(planFolder);
            }
            const clipsBaseFolder = `${planFolder}/clips`;
            const clipsBaseFolderObj = this.app.vault.getAbstractFileByPath(clipsBaseFolder);
            if (!clipsBaseFolderObj) {
              await this.app.vault.createFolder(clipsBaseFolder);
            }
            const clipsFolder = `${clipsBaseFolder}/${cleanTopic}`;
            const clipsFolderObj = this.app.vault.getAbstractFileByPath(clipsFolder);
            if (!clipsFolderObj) {
              await this.app.vault.createFolder(clipsFolder);
            }
            let videoSection = "";
            if (response.clips && response.clips.length > 0) {
              planBtn.setText(`Downloading ${response.clips.length} clips...`);
              const clipEmbeds = [];
              for (const clip of response.clips) {
                try {
                  const clipResponse = await (0, import_obsidian.requestUrl)({
                    url: `${this.plugin.settings.serverUrl}${clip.clip_url}`,
                    method: "GET",
                    headers: {
                      "Authorization": `Bearer ${this.plugin.settings.apiToken}`
                    }
                  });
                  const clipFilename = `${clip.instructor.replace(/[\\/:*?"<>|]/g, "-")} - ${clip.timestamp.replace(/:/g, "-")}.mp4`;
                  const clipPath = `${clipsFolder}/${clipFilename}`;
                  const existingClip = this.app.vault.getAbstractFileByPath(clipPath);
                  if (!existingClip) {
                    await this.app.vault.createBinary(clipPath, clipResponse.arrayBuffer);
                  }
                  clipEmbeds.push(`#### ${clip.instructor} @ ${clip.timestamp}
![[${clipPath}]]`);
                } catch (clipError) {
                  console.error("Failed to download clip:", clipError);
                }
              }
              if (clipEmbeds.length > 0) {
                videoSection = `

## Reference Video Clips

These clips show the actual techniques from the research sources. Watch them to see how the moves should look:

${clipEmbeds.join("\n\n")}
`;
              }
            }
            let researchLink = "";
            if (this.savedFilePath) {
              const researchFileName = ((_a = this.savedFilePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "";
              researchLink = `> **Based on research:** [[${researchFileName}]]

`;
            }
            const planContent = `---
topic: "${this.topic}"
date: ${date}
type: training-plan
research: "${this.savedFilePath || ""}"
clips: ${((_b = response.clips) == null ? void 0 : _b.length) || 0}
---

${researchLink}${response.markdown}${videoSection}`;
            const existingFile = this.app.vault.getAbstractFileByPath(planFilename);
            if (existingFile instanceof import_obsidian.TFile) {
              await this.app.vault.modify(existingFile, planContent);
            } else {
              await this.app.vault.create(planFilename, planContent);
            }
            const file = this.app.vault.getAbstractFileByPath(planFilename);
            if (file instanceof import_obsidian.TFile) {
              await this.app.workspace.getLeaf().openFile(file);
            }
            const clipMsg = ((_c = response.clips) == null ? void 0 : _c.length) ? ` with ${response.clips.length} video clips` : "";
            new import_obsidian.Notice(`Training plan saved${clipMsg}`);
            planBtn.setText("TRAINING PLAN");
            planBtn.disabled = false;
          } else {
            new import_obsidian.Notice("Plan created but no content returned");
            planBtn.setText("TRAINING PLAN");
            planBtn.disabled = false;
          }
        } catch (error) {
          console.error("Plan error:", error);
          new import_obsidian.Notice("Failed to create plan");
          planBtn.disabled = false;
          planBtn.setText("TRAINING PLAN");
        }
      };
      const viewBtn = controlsContainer.createEl("button", { text: "VIEW IN VAULT" });
      viewBtn.style.padding = "12px 24px";
      viewBtn.onclick = async () => {
        if (this.savedFilePath) {
          const file = this.app.vault.getAbstractFileByPath(this.savedFilePath);
          if (file instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
            this.close();
          }
        } else {
          new import_obsidian.Notice("Still saving... please wait");
        }
      };
    }
    const closeBtn = controlsContainer.createEl("button", { text: "CLOSE" });
    closeBtn.style.padding = "12px 24px";
    closeBtn.onclick = () => this.close();
    if (this.sections.length > 0) {
      this.playSection(0);
    }
  }
  playSection(index) {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio = null;
    }
    if (index >= this.sections.length) {
      this.isPlaying = false;
      this.statusEl.setText("\u2713 Playback complete - click any section to replay");
      this.sectionItems.forEach((item) => {
        const indicator = item.querySelector(".section-indicator");
        indicator.setText("\u2713");
        item.style.opacity = "1";
        item.style.background = "";
      });
      return;
    }
    this.currentIndex = index;
    this.sectionItems.forEach((item, i) => {
      const indicator = item.querySelector(".section-indicator");
      if (i < index) {
        indicator.setText("\u2713");
        item.style.opacity = "0.7";
        item.style.background = "";
      } else if (i === index) {
        indicator.setText("\u25B6");
        item.style.background = "var(--background-modifier-active-hover)";
        item.style.opacity = "1";
      } else {
        indicator.setText("\u25CB");
        item.style.background = "";
        item.style.opacity = "1";
      }
    });
    const section = this.sections[index];
    this.statusEl.setText(`Playing: ${section.title}`);
    const audioUrl = `${this.plugin.settings.serverUrl}${section.audio_url}`;
    this.currentAudio = new Audio(audioUrl);
    this.currentAudio.volume = this.volume;
    this.isPlaying = true;
    this.currentAudio.play().catch((err) => {
      console.error("Audio play error:", err);
      this.statusEl.setText(`Error playing ${section.title} - click to retry`);
    });
    this.currentAudio.onended = () => {
      this.sectionItems[index].style.background = "";
      this.playSection(index + 1);
    };
    this.currentAudio.onerror = () => {
      console.error("Audio load error for section:", section.title);
      this.statusEl.setText(`Error loading audio - click section to retry`);
    };
  }
  onClose() {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio = null;
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CoachAddAthleteModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Add Athlete to Roster" });
    let discordId = "";
    let displayName = "";
    new import_obsidian.Setting(contentEl).setName("Discord ID").setDesc("The athlete's Discord user ID (18-digit number)").addText((text) => text.setPlaceholder("123456789012345678").onChange((value) => discordId = value));
    new import_obsidian.Setting(contentEl).setName("Display Name").setDesc("Optional friendly name").addText((text) => text.setPlaceholder("John Doe").onChange((value) => displayName = value));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Add Athlete").setCta().onClick(async () => {
      if (!discordId) {
        new import_obsidian.Notice("Discord ID is required");
        return;
      }
      try {
        await this.plugin.coachClient.addAthlete(discordId, displayName || void 0);
        new import_obsidian.Notice("Athlete added to roster!");
        this.close();
      } catch (error) {
        new import_obsidian.Notice("Failed to add athlete");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var AthleteSelectModal = class extends import_obsidian.Modal {
  constructor(app, athletes, onSelect) {
    super(app);
    this.athletes = athletes;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select Athlete" });
    contentEl.createEl("p", { text: "Choose an athlete to share this content with:" });
    const listEl = contentEl.createEl("div", { cls: "athlete-select-list" });
    for (const athlete of this.athletes) {
      const athleteEl = listEl.createEl("div", { cls: "athlete-select-item" });
      athleteEl.style.cssText = "padding: 10px; margin: 5px 0; border-radius: 5px; cursor: pointer; background: var(--background-secondary);";
      const name = athlete.display_name || athlete.discord_username || `Athlete ${athlete.id}`;
      athleteEl.createEl("strong", { text: name });
      if (athlete.discord_username && athlete.discord_username !== name) {
        athleteEl.createEl("span", {
          text: ` (@${athlete.discord_username})`,
          cls: "athlete-discord-name"
        });
      }
      athleteEl.addEventListener("click", () => {
        this.onSelect(athlete);
        this.close();
      });
      athleteEl.addEventListener("mouseenter", () => {
        athleteEl.style.background = "var(--background-modifier-hover)";
      });
      athleteEl.addEventListener("mouseleave", () => {
        athleteEl.style.background = "var(--background-secondary)";
      });
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ArticleBibliographyModal = class extends import_obsidian.Modal {
  constructor(app, plugin, bibliographyData, sourceFile) {
    super(app);
    this.plugin = plugin;
    this.bibliographyData = bibliographyData;
    this.sourceFile = sourceFile;
  }
  onOpen() {
    const { contentEl } = this;
    const { bibliographyData } = this;
    contentEl.createEl("h2", { text: "Article Source Videos" });
    const queryEl = contentEl.createEl("div", { cls: "original-query" });
    queryEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px; border-left: 3px solid var(--interactive-accent);";
    queryEl.createEl("p", {
      text: `Original Question: "${bibliographyData.original_query}"`,
      cls: "query-text"
    });
    const statsEl = contentEl.createEl("div", { cls: "bibliography-stats" });
    statsEl.style.cssText = "margin-bottom: 15px; display: flex; gap: 15px;";
    statsEl.createEl("span", { text: `\u{1F4F9} ${bibliographyData.total_videos} videos` });
    statsEl.createEl("span", { text: `\u{1F464} ${bibliographyData.instructors.length} instructors` });
    contentEl.createEl("p", {
      text: "Click any video to view its full concept cache with timestamps:",
      cls: "bibliography-instructions"
    });
    const listEl = contentEl.createEl("div", { cls: "videos-list" });
    listEl.style.cssText = "max-height: 450px; overflow-y: auto;";
    const byInstructor = {};
    for (const video of bibliographyData.videos) {
      const instructor = video.instructor || "Unknown";
      if (!byInstructor[instructor]) {
        byInstructor[instructor] = [];
      }
      byInstructor[instructor].push(video);
    }
    for (const instructor of Object.keys(byInstructor).sort()) {
      const groupEl = listEl.createEl("div", { cls: "instructor-group" });
      groupEl.style.cssText = "margin-bottom: 15px;";
      const headerEl = groupEl.createEl("h3", { text: `\u{1F464} ${instructor}` });
      headerEl.style.cssText = "margin: 10px 0 5px 0; font-size: 1.1em; color: var(--text-accent);";
      for (const video of byInstructor[instructor]) {
        const videoEl = groupEl.createEl("div", { cls: "video-item" });
        videoEl.style.cssText = "padding: 10px; margin: 5px 0; border-radius: 5px; background: var(--background-secondary); cursor: pointer; border-left: 3px solid var(--interactive-accent);";
        const titleRow = videoEl.createEl("div", { cls: "title-row" });
        titleRow.style.cssText = "display: flex; justify-content: space-between; align-items: center;";
        titleRow.createEl("strong", { text: video.video_title });
        const citationsBadge = titleRow.createEl("span", { cls: "citations-badge" });
        citationsBadge.style.cssText = "background: var(--interactive-accent); color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em;";
        citationsBadge.textContent = `${video.citations_count} citation${video.citations_count !== 1 ? "s" : ""}`;
        if (video.timestamps && video.timestamps.length > 0) {
          const timestampsEl = videoEl.createEl("div", { cls: "timestamps-preview" });
          timestampsEl.style.cssText = "margin-top: 5px; font-size: 0.85em; color: var(--text-muted);";
          timestampsEl.textContent = `Timestamps: ${video.timestamps.slice(0, 5).join(", ")}${video.timestamps.length > 5 ? "..." : ""}`;
        }
        videoEl.addEventListener("click", async () => {
          videoEl.style.background = "var(--background-modifier-hover)";
          titleRow.createEl("span", { text: " Loading...", cls: "loading-text" });
          try {
            const response = await (0, import_obsidian.requestUrl)({
              url: `${this.plugin.settings.serverUrl}/api/obsidian/explore-video`,
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${this.plugin.settings.apiToken}`
              },
              body: JSON.stringify({
                video_id: video.video_id,
                concept: video.video_title
                // Use video title as fallback
              })
            });
            const data = response.json;
            if (data.error) {
              new import_obsidian.Notice(`Could not load concept cache for this video`, 3e3);
              videoEl.style.background = "var(--background-secondary)";
              const loadingText = videoEl.querySelector(".loading-text");
              if (loadingText)
                loadingText.remove();
              return;
            }
            this.close();
            const modal = new VideoExplorerModal(
              this.app,
              this.plugin,
              data,
              this.sourceFile
            );
            modal.open();
          } catch (error) {
            new import_obsidian.Notice(`Failed to load: ${error.message}`, 3e3);
            videoEl.style.background = "var(--background-secondary)";
            const loadingText = videoEl.querySelector(".loading-text");
            if (loadingText)
              loadingText.remove();
          }
        });
        videoEl.addEventListener("mouseenter", () => {
          videoEl.style.background = "var(--background-modifier-hover)";
        });
        videoEl.addEventListener("mouseleave", () => {
          videoEl.style.background = "var(--background-secondary)";
        });
      }
    }
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 20px; display: flex; gap: 10px;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var CatalogBrowserModal = class extends import_obsidian.Modal {
  constructor(app, plugin, concept, conceptContext, sourceFile) {
    super(app);
    this.selectedVideos = /* @__PURE__ */ new Set();
    this.catalogData = null;
    this.plugin = plugin;
    this.concept = concept;
    this.conceptContext = conceptContext;
    this.sourceFile = sourceFile;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Cross-Reference Research" });
    const conceptEl = contentEl.createEl("div", { cls: "concept-info" });
    conceptEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px; border-left: 3px solid var(--interactive-accent);";
    conceptEl.createEl("p", { text: `Concept: "${this.concept}"` });
    if (this.conceptContext) {
      conceptEl.createEl("p", { text: `Context: ${this.conceptContext}`, cls: "context-text" });
    }
    const loadingEl = contentEl.createEl("div", { cls: "loading", text: "Loading video catalog..." });
    loadingEl.style.cssText = "padding: 20px; text-align: center;";
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.plugin.settings.serverUrl}/api/obsidian/catalog`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.plugin.settings.apiToken}`
        }
      });
      this.catalogData = response.json;
      loadingEl.remove();
      contentEl.createEl("p", {
        text: `Select videos to cross-reference (${this.catalogData.total_videos} available):`,
        cls: "catalog-instructions"
      });
      const selectedCountEl = contentEl.createEl("div", { cls: "selected-count" });
      selectedCountEl.style.cssText = "margin-bottom: 10px; font-weight: bold; color: var(--text-accent);";
      selectedCountEl.textContent = "0 videos selected";
      const searchEl = contentEl.createEl("input", { type: "text", placeholder: "Filter instructors/series..." });
      searchEl.style.cssText = "width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 5px; border: 1px solid var(--background-modifier-border);";
      const listEl = contentEl.createEl("div", { cls: "catalog-list" });
      listEl.style.cssText = "max-height: 350px; overflow-y: auto; border: 1px solid var(--background-modifier-border); border-radius: 5px; padding: 10px;";
      const updateSelectedCount = () => {
        selectedCountEl.textContent = `${this.selectedVideos.size} videos selected`;
      };
      const renderCatalog = (filter = "") => {
        listEl.empty();
        const filterLower = filter.toLowerCase();
        for (const instructor of this.catalogData.instructors) {
          const instructorMatches = instructor.name.toLowerCase().includes(filterLower);
          const matchingSeries = instructor.series.filter(
            (s) => instructorMatches || s.name.toLowerCase().includes(filterLower)
          );
          if (matchingSeries.length === 0 && !instructorMatches)
            continue;
          const groupEl = listEl.createEl("div", { cls: "instructor-group" });
          groupEl.style.cssText = "margin-bottom: 10px;";
          const headerEl = groupEl.createEl("div", { cls: "instructor-header" });
          headerEl.style.cssText = "display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 5px; background: var(--background-secondary); border-radius: 3px;";
          const expandIcon = headerEl.createEl("span", { text: "\u25B6" });
          expandIcon.style.cssText = "font-size: 0.8em; transition: transform 0.2s;";
          const instructorCheckbox = headerEl.createEl("input", { type: "checkbox" });
          instructorCheckbox.style.cssText = "margin-right: 5px;";
          headerEl.createEl("strong", { text: `${instructor.name} (${instructor.video_count})` });
          const seriesContainer = groupEl.createEl("div", { cls: "series-container" });
          seriesContainer.style.cssText = "display: none; margin-left: 20px; margin-top: 5px;";
          headerEl.addEventListener("click", (e) => {
            if (e.target === instructorCheckbox)
              return;
            const isExpanded = seriesContainer.style.display !== "none";
            seriesContainer.style.display = isExpanded ? "none" : "block";
            expandIcon.style.transform = isExpanded ? "" : "rotate(90deg)";
          });
          const seriesToRender = instructorMatches ? instructor.series : matchingSeries;
          for (const series of seriesToRender) {
            const seriesEl = seriesContainer.createEl("div", { cls: "series-item" });
            seriesEl.style.cssText = "margin: 5px 0; padding: 5px; border-left: 2px solid var(--background-modifier-border);";
            const seriesHeader = seriesEl.createEl("div", { cls: "series-header" });
            seriesHeader.style.cssText = "display: flex; align-items: center; gap: 5px;";
            const seriesCheckbox = seriesHeader.createEl("input", { type: "checkbox" });
            seriesHeader.createEl("span", { text: `${series.name} (${series.video_count})` });
            const videosEl = seriesEl.createEl("div", { cls: "videos-list" });
            videosEl.style.cssText = "margin-left: 20px; font-size: 0.9em;";
            const videoCheckboxes = [];
            for (const video of series.videos) {
              const videoEl = videosEl.createEl("div", { cls: "video-item" });
              videoEl.style.cssText = "display: flex; align-items: center; gap: 5px; padding: 2px 0;";
              const videoCheckbox = videoEl.createEl("input", { type: "checkbox" });
              videoCheckbox.dataset.videoId = video.video_id;
              videoCheckboxes.push(videoCheckbox);
              if (this.selectedVideos.has(video.video_id)) {
                videoCheckbox.checked = true;
              }
              videoCheckbox.addEventListener("change", () => {
                if (videoCheckbox.checked) {
                  this.selectedVideos.add(video.video_id);
                } else {
                  this.selectedVideos.delete(video.video_id);
                }
                updateSelectedCount();
              });
              const volText = video.volume ? ` (Vol ${video.volume})` : "";
              videoEl.createEl("span", { text: video.title + volText });
            }
            seriesCheckbox.addEventListener("change", () => {
              for (const cb of videoCheckboxes) {
                cb.checked = seriesCheckbox.checked;
                if (seriesCheckbox.checked) {
                  this.selectedVideos.add(cb.dataset.videoId);
                } else {
                  this.selectedVideos.delete(cb.dataset.videoId);
                }
              }
              updateSelectedCount();
            });
          }
          instructorCheckbox.addEventListener("change", () => {
            const allCheckboxes = seriesContainer.querySelectorAll('input[type="checkbox"]');
            allCheckboxes.forEach((cb) => {
              cb.checked = instructorCheckbox.checked;
              if (cb.dataset.videoId) {
                if (instructorCheckbox.checked) {
                  this.selectedVideos.add(cb.dataset.videoId);
                } else {
                  this.selectedVideos.delete(cb.dataset.videoId);
                }
              }
            });
            updateSelectedCount();
          });
        }
      };
      renderCatalog();
      searchEl.addEventListener("input", () => {
        renderCatalog(searchEl.value);
      });
      const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
      footerEl.style.cssText = "margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;";
      new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Run Cross-Reference").setCta().onClick(async () => {
        if (this.selectedVideos.size === 0) {
          new import_obsidian.Notice("Select at least one video to cross-reference");
          return;
        }
        btn.setButtonText("Researching...");
        btn.setDisabled(true);
        try {
          const response2 = await (0, import_obsidian.requestUrl)({
            url: `${this.plugin.settings.serverUrl}/api/obsidian/cross-reference`,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${this.plugin.settings.apiToken}`
            },
            body: JSON.stringify({
              concept: this.concept,
              concept_context: this.conceptContext,
              video_ids: Array.from(this.selectedVideos)
            })
          });
          const data = response2.json;
          if (data.error) {
            new import_obsidian.Notice(`Error: ${data.error}`);
            btn.setButtonText("Run Cross-Reference");
            btn.setDisabled(false);
            return;
          }
          this.close();
          const resultsModal = new CrossReferenceResultsModal(
            this.app,
            this.plugin,
            data,
            this.sourceFile
          );
          resultsModal.open();
        } catch (error) {
          new import_obsidian.Notice(`Failed: ${error.message}`);
          btn.setButtonText("Run Cross-Reference");
          btn.setDisabled(false);
        }
      })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
    } catch (error) {
      loadingEl.textContent = `Failed to load catalog: ${error.message}`;
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};
var CrossReferenceResultsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, resultsData, sourceFile) {
    super(app);
    this.plugin = plugin;
    this.resultsData = resultsData;
    this.sourceFile = sourceFile;
  }
  onOpen() {
    const { contentEl } = this;
    const { resultsData } = this;
    contentEl.createEl("h2", { text: "\u{1F4CA} Cross-Reference Results" });
    const statsEl = contentEl.createEl("div", { cls: "results-stats" });
    statsEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    statsEl.createEl("p", { text: `Concept: "${resultsData.concept}"` });
    statsEl.createEl("p", { text: `\u{1F4F9} ${resultsData.videos_analyzed} videos analyzed` });
    statsEl.createEl("p", { text: `\u{1F9E0} ${resultsData.thinkers_used} thinker perspectives used` });
    const sourcesEl = contentEl.createEl("div", { cls: "sources-used" });
    sourcesEl.style.cssText = "margin-bottom: 15px;";
    sourcesEl.createEl("h4", { text: "Sources Cross-Referenced:" });
    const sourcesList = sourcesEl.createEl("ul");
    for (const src of resultsData.sources) {
      sourcesList.createEl("li", { text: `${src.instructor} - ${src.video_name}` });
    }
    const researchEl = contentEl.createEl("div", { cls: "research-content" });
    researchEl.style.cssText = "max-height: 400px; overflow-y: auto; padding: 15px; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 5px; white-space: pre-wrap; font-family: var(--font-text);";
    researchEl.textContent = resultsData.research;
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 15px; display: flex; gap: 10px;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Save to Note").setCta().onClick(async () => {
      var _a;
      const fileName = `Cross-Reference - ${resultsData.concept.substring(0, 30)}.md`;
      const folderPath = ((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || this.plugin.settings.syncFolder;
      const filePath = `${folderPath}/${fileName}`;
      const content = `---
type: cross-reference
concept: "${resultsData.concept}"
videos_analyzed: ${resultsData.videos_analyzed}
thinkers_used: ${resultsData.thinkers_used}
date: ${new Date().toISOString().split("T")[0]}
---

# Cross-Reference: ${resultsData.concept}

## Sources Analyzed
${resultsData.sources.map((s) => `- ${s.instructor} - ${s.video_name}`).join("\n")}

## Research

${resultsData.research}
`;
      try {
        await this.app.vault.create(filePath, content);
        new import_obsidian.Notice(`Saved to ${fileName}`);
        this.close();
        const newFile = this.app.vault.getAbstractFileByPath(filePath);
        if (newFile instanceof import_obsidian.TFile) {
          await this.app.workspace.getLeaf().openFile(newFile);
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to save: ${error.message}`);
      }
    })).addButton((btn) => btn.setButtonText("Copy to Clipboard").onClick(async () => {
      await navigator.clipboard.writeText(resultsData.research);
      new import_obsidian.Notice("Copied to clipboard!");
    })).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var EnrichCheckpointModal = class extends import_obsidian.Modal {
  constructor(app, plugin, checkpointData, sourceFile) {
    super(app);
    this.selectedVideos = /* @__PURE__ */ new Set();
    this.catalogData = null;
    this.plugin = plugin;
    this.checkpointData = checkpointData;
    this.sourceFile = sourceFile;
  }
  async onOpen() {
    const { contentEl } = this;
    const { checkpointData } = this;
    contentEl.createEl("h2", { text: "RLM Checkpoint Enrichment" });
    const infoEl = contentEl.createEl("div", { cls: "checkpoint-info" });
    infoEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px; border-left: 3px solid var(--text-accent);";
    infoEl.createEl("h3", { text: checkpointData.name });
    infoEl.createEl("p", { text: `Cluster: ${checkpointData.cluster}` });
    const currentEl = contentEl.createEl("div", { cls: "current-state" });
    currentEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-primary-alt); border-radius: 5px;";
    currentEl.createEl("h4", { text: "Current Knowledge:" });
    const invariablesEl = currentEl.createEl("div");
    invariablesEl.createEl("strong", { text: "Invariables: " });
    invariablesEl.createEl("span", {
      text: checkpointData.currentInvariables.length > 0 ? checkpointData.currentInvariables.join(", ") : "(none)"
    });
    const variablesEl = currentEl.createEl("div");
    variablesEl.createEl("strong", { text: "Variables: " });
    variablesEl.createEl("span", {
      text: checkpointData.currentVariables.length > 0 ? checkpointData.currentVariables.length + " IF/THEN branches" : "(none)"
    });
    const loadingEl = contentEl.createEl("div", { text: "Loading video catalog..." });
    loadingEl.style.cssText = "padding: 20px; text-align: center;";
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.plugin.settings.serverUrl}/api/obsidian/catalog`,
        method: "GET",
        headers: { "Authorization": `Bearer ${this.plugin.settings.apiToken}` }
      });
      this.catalogData = response.json;
      loadingEl.remove();
      contentEl.createEl("p", {
        text: `Select videos to analyze for enrichment (${this.catalogData.total_videos} available):`,
        cls: "enrich-instructions"
      });
      const selectedCountEl = contentEl.createEl("div", { cls: "selected-count" });
      selectedCountEl.style.cssText = "margin-bottom: 10px; font-weight: bold; color: var(--text-accent);";
      selectedCountEl.textContent = "0 videos selected";
      const updateCount = () => {
        selectedCountEl.textContent = `${this.selectedVideos.size} videos selected`;
      };
      const searchEl = contentEl.createEl("input", { type: "text", placeholder: "Filter instructors/series..." });
      searchEl.style.cssText = "width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 5px; border: 1px solid var(--background-modifier-border);";
      const listEl = contentEl.createEl("div", { cls: "catalog-list" });
      listEl.style.cssText = "max-height: 250px; overflow-y: auto; border: 1px solid var(--background-modifier-border); border-radius: 5px; padding: 10px;";
      const renderCatalog = (filter = "") => {
        listEl.empty();
        const filterLower = filter.toLowerCase();
        for (const instructor of this.catalogData.instructors) {
          const instructorMatches = instructor.name.toLowerCase().includes(filterLower);
          const matchingSeries = instructor.series.filter(
            (s) => instructorMatches || s.name.toLowerCase().includes(filterLower)
          );
          if (matchingSeries.length === 0 && !instructorMatches)
            continue;
          const groupEl = listEl.createEl("div", { cls: "instructor-group" });
          groupEl.style.cssText = "margin-bottom: 8px;";
          const headerEl = groupEl.createEl("div", { cls: "instructor-header" });
          headerEl.style.cssText = "display: flex; align-items: center; gap: 5px; cursor: pointer; padding: 3px; background: var(--background-secondary); border-radius: 3px;";
          const expandIcon = headerEl.createEl("span", { text: "\u25B6" });
          expandIcon.style.cssText = "font-size: 0.7em;";
          const instructorCb = headerEl.createEl("input", { type: "checkbox" });
          headerEl.createEl("span", { text: `${instructor.name} (${instructor.video_count})` });
          const seriesContainer = groupEl.createEl("div");
          seriesContainer.style.cssText = "display: none; margin-left: 15px; font-size: 0.9em;";
          headerEl.addEventListener("click", (e) => {
            if (e.target === instructorCb)
              return;
            const isExpanded = seriesContainer.style.display !== "none";
            seriesContainer.style.display = isExpanded ? "none" : "block";
            expandIcon.style.transform = isExpanded ? "" : "rotate(90deg)";
          });
          const allVideoIds = [];
          const seriesToRender = instructorMatches ? instructor.series : matchingSeries;
          for (const series of seriesToRender) {
            const seriesEl = seriesContainer.createEl("div");
            seriesEl.style.cssText = "display: flex; align-items: center; gap: 5px; padding: 2px 0;";
            const seriesCb = seriesEl.createEl("input", { type: "checkbox" });
            seriesEl.createEl("span", { text: `${series.name} (${series.video_count})` });
            const videoIds = series.videos.map((v) => v.video_id);
            allVideoIds.push(...videoIds);
            const allSelected = videoIds.every((id) => this.selectedVideos.has(id));
            seriesCb.checked = allSelected;
            seriesCb.addEventListener("change", () => {
              for (const id of videoIds) {
                if (seriesCb.checked) {
                  this.selectedVideos.add(id);
                } else {
                  this.selectedVideos.delete(id);
                }
              }
              updateCount();
            });
          }
          instructorCb.addEventListener("change", () => {
            const checkboxes = seriesContainer.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach((cb) => cb.checked = instructorCb.checked);
            for (const id of allVideoIds) {
              if (instructorCb.checked) {
                this.selectedVideos.add(id);
              } else {
                this.selectedVideos.delete(id);
              }
            }
            updateCount();
          });
        }
      };
      renderCatalog();
      searchEl.addEventListener("input", () => renderCatalog(searchEl.value));
      const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
      footerEl.style.cssText = "margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;";
      new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Run Enrichment").setCta().onClick(async () => {
        if (this.selectedVideos.size === 0) {
          new import_obsidian.Notice("Select at least one video");
          return;
        }
        btn.setButtonText("Analyzing...");
        btn.setDisabled(true);
        try {
          const response2 = await (0, import_obsidian.requestUrl)({
            url: `${this.plugin.settings.serverUrl}/api/obsidian/enrich-checkpoint`,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${this.plugin.settings.apiToken}`
            },
            body: JSON.stringify({
              checkpoint_name: checkpointData.name,
              checkpoint_cluster: checkpointData.cluster,
              current_invariables: checkpointData.currentInvariables,
              current_variables: checkpointData.currentVariables,
              goal: checkpointData.goal,
              success_test: checkpointData.successTest,
              video_ids: Array.from(this.selectedVideos)
            })
          });
          const enrichments = response2.json;
          if (enrichments.error) {
            new import_obsidian.Notice(`Error: ${enrichments.error}`);
            btn.setButtonText("Run Enrichment");
            btn.setDisabled(false);
            return;
          }
          this.close();
          const resultsModal = new EnrichmentResultsModal(
            this.app,
            this.plugin,
            enrichments,
            this.sourceFile,
            checkpointData
          );
          resultsModal.open();
        } catch (error) {
          new import_obsidian.Notice(`Failed: ${error.message}`);
          btn.setButtonText("Run Enrichment");
          btn.setDisabled(false);
        }
      })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
    } catch (error) {
      loadingEl.textContent = `Failed to load catalog: ${error.message}`;
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};
var EnrichmentResultsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, enrichments, sourceFile, checkpointData) {
    super(app);
    this.acceptedInvariables = /* @__PURE__ */ new Set();
    this.acceptedVariables = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.enrichments = enrichments;
    this.sourceFile = sourceFile;
    this.checkpointData = checkpointData;
  }
  onOpen() {
    const { contentEl } = this;
    const { enrichments } = this;
    contentEl.createEl("h2", { text: "Enrichment Results" });
    const statsEl = contentEl.createEl("div", { cls: "enrichment-stats" });
    statsEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    statsEl.createEl("p", { text: `Checkpoint: ${enrichments.checkpoint_name}` });
    statsEl.createEl("p", { text: `\u{1F4F9} ${enrichments.sources_analyzed} videos analyzed` });
    const scrollEl = contentEl.createEl("div", { cls: "enrichment-scroll" });
    scrollEl.style.cssText = "max-height: 400px; overflow-y: auto;";
    if (enrichments.new_invariables && enrichments.new_invariables.length > 0) {
      const invSection = scrollEl.createEl("div", { cls: "invariables-section" });
      invSection.createEl("h3", { text: `New Invariables (${enrichments.new_invariables.length})` });
      enrichments.new_invariables.forEach((inv, idx) => {
        const itemEl = invSection.createEl("div", { cls: "enrichment-item" });
        itemEl.style.cssText = "padding: 10px; margin: 5px 0; border-radius: 5px; background: var(--background-primary-alt); border-left: 3px solid var(--text-success);";
        const headerRow = itemEl.createEl("div");
        headerRow.style.cssText = "display: flex; align-items: center; gap: 10px;";
        const checkbox = headerRow.createEl("input", { type: "checkbox" });
        checkbox.checked = true;
        this.acceptedInvariables.add(idx);
        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            this.acceptedInvariables.add(idx);
          } else {
            this.acceptedInvariables.delete(idx);
          }
        });
        const tierBadge = headerRow.createEl("span", { cls: "tier-badge" });
        tierBadge.style.cssText = `padding: 2px 6px; border-radius: 3px; font-size: 0.8em; background: ${inv.tier === "CRITICAL" ? "var(--text-error)" : inv.tier === "IMPORTANT" ? "var(--text-warning)" : "var(--text-muted)"}; color: white;`;
        tierBadge.textContent = inv.tier;
        headerRow.createEl("strong", { text: inv.name });
        if (inv.source_instructor) {
          const sourceEl = itemEl.createEl("p");
          sourceEl.style.cssText = "margin: 5px 0; font-size: 0.85em; color: var(--text-accent);";
          sourceEl.textContent = `Source: ${inv.source_instructor}${inv.timestamp ? ` [${inv.timestamp}]` : ""}`;
        }
        if (inv.description) {
          const descEl = itemEl.createEl("p");
          descEl.style.cssText = "margin: 5px 0; font-size: 0.9em; color: var(--text-muted);";
          descEl.textContent = inv.description;
        }
      });
    }
    if (enrichments.new_variables && enrichments.new_variables.length > 0) {
      const varSection = scrollEl.createEl("div", { cls: "variables-section" });
      varSection.style.cssText = "margin-top: 15px;";
      varSection.createEl("h3", { text: `\u{1F500} New Variables (${enrichments.new_variables.length})` });
      enrichments.new_variables.forEach((v, idx) => {
        const itemEl = varSection.createEl("div", { cls: "enrichment-item" });
        itemEl.style.cssText = "padding: 10px; margin: 5px 0; border-radius: 5px; background: var(--background-primary-alt); border-left: 3px solid var(--text-warning);";
        const headerRow = itemEl.createEl("div");
        headerRow.style.cssText = "display: flex; align-items: center; gap: 10px;";
        const checkbox = headerRow.createEl("input", { type: "checkbox" });
        checkbox.checked = true;
        this.acceptedVariables.add(idx);
        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            this.acceptedVariables.add(idx);
          } else {
            this.acceptedVariables.delete(idx);
          }
        });
        headerRow.createEl("strong", { text: `${v.condition} \u2192 ${v.action}` });
        if (v.source_instructor) {
          const sourceEl = itemEl.createEl("p");
          sourceEl.style.cssText = "margin: 5px 0; font-size: 0.85em; color: var(--text-accent);";
          sourceEl.textContent = `Source: ${v.source_instructor}${v.timestamp ? ` [${v.timestamp}]` : ""}`;
        }
        if (v.description) {
          const descEl = itemEl.createEl("p");
          descEl.style.cssText = "margin: 5px 0; font-size: 0.9em; color: var(--text-muted);";
          descEl.textContent = v.description;
        }
      });
    }
    if (enrichments.defensive_inversions && enrichments.defensive_inversions.length > 0) {
      const invSection = scrollEl.createEl("div", { cls: "inversions-section" });
      invSection.style.cssText = "margin-top: 15px;";
      invSection.createEl("h3", { text: `Defensive Inversions (${enrichments.defensive_inversions.length})` });
      for (const inv of enrichments.defensive_inversions) {
        const itemEl = invSection.createEl("div", { cls: "inversion-item" });
        itemEl.style.cssText = "padding: 10px; margin: 5px 0; border-radius: 5px; background: var(--background-primary-alt); border-left: 3px solid var(--interactive-accent);";
        itemEl.createEl("p", { text: `Defender wants: ${inv.defensive_concept}` });
        itemEl.createEl("p", { text: `\u2192 You should: ${inv.offensive_counter}` });
        if (inv.source_instructor) {
          const srcEl = itemEl.createEl("p");
          srcEl.style.cssText = "font-size: 0.85em; color: var(--text-accent);";
          srcEl.textContent = `Source: ${inv.source_instructor}`;
        }
      }
    }
    if (enrichments.key_insights && enrichments.key_insights.length > 0) {
      const insightsSection = scrollEl.createEl("div", { cls: "insights-section" });
      insightsSection.style.cssText = "margin-top: 15px;";
      insightsSection.createEl("h3", { text: `Key Insights` });
      const ul = insightsSection.createEl("ul");
      for (const insight of enrichments.key_insights) {
        ul.createEl("li", { text: insight });
      }
    }
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Apply Selected Enrichments").setCta().onClick(async () => {
      await this.applyEnrichments();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  async applyEnrichments() {
    var _a, _b, _c, _d, _e;
    const { enrichments, sourceFile, checkpointData } = this;
    try {
      let content = await this.app.vault.read(sourceFile);
      const newInvariables = ((_a = enrichments.new_invariables) == null ? void 0 : _a.filter(
        (_, idx) => this.acceptedInvariables.has(idx)
      )) || [];
      const newVariables = ((_b = enrichments.new_variables) == null ? void 0 : _b.filter(
        (_, idx) => this.acceptedVariables.has(idx)
      )) || [];
      if (newInvariables.length === 0 && newVariables.length === 0) {
        new import_obsidian.Notice("No enrichments selected");
        return;
      }
      const createdFiles = [];
      if (newInvariables.length > 0) {
        const tableMatch = content.match(/(## INVARIABLES[\s\S]*?\| REFINEMENT \|[^\n]*)/);
        if (tableMatch) {
          let newRows = "";
          for (const inv of newInvariables) {
            const safeName = inv.name.replace(/[\\/:*?"<>|]/g, "-").substring(0, 60);
            const conceptPath = `${(_c = sourceFile.parent) == null ? void 0 : _c.path}/${safeName}.md`;
            const conceptContent = `---
type: method
method_type: invariable
cluster: "${checkpointData.cluster}"
tier: "${inv.tier}"
source_instructor: "${inv.source_instructor || "Unknown"}"
video_id: "${inv.video_id || ""}"
timestamp: "${inv.timestamp || ""}"
clip_duration: 30
enrichment_source: true
---

# ${inv.name}

${inv.description || ""}

## Clip Info
- **Instructor:** ${inv.source_instructor || "Unknown"}
- **Timestamp:** ${inv.timestamp || "N/A"}
- **Video ID:** ${inv.video_id || "N/A"}
`;
            const existingFile = this.app.vault.getAbstractFileByPath(conceptPath);
            if (!existingFile) {
              const newFile = await this.app.vault.create(conceptPath, conceptContent);
              createdFiles.push(newFile);
            }
            const linkText = `[[${safeName}]]`;
            newRows += `| ${inv.tier} | ${linkText} |
`;
          }
          const refinementMatch = content.match(/(\| REFINEMENT \|[^\n]*\n)/);
          if (refinementMatch) {
            content = content.replace(refinementMatch[1], newRows + refinementMatch[1]);
          }
        }
      }
      if (newVariables.length > 0) {
        const variablesMatch = content.match(/(## VARIABLES \(IF\/THEN\)\n\n)([\s\S]*?)(\n---)/);
        if (variablesMatch) {
          let newVarText = "";
          for (const v of newVariables) {
            const safeName = v.condition.replace(/^IF\s*/i, "").replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
            const varPath = `${(_d = sourceFile.parent) == null ? void 0 : _d.path}/VAR - ${safeName}.md`;
            const varContent = `---
type: method
method_type: variable
cluster: "${checkpointData.cluster}"
condition: "${v.condition}"
action: "${v.action}"
source_instructor: "${v.source_instructor || "Unknown"}"
video_id: "${v.video_id || ""}"
timestamp: "${v.timestamp || ""}"
clip_duration: 30
enrichment_source: true
---

# ${v.condition}

**Action:** ${v.action}

${v.description || ""}

## Clip Info
- **Instructor:** ${v.source_instructor || "Unknown"}
- **Timestamp:** ${v.timestamp || "N/A"}
- **Video ID:** ${v.video_id || "N/A"}
`;
            const existingVarFile = this.app.vault.getAbstractFileByPath(varPath);
            if (!existingVarFile) {
              const newVarFile = await this.app.vault.create(varPath, varContent);
              createdFiles.push(newVarFile);
            }
            newVarText += `- **${v.condition}** \u2192 ${v.action} \u2192 [[VAR - ${safeName}]]
`;
          }
          content = content.replace(
            variablesMatch[0],
            variablesMatch[1] + variablesMatch[2] + newVarText + variablesMatch[3]
          );
        }
      }
      const enrichmentDate = new Date().toISOString().split("T")[0];
      if (content.includes("---\n")) {
        const parts = content.split("---");
        if (parts.length >= 2) {
          parts[1] = parts[1].replace(/\nlast_enriched:.*$/gm, "").replace(/\nenrichment_sources:.*$/gm, "").trimEnd();
          parts[1] += `
last_enriched: ${enrichmentDate}
enrichment_sources: ${enrichments.sources_analyzed} videos
`;
          content = parts.join("---");
        }
      }
      await this.app.vault.modify(sourceFile, content);
      const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
      if (canvasLeaves.length > 0 && createdFiles.length > 0) {
        const canvasView = canvasLeaves[0].view;
        const canvas = canvasView == null ? void 0 : canvasView.canvas;
        if (canvas) {
          let checkpointNode = null;
          let checkpointX = 0;
          let checkpointY = 0;
          for (const node of canvas.nodes.values()) {
            if (((_e = node.file) == null ? void 0 : _e.path) === sourceFile.path) {
              checkpointNode = node;
              checkpointX = node.x;
              checkpointY = node.y;
              break;
            }
          }
          const nodeWidth = 250;
          const nodeHeight = 100;
          const spacing = 50;
          const startX = checkpointX + 350;
          let currentY = checkpointY - (createdFiles.length - 1) * (nodeHeight + spacing) / 2;
          for (const file of createdFiles) {
            const nodeData = {
              id: `enrichment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
              type: "file",
              file: file.path,
              x: startX,
              y: currentY,
              width: nodeWidth,
              height: nodeHeight
            };
            canvas.createFileNode({
              file,
              pos: { x: startX, y: currentY },
              size: { width: nodeWidth, height: nodeHeight }
            });
            currentY += nodeHeight + spacing;
          }
          canvas.requestSave();
          new import_obsidian.Notice(`Added ${createdFiles.length} nodes to Canvas`);
        }
      }
      new import_obsidian.Notice(`Applied ${newInvariables.length} invariables and ${newVariables.length} variables`);
      this.close();
      const leaf = this.app.workspace.getLeaf();
      await leaf.openFile(sourceFile);
    } catch (error) {
      new import_obsidian.Notice(`Failed to apply enrichments: ${error.message}`);
      console.error("Apply enrichments error:", error);
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};
var RLMPipelineModal = class extends import_obsidian.Modal {
  constructor(app, plugin, canvasFile, folder, checkpointFiles) {
    super(app);
    this.selectedVideos = /* @__PURE__ */ new Set();
    this.catalogData = null;
    this.plugin = plugin;
    this.canvasFile = canvasFile;
    this.folder = folder;
    this.checkpointFiles = checkpointFiles;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "RLM Pipeline: Enrich & Rebuild" });
    const stepsEl = contentEl.createEl("div", { cls: "pipeline-steps" });
    stepsEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    stepsEl.createEl("p", { text: "This will:", cls: "steps-header" });
    const stepsList = stepsEl.createEl("ol");
    stepsList.style.cssText = "margin: 5px 0; padding-left: 25px; font-size: 0.9em;";
    stepsList.createEl("li", { text: "Backup current canvas (version control)" });
    stepsList.createEl("li", { text: "Enrich all checkpoints with selected videos" });
    stepsList.createEl("li", { text: "Rebuild canvas with proper layout & connections" });
    const infoEl = contentEl.createEl("div", { cls: "checkpoint-info" });
    infoEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-primary-alt); border-radius: 5px;";
    infoEl.createEl("p", { text: `Found ${this.checkpointFiles.length} checkpoints in ${this.folder.name}:` });
    const checkpointList = infoEl.createEl("ul");
    checkpointList.style.cssText = "margin: 5px 0; padding-left: 20px; font-size: 0.9em; max-height: 100px; overflow-y: auto;";
    for (const file of this.checkpointFiles) {
      checkpointList.createEl("li", { text: file.basename });
    }
    const loadingEl = contentEl.createEl("div", { text: "Loading video catalog..." });
    loadingEl.style.cssText = "padding: 20px; text-align: center;";
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.plugin.settings.serverUrl}/api/obsidian/catalog`,
        method: "GET",
        headers: { "Authorization": `Bearer ${this.plugin.settings.apiToken}` }
      });
      this.catalogData = response.json;
      loadingEl.remove();
      contentEl.createEl("p", {
        text: `Select videos to cross-reference ALL checkpoints (${this.catalogData.total_videos} available):`
      });
      const selectedCountEl = contentEl.createEl("div", { cls: "selected-count" });
      selectedCountEl.style.cssText = "margin-bottom: 10px; font-weight: bold; color: var(--text-accent);";
      selectedCountEl.textContent = "0 videos selected";
      const updateCount = () => {
        selectedCountEl.textContent = `${this.selectedVideos.size} videos selected`;
      };
      const searchEl = contentEl.createEl("input", { type: "text", placeholder: "Filter instructors/series..." });
      searchEl.style.cssText = "width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 5px; border: 1px solid var(--background-modifier-border);";
      const listEl = contentEl.createEl("div", { cls: "catalog-list" });
      listEl.style.cssText = "max-height: 200px; overflow-y: auto; border: 1px solid var(--background-modifier-border); border-radius: 5px; padding: 10px;";
      const renderCatalog = (filter = "") => {
        listEl.empty();
        const filterLower = filter.toLowerCase();
        for (const instructor of this.catalogData.instructors) {
          const instructorMatches = instructor.name.toLowerCase().includes(filterLower);
          const matchingSeries = instructor.series.filter(
            (s) => instructorMatches || s.name.toLowerCase().includes(filterLower)
          );
          if (matchingSeries.length === 0 && !instructorMatches)
            continue;
          const groupEl = listEl.createEl("div", { cls: "instructor-group" });
          groupEl.style.cssText = "margin-bottom: 8px;";
          const headerEl = groupEl.createEl("div", { cls: "instructor-header" });
          headerEl.style.cssText = "display: flex; align-items: center; gap: 5px; cursor: pointer; padding: 3px; background: var(--background-secondary); border-radius: 3px;";
          const expandIcon = headerEl.createEl("span", { text: ">" });
          expandIcon.style.cssText = "font-size: 0.8em; width: 12px;";
          const instructorCb = headerEl.createEl("input", { type: "checkbox" });
          headerEl.createEl("span", { text: `${instructor.name} (${instructor.video_count})` });
          const seriesContainer = groupEl.createEl("div");
          seriesContainer.style.cssText = "display: none; margin-left: 20px; font-size: 0.9em;";
          headerEl.addEventListener("click", (e) => {
            if (e.target === instructorCb)
              return;
            const isExpanded = seriesContainer.style.display !== "none";
            seriesContainer.style.display = isExpanded ? "none" : "block";
            expandIcon.textContent = isExpanded ? ">" : "v";
          });
          const allVideoIds = [];
          const seriesToRender = instructorMatches ? instructor.series : matchingSeries;
          for (const series of seriesToRender) {
            const seriesEl = seriesContainer.createEl("div");
            seriesEl.style.cssText = "display: flex; align-items: center; gap: 5px; padding: 2px 0;";
            const seriesCb = seriesEl.createEl("input", { type: "checkbox" });
            seriesEl.createEl("span", { text: `${series.name} (${series.video_count})` });
            const videoIds = series.videos.map((v) => v.video_id);
            allVideoIds.push(...videoIds);
            const allSelected = videoIds.every((id) => this.selectedVideos.has(id));
            seriesCb.checked = allSelected;
            seriesCb.addEventListener("change", () => {
              for (const id of videoIds) {
                if (seriesCb.checked) {
                  this.selectedVideos.add(id);
                } else {
                  this.selectedVideos.delete(id);
                }
              }
              updateCount();
            });
          }
          instructorCb.addEventListener("change", () => {
            const checkboxes = seriesContainer.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach((cb) => cb.checked = instructorCb.checked);
            for (const id of allVideoIds) {
              if (instructorCb.checked) {
                this.selectedVideos.add(id);
              } else {
                this.selectedVideos.delete(id);
              }
            }
            updateCount();
          });
        }
      };
      renderCatalog();
      searchEl.addEventListener("input", () => renderCatalog(searchEl.value));
      const progressEl = contentEl.createEl("div", { cls: "progress-area" });
      progressEl.style.cssText = "display: none; margin-top: 15px; padding: 10px; background: var(--background-primary-alt); border-radius: 5px;";
      const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
      footerEl.style.cssText = "margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;";
      new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Run RLM Pipeline").setCta().onClick(async () => {
        var _a, _b, _c;
        if (this.selectedVideos.size === 0) {
          new import_obsidian.Notice("Select at least one video");
          return;
        }
        btn.setButtonText("Running Pipeline...");
        btn.setDisabled(true);
        progressEl.style.display = "block";
        progressEl.empty();
        progressEl.createEl("h4", { text: "Step 1: Backing up canvas..." });
        const backupName = `${this.canvasFile.basename}_backup_${Date.now()}.canvas`;
        const backupPath = `${this.folder.path}/${backupName}`;
        try {
          const canvasContent = await this.app.vault.read(this.canvasFile);
          await this.app.vault.create(backupPath, canvasContent);
          progressEl.createEl("p", { text: `Backup saved: ${backupName}` });
        } catch (e) {
          progressEl.createEl("p", { text: "Backup failed, continuing..." });
        }
        progressEl.createEl("h4", { text: "Step 2: Enriching checkpoints..." });
        const videoIds = Array.from(this.selectedVideos);
        let successCount = 0;
        let totalNewConcepts = 0;
        for (let i = 0; i < this.checkpointFiles.length; i++) {
          const file = this.checkpointFiles[i];
          const checkpointName = file.basename;
          const statusEl = progressEl.createEl("div");
          statusEl.textContent = `[${i + 1}/${this.checkpointFiles.length}] ${checkpointName}...`;
          try {
            const content = await this.app.vault.read(file);
            const cache = this.app.metadataCache.getFileCache(file);
            const invariablesMatch = content.match(/## INVARIABLES[\s\S]*?\|[\s\S]*?\|([\s\S]*?)(?=\n---|\n##|$)/);
            const currentInvariables = [];
            if (invariablesMatch) {
              const links = invariablesMatch[1].match(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g) || [];
              for (const link of links) {
                const nameMatch = link.match(/\[\[(?:[^\]|]+\|)?([^\]]+)\]\]/);
                if (nameMatch && nameMatch[1] !== "none") {
                  currentInvariables.push(nameMatch[1].trim());
                }
              }
            }
            const variablesMatch = content.match(/## VARIABLES[\s\S]*?((?:- \*\*IF.*\n?)+)/);
            const currentVariables = [];
            if (variablesMatch) {
              const lines = variablesMatch[1].match(/- \*\*IF[^*]+\*\*[^\n]+/g) || [];
              currentVariables.push(...lines.map((l) => l.replace(/^- /, "").trim()));
            }
            const goalMatch = content.match(/## Goal\n\n([^\n]+)/);
            const goal = goalMatch ? goalMatch[1].trim() : "";
            const successMatch = content.match(/## Success Test\n\n> ([^\n]+)/);
            const successTest = successMatch ? successMatch[1].trim() : "";
            const response2 = await (0, import_obsidian.requestUrl)({
              url: `${this.plugin.settings.serverUrl}/api/obsidian/enrich-checkpoint`,
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${this.plugin.settings.apiToken}`
              },
              body: JSON.stringify({
                checkpoint_name: checkpointName,
                checkpoint_cluster: ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.cluster) || "",
                current_invariables: currentInvariables,
                current_variables: currentVariables,
                goal,
                success_test: successTest,
                video_ids: videoIds
              }),
              throw: false
            });
            if (response2.status === 200) {
              const enrichments = response2.json;
              const newCount = (((_b = enrichments.new_invariables) == null ? void 0 : _b.length) || 0) + (((_c = enrichments.new_variables) == null ? void 0 : _c.length) || 0);
              totalNewConcepts += newCount;
              if (newCount > 0) {
                await this.applyEnrichmentsToCheckpoint(file, enrichments);
              }
              statusEl.textContent = `[${i + 1}/${this.checkpointFiles.length}] ${checkpointName} - ${newCount} new concepts`;
              statusEl.style.color = "var(--text-success)";
              successCount++;
            } else {
              statusEl.textContent = `[${i + 1}/${this.checkpointFiles.length}] ${checkpointName} - Failed`;
              statusEl.style.color = "var(--text-error)";
            }
          } catch (error) {
            statusEl.textContent = `[${i + 1}/${this.checkpointFiles.length}] ${checkpointName} - Error: ${error.message}`;
            statusEl.style.color = "var(--text-error)";
          }
        }
        progressEl.createEl("hr");
        progressEl.createEl("h4", { text: "Step 3: Rebuilding canvas..." });
        const rebuildStatus = progressEl.createEl("div");
        rebuildStatus.textContent = "Scanning checkpoint files and linked concepts...";
        try {
          const newCanvasPath = await this.rebuildCanvasForFolder(this.folder, this.canvasFile.basename);
          rebuildStatus.textContent = `Canvas rebuilt: ${newCanvasPath}`;
          rebuildStatus.style.color = "var(--text-success)";
        } catch (err) {
          rebuildStatus.textContent = `Canvas rebuild failed: ${err.message}`;
          rebuildStatus.style.color = "var(--text-error)";
        }
        progressEl.createEl("hr");
        progressEl.createEl("p", {
          text: `Complete: ${successCount}/${this.checkpointFiles.length} checkpoints enriched, ${totalNewConcepts} new concepts added`
        });
        btn.setButtonText("Done");
        btn.setDisabled(false);
        btn.buttonEl.onclick = () => this.close();
        new import_obsidian.Notice(`RLM Pipeline complete: ${totalNewConcepts} new concepts, canvas rebuilt`);
      })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
    } catch (error) {
      loadingEl.textContent = `Error loading catalog: ${error.message}`;
    }
  }
  async applyEnrichmentsToCheckpoint(file, enrichments) {
    var _a, _b, _c, _d, _e;
    const cache = this.app.metadataCache.getFileCache(file);
    const cluster = ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.cluster) || "";
    let content = await this.app.vault.read(file);
    if (((_b = enrichments.new_invariables) == null ? void 0 : _b.length) > 0) {
      const tableMatch = content.match(/(## INVARIABLES[\s\S]*?\| REFINEMENT \|[^\n]*)/);
      if (tableMatch) {
        let newRows = "";
        for (const inv of enrichments.new_invariables) {
          const safeName = inv.name.replace(/[\\/:*?"<>|]/g, "-").substring(0, 60);
          const conceptPath = `${(_c = file.parent) == null ? void 0 : _c.path}/${safeName}.md`;
          const conceptContent = `---
type: method
method_type: invariable
cluster: "${cluster}"
tier: "${inv.tier}"
source_instructor: "${inv.source_instructor || "Unknown"}"
video_id: "${inv.video_id || ""}"
timestamp: "${inv.timestamp || ""}"
clip_duration: 30
enrichment_source: true
---

# ${inv.name}

${inv.description || ""}

## Clip Info
- **Instructor:** ${inv.source_instructor || "Unknown"}
- **Timestamp:** ${inv.timestamp || "N/A"}
- **Video ID:** ${inv.video_id || "N/A"}
`;
          const existingFile = this.app.vault.getAbstractFileByPath(conceptPath);
          if (!existingFile) {
            await this.app.vault.create(conceptPath, conceptContent);
          }
          const linkText = `[[${safeName}]]`;
          newRows += `| ${inv.tier} | ${linkText} |
`;
        }
        const refinementMatch = content.match(/(\| REFINEMENT \|[^\n]*\n)/);
        if (refinementMatch) {
          content = content.replace(refinementMatch[1], newRows + refinementMatch[1]);
        }
      }
    }
    if (((_d = enrichments.new_variables) == null ? void 0 : _d.length) > 0) {
      const variablesMatch = content.match(/(## VARIABLES \(IF\/THEN\)\n\n)([\s\S]*?)(\n---)/);
      if (variablesMatch) {
        let newVarText = "";
        for (const v of enrichments.new_variables) {
          const safeName = v.condition.replace(/^IF\s*/i, "").replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
          const varPath = `${(_e = file.parent) == null ? void 0 : _e.path}/VAR - ${safeName}.md`;
          const varContent = `---
type: method
method_type: variable
cluster: "${cluster}"
condition: "${v.condition}"
action: "${v.action}"
source_instructor: "${v.source_instructor || "Unknown"}"
video_id: "${v.video_id || ""}"
timestamp: "${v.timestamp || ""}"
clip_duration: 30
enrichment_source: true
---

# ${v.condition}

**Action:** ${v.action}

${v.description || ""}

## Clip Info
- **Instructor:** ${v.source_instructor || "Unknown"}
- **Timestamp:** ${v.timestamp || "N/A"}
- **Video ID:** ${v.video_id || "N/A"}
`;
          const existingVarFile = this.app.vault.getAbstractFileByPath(varPath);
          if (!existingVarFile) {
            await this.app.vault.create(varPath, varContent);
          }
          newVarText += `- **${v.condition}** \u2192 ${v.action} \u2192 [[VAR - ${safeName}]]
`;
        }
        content = content.replace(
          variablesMatch[0],
          variablesMatch[1] + variablesMatch[2] + newVarText + variablesMatch[3]
        );
      }
    }
    const enrichmentDate = new Date().toISOString().split("T")[0];
    if (content.includes("---\n")) {
      const parts = content.split("---");
      if (parts.length >= 2) {
        parts[1] = parts[1].replace(/\nlast_enriched:.*$/gm, "").replace(/\nenrichment_sources:.*$/gm, "").trimEnd();
        parts[1] += `
last_enriched: ${enrichmentDate}
enrichment_sources: ${enrichments.sources_analyzed} videos
`;
        content = parts.join("---");
      }
    }
    await this.app.vault.modify(file, content);
  }
  /**
   * Rebuild canvas from checkpoints in a folder.
   * Creates a new canvas with proper layout and connections.
   */
  async rebuildCanvasForFolder(folder, canvasBasename) {
    var _a, _b;
    const checkpoints = [];
    const methods = [];
    for (const file of this.app.vault.getFiles()) {
      if (file.extension !== "md")
        continue;
      if (((_a = file.parent) == null ? void 0 : _a.path) !== folder.path)
        continue;
      const cache = this.app.metadataCache.getFileCache(file);
      const frontmatter = cache == null ? void 0 : cache.frontmatter;
      if ((frontmatter == null ? void 0 : frontmatter.type) === "checkpoint") {
        const content = await this.app.vault.read(file);
        const order = (frontmatter == null ? void 0 : frontmatter.order) || parseInt(((_b = file.basename.match(/\[(\d+)\]/)) == null ? void 0 : _b[1]) || "99");
        const invariables = [];
        const invMatch = content.match(/## INVARIABLES[\s\S]*?\|([\s\S]*?)(?=\n##|\n---)/);
        if (invMatch) {
          const links = invMatch[1].match(/\[\[([^\]|]+)/g) || [];
          for (const link of links) {
            const name = link.replace("[[", "").trim();
            if (name && name !== "none") {
              invariables.push(name);
            }
          }
        }
        const variables = [];
        const varMatch = content.match(/## VARIABLES[\s\S]*?((?:- \*\*IF[\s\S]*?)+)(?=\n---|\n##|$)/);
        if (varMatch) {
          const varLinks = varMatch[1].match(/\[\[([^\]|]+)/g) || [];
          for (const link of varLinks) {
            const name = link.replace("[[", "").trim();
            if (name && name.startsWith("VAR -")) {
              variables.push(name);
            }
          }
        }
        const navigation = [];
        const navMatch = content.match(/## Navigation[\s\S]*?((?:\[\[[^\]]+\]\][^\n]*\n?)+)/);
        if (navMatch) {
          const navLinks = navMatch[1].match(/\[\[([^\]|]+)/g) || [];
          for (const link of navLinks) {
            navigation.push(link.replace("[[", "").trim());
          }
        }
        checkpoints.push({
          file,
          order,
          cluster: (frontmatter == null ? void 0 : frontmatter.cluster) || "",
          invariables,
          variables,
          navigation
        });
      } else if ((frontmatter == null ? void 0 : frontmatter.type) === "method" || (frontmatter == null ? void 0 : frontmatter.type) === "concept" || (frontmatter == null ? void 0 : frontmatter.method_type)) {
        methods.push({
          file,
          tier: (frontmatter == null ? void 0 : frontmatter.tier) || (frontmatter == null ? void 0 : frontmatter.method_type) || "REFINEMENT",
          cluster: (frontmatter == null ? void 0 : frontmatter.cluster) || ""
        });
      }
    }
    if (checkpoints.length === 0) {
      throw new Error("No checkpoint files found");
    }
    checkpoints.sort((a, b) => a.order - b.order);
    const canvasData = { nodes: [], edges: [] };
    const checkpointWidth = 300;
    const checkpointHeight = 150;
    const methodWidth = 200;
    const methodHeight = 80;
    const horizontalGap = 400;
    const methodOffsetX = 350;
    const methodGap = 100;
    let currentX = 100;
    const checkpointY = 300;
    const nodeIdMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < checkpoints.length; i++) {
      const cp = checkpoints[i];
      const nodeId = `checkpoint-${i}`;
      nodeIdMap.set(cp.file.basename, nodeId);
      canvasData.nodes.push({
        id: nodeId,
        type: "file",
        file: cp.file.path,
        x: currentX,
        y: checkpointY,
        width: checkpointWidth,
        height: checkpointHeight,
        color: "4"
      });
      let methodY = checkpointY - methodGap - methodHeight;
      for (const invName of cp.invariables) {
        const methodFile = methods.find((m) => m.file.basename === invName);
        if (methodFile) {
          const methodId = `method-${nodeIdMap.size}`;
          nodeIdMap.set(invName, methodId);
          let color = "0";
          if (methodFile.tier === "CRITICAL")
            color = "1";
          else if (methodFile.tier === "IMPORTANT")
            color = "6";
          else if (methodFile.tier === "invariable")
            color = "5";
          canvasData.nodes.push({
            id: methodId,
            type: "file",
            file: methodFile.file.path,
            x: currentX + methodOffsetX,
            y: methodY,
            width: methodWidth,
            height: methodHeight,
            color
          });
          canvasData.edges.push({
            id: `edge-${canvasData.edges.length}`,
            fromNode: nodeId,
            fromSide: "right",
            toNode: methodId,
            toSide: "left"
          });
          methodY -= methodHeight + 30;
        }
      }
      if (i < checkpoints.length - 1) {
        canvasData.edges.push({
          id: `edge-cp-${i}`,
          fromNode: nodeId,
          fromSide: "right",
          toNode: `checkpoint-${i + 1}`,
          toSide: "left",
          color: "5"
        });
      }
      currentX += horizontalGap;
    }
    for (const cp of checkpoints) {
      const fromId = nodeIdMap.get(cp.file.basename);
      for (const navTarget of cp.navigation) {
        const toId = nodeIdMap.get(navTarget);
        if (fromId && toId && fromId !== toId) {
          const exists = canvasData.edges.some(
            (e) => e.fromNode === fromId && e.toNode === toId
          );
          if (!exists) {
            canvasData.edges.push({
              id: `edge-nav-${canvasData.edges.length}`,
              fromNode: fromId,
              fromSide: "bottom",
              toNode: toId,
              toSide: "top",
              color: "3"
            });
          }
        }
      }
    }
    const canvasPath = `${folder.path}/${canvasBasename} - RLM.canvas`;
    const canvasContent = JSON.stringify(canvasData, null, 2);
    const existingCanvas = this.app.vault.getAbstractFileByPath(canvasPath);
    if (existingCanvas) {
      await this.app.vault.modify(existingCanvas, canvasContent);
    } else {
      await this.app.vault.create(canvasPath, canvasContent);
    }
    const varCanvasData = { nodes: [], edges: [] };
    const varNodeIdMap = /* @__PURE__ */ new Map();
    let varCurrentX = 100;
    const varCheckpointY = 100;
    for (let i = 0; i < checkpoints.length; i++) {
      const cp = checkpoints[i];
      const nodeId = `checkpoint-${i}`;
      varNodeIdMap.set(cp.file.basename, nodeId);
      varCanvasData.nodes.push({
        id: nodeId,
        type: "file",
        file: cp.file.path,
        x: varCurrentX,
        y: varCheckpointY,
        width: checkpointWidth,
        height: checkpointHeight,
        color: "4"
      });
      let varY = varCheckpointY + checkpointHeight + methodGap;
      for (const varName of cp.variables) {
        const varFile = methods.find((m) => m.file.basename === varName);
        if (varFile) {
          const varId = `var-${varNodeIdMap.size}`;
          varNodeIdMap.set(varName, varId);
          varCanvasData.nodes.push({
            id: varId,
            type: "file",
            file: varFile.file.path,
            x: varCurrentX + methodOffsetX,
            y: varY,
            width: methodWidth + 50,
            height: methodHeight,
            color: "2"
            // Green for variables
          });
          varCanvasData.edges.push({
            id: `edge-${varCanvasData.edges.length}`,
            fromNode: nodeId,
            fromSide: "bottom",
            toNode: varId,
            toSide: "top"
          });
          varY += methodHeight + 30;
        }
      }
      if (i < checkpoints.length - 1) {
        varCanvasData.edges.push({
          id: `edge-cp-${i}`,
          fromNode: nodeId,
          fromSide: "right",
          toNode: `checkpoint-${i + 1}`,
          toSide: "left",
          color: "5"
        });
      }
      varCurrentX += horizontalGap;
    }
    const varCanvasPath = `${folder.path}/${canvasBasename} - Variables.canvas`;
    const varCanvasContent = JSON.stringify(varCanvasData, null, 2);
    const existingVarCanvas = this.app.vault.getAbstractFileByPath(varCanvasPath);
    if (existingVarCanvas) {
      await this.app.vault.modify(existingVarCanvas, varCanvasContent);
    } else {
      await this.app.vault.create(varCanvasPath, varCanvasContent);
    }
    const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
    if (canvasFile) {
      await this.app.workspace.getLeaf().openFile(canvasFile);
    }
    return canvasPath;
  }
  /**
   * Generate only the Variables canvas (without running full enrichment).
   */
  async generateVariablesCanvasOnly(folder, canvasBasename) {
    var _a, _b;
    const checkpoints = [];
    const methods = [];
    for (const file of this.app.vault.getFiles()) {
      if (file.extension !== "md")
        continue;
      if (((_a = file.parent) == null ? void 0 : _a.path) !== folder.path)
        continue;
      const cache = this.app.metadataCache.getFileCache(file);
      const frontmatter = cache == null ? void 0 : cache.frontmatter;
      if ((frontmatter == null ? void 0 : frontmatter.type) === "checkpoint") {
        const content = await this.app.vault.read(file);
        const order = (frontmatter == null ? void 0 : frontmatter.order) || parseInt(((_b = file.basename.match(/\[(\d+)\]/)) == null ? void 0 : _b[1]) || "99");
        const variables = [];
        const varMatch = content.match(/## VARIABLES[\s\S]*?((?:- \*\*IF[\s\S]*?)+)(?=\n---|\n##|$)/);
        if (varMatch) {
          const varLinks = varMatch[1].match(/\[\[([^\]|]+)/g) || [];
          for (const link of varLinks) {
            const name = link.replace("[[", "").trim();
            if (name && name.startsWith("VAR -")) {
              variables.push(name);
            }
          }
        }
        checkpoints.push({ file, order, variables });
      } else if ((frontmatter == null ? void 0 : frontmatter.type) === "method" || (frontmatter == null ? void 0 : frontmatter.method_type)) {
        methods.push({
          file,
          tier: (frontmatter == null ? void 0 : frontmatter.tier) || (frontmatter == null ? void 0 : frontmatter.method_type) || "REFINEMENT"
        });
      }
    }
    if (checkpoints.length === 0) {
      throw new Error("No checkpoint files found");
    }
    checkpoints.sort((a, b) => a.order - b.order);
    const canvasData = { nodes: [], edges: [] };
    const checkpointWidth = 300;
    const checkpointHeight = 150;
    const methodWidth = 250;
    const methodHeight = 80;
    const horizontalGap = 400;
    const methodGap = 100;
    const methodOffsetX = 350;
    let currentX = 100;
    const checkpointY = 100;
    const nodeIdMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < checkpoints.length; i++) {
      const cp = checkpoints[i];
      const nodeId = `checkpoint-${i}`;
      nodeIdMap.set(cp.file.basename, nodeId);
      canvasData.nodes.push({
        id: nodeId,
        type: "file",
        file: cp.file.path,
        x: currentX,
        y: checkpointY,
        width: checkpointWidth,
        height: checkpointHeight,
        color: "4"
      });
      let varY = checkpointY + checkpointHeight + methodGap;
      for (const varName of cp.variables) {
        const varFile = methods.find((m) => m.file.basename === varName);
        if (varFile) {
          const varId = `var-${nodeIdMap.size}`;
          nodeIdMap.set(varName, varId);
          canvasData.nodes.push({
            id: varId,
            type: "file",
            file: varFile.file.path,
            x: currentX + methodOffsetX,
            y: varY,
            width: methodWidth,
            height: methodHeight,
            color: "2"
          });
          canvasData.edges.push({
            id: `edge-${canvasData.edges.length}`,
            fromNode: nodeId,
            fromSide: "bottom",
            toNode: varId,
            toSide: "top"
          });
          varY += methodHeight + 30;
        }
      }
      if (i < checkpoints.length - 1) {
        canvasData.edges.push({
          id: `edge-cp-${i}`,
          fromNode: nodeId,
          fromSide: "right",
          toNode: `checkpoint-${i + 1}`,
          toSide: "left",
          color: "5"
        });
      }
      currentX += horizontalGap;
    }
    const canvasPath = `${folder.path}/${canvasBasename} - Variables.canvas`;
    const canvasContent = JSON.stringify(canvasData, null, 2);
    const existingCanvas = this.app.vault.getAbstractFileByPath(canvasPath);
    if (existingCanvas) {
      await this.app.vault.modify(existingCanvas, canvasContent);
    } else {
      await this.app.vault.create(canvasPath, canvasContent);
    }
    return canvasPath;
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ClipBrowserModal = class extends import_obsidian.Modal {
  constructor(app, plugin, sourceFile, clipData) {
    super(app);
    this.plugin = plugin;
    this.sourceFile = sourceFile;
    this.clipData = clipData;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    const { clipData, sourceFile } = this;
    contentEl.createEl("h2", { text: `Clip Options: ${sourceFile.basename}` });
    const infoEl = contentEl.createEl("div", { cls: "clip-info" });
    infoEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    infoEl.createEl("p", { text: `Video: ${clipData.video_name || clipData.video_id}` });
    infoEl.createEl("p", { text: `Instructor: ${clipData.instructor || "Unknown"}` });
    infoEl.createEl("p", { text: `Found ${((_a = clipData.clips) == null ? void 0 : _a.length) || 0} relevant sections` });
    if (!clipData.clips || clipData.clips.length === 0) {
      contentEl.createEl("p", { text: "No clip options found for this concept." });
      return;
    }
    const listEl = contentEl.createEl("div", { cls: "clip-list" });
    listEl.style.cssText = "max-height: 400px; overflow-y: auto;";
    for (const clip of clipData.clips) {
      const clipEl = listEl.createEl("div", { cls: "clip-option" });
      clipEl.style.cssText = "margin-bottom: 15px; padding: 12px; background: var(--background-primary-alt); border-radius: 5px; border-left: 3px solid var(--text-accent);";
      const headerEl = clipEl.createEl("div", { cls: "clip-header" });
      headerEl.style.cssText = "display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;";
      const timestampEl = headerEl.createEl("span", { cls: "clip-timestamp" });
      timestampEl.style.cssText = "font-weight: bold; font-size: 1.1em; color: var(--text-accent);";
      timestampEl.textContent = clip.timestamp || "Unknown";
      const durationEl = headerEl.createEl("span", { cls: "clip-duration" });
      durationEl.style.cssText = "font-size: 0.9em; color: var(--text-muted);";
      durationEl.textContent = `${clip.duration || 30}s`;
      const summaryEl = clipEl.createEl("div", { cls: "clip-summary" });
      summaryEl.style.cssText = "margin-bottom: 10px; font-size: 0.95em;";
      summaryEl.textContent = clip.summary || clip.description || "No description";
      if (clip.excerpt) {
        const excerptEl = clipEl.createEl("div", { cls: "clip-excerpt" });
        excerptEl.style.cssText = "font-size: 0.85em; color: var(--text-muted); font-style: italic; margin-bottom: 10px; padding: 8px; background: var(--background-secondary); border-radius: 3px;";
        excerptEl.textContent = `"${clip.excerpt.substring(0, 200)}${clip.excerpt.length > 200 ? "..." : ""}"`;
      }
      const btnEl = clipEl.createEl("button", { text: "Extract This Clip" });
      btnEl.style.cssText = "padding: 6px 12px; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 4px; cursor: pointer;";
      btnEl.addEventListener("click", async () => {
        var _a2, _b;
        btnEl.textContent = "Extracting...";
        btnEl.disabled = true;
        const parts = (clip.timestamp || "0:00").split(":").map((p) => parseInt(p, 10));
        let startSeconds = 0;
        if (parts.length === 3) {
          startSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
        } else if (parts.length === 2) {
          startSeconds = parts[0] * 60 + parts[1];
        }
        const clipPath = await this.plugin.doExtractClip(
          clipData.video_id,
          startSeconds,
          clip.duration || 30,
          `${sourceFile.basename}_${((_a2 = clip.timestamp) == null ? void 0 : _a2.replace(/:/g, "-")) || "clip"}`
        );
        if (clipPath) {
          new import_obsidian.Notice(`Clip saved: ${clipPath}`);
          btnEl.textContent = "Extracted!";
          btnEl.style.background = "var(--text-success)";
          let content = await this.app.vault.read(sourceFile);
          if (!content.includes("## Extracted Clips")) {
            content += `

## Extracted Clips
`;
          }
          content += `- [${clip.timestamp}] ${((_b = clip.summary) == null ? void 0 : _b.substring(0, 50)) || "Clip"} - \`${clipPath}\`
`;
          await this.app.vault.modify(sourceFile, content);
        } else {
          new import_obsidian.Notice("Failed to extract clip");
          btnEl.textContent = "Failed - Try Again";
          btnEl.disabled = false;
        }
      });
    }
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 15px; text-align: right;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var LinkedSourcesModal = class extends import_obsidian.Modal {
  constructor(app, plugin, sourcesData, sourceFile) {
    super(app);
    this.plugin = plugin;
    this.sourcesData = sourcesData;
    this.sourceFile = sourceFile;
  }
  onOpen() {
    const { contentEl } = this;
    const { sourcesData } = this;
    contentEl.createEl("h2", { text: `Sources for: ${sourcesData.concept}` });
    const metaEl = contentEl.createEl("div", { cls: "sources-meta" });
    metaEl.style.cssText = "margin-bottom: 20px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    if (sourcesData.section_matched) {
      metaEl.createEl("p", { text: `\u{1F4CD} From section: "${sourcesData.section_matched}"` });
    }
    metaEl.createEl("p", { text: `Found ${sourcesData.total_sources} source${sourcesData.total_sources !== 1 ? "s" : ""} from your Oracle research` });
    const infoEl = contentEl.createEl("div", { cls: "info-callout" });
    infoEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: rgba(var(--color-green-rgb), 0.1); border-left: 3px solid var(--text-success); border-radius: 3px;";
    infoEl.createEl("p", {
      text: "\u2713 These are the exact videos cited in your Training Review - not a new search.",
      cls: "info-text"
    });
    contentEl.createEl("p", {
      text: "Click any timestamp to generate a 60-second WebM clip:",
      cls: "sources-instructions"
    });
    const listEl = contentEl.createEl("div", { cls: "sources-list" });
    listEl.style.cssText = "max-height: 400px; overflow-y: auto;";
    const sources = sourcesData.sources || [];
    if (sources.length === 0) {
      listEl.createEl("p", { text: "No linked sources found for this concept." });
    }
    for (const source of sources) {
      const sourceEl = listEl.createEl("div", { cls: "source-item" });
      const borderColor = source.relevance === "high" ? "var(--text-success)" : source.relevance === "medium" ? "var(--text-warning)" : "var(--text-muted)";
      sourceEl.style.cssText = `padding: 12px; margin: 8px 0; border-radius: 5px; background: var(--background-secondary); cursor: pointer; border-left: 3px solid ${borderColor};`;
      const headerRow = sourceEl.createEl("div", { cls: "source-header" });
      headerRow.style.cssText = "display: flex; align-items: center; gap: 10px;";
      const timestampBadge = headerRow.createEl("span", { cls: "timestamp-badge" });
      timestampBadge.style.cssText = "display: inline-block; background: var(--interactive-accent); color: white; padding: 2px 8px; border-radius: 3px; font-family: monospace;";
      timestampBadge.textContent = source.timestamp || "0:00";
      headerRow.createEl("strong", { text: source.video_title || "Unknown Video" });
      const instructorEl = sourceEl.createEl("p", { cls: "source-instructor" });
      instructorEl.style.cssText = "margin: 5px 0; font-size: 0.9em; color: var(--text-accent);";
      instructorEl.textContent = `\u{1F464} ${source.instructor || "Unknown"}`;
      if (source.context) {
        const contextEl = sourceEl.createEl("p", { cls: "source-context" });
        contextEl.style.cssText = "margin-top: 5px; font-size: 0.85em; color: var(--text-muted); font-style: italic;";
        contextEl.textContent = `"${source.context.substring(0, 150)}${source.context.length > 150 ? "..." : ""}"`;
      }
      sourceEl.addEventListener("click", async () => {
        var _a;
        timestampBadge.textContent = "Generating...";
        timestampBadge.style.background = "var(--text-warning)";
        const clipsFolder = `${((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || this.plugin.settings.syncFolder}/clips/${source.video_id}`;
        const clipPath = await this.plugin.generateClipOnDemand(
          source.video_id,
          source.timestamp_seconds || 0,
          clipsFolder
        );
        if (clipPath) {
          timestampBadge.textContent = "Done!";
          timestampBadge.style.background = "var(--text-success)";
          new import_obsidian.Notice(`Clip saved: ${clipPath}`, 3e3);
          const clipFile = this.app.vault.getAbstractFileByPath(clipPath);
          if (clipFile instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf("split").openFile(clipFile);
          }
        } else {
          timestampBadge.textContent = "Failed";
          timestampBadge.style.background = "var(--text-error)";
          new import_obsidian.Notice("Failed to generate clip", 3e3);
        }
        setTimeout(() => {
          timestampBadge.textContent = source.timestamp || "0:00";
          timestampBadge.style.background = "var(--interactive-accent)";
        }, 3e3);
      });
      sourceEl.addEventListener("mouseenter", () => {
        sourceEl.style.background = "var(--background-modifier-hover)";
      });
      sourceEl.addEventListener("mouseleave", () => {
        sourceEl.style.background = "var(--background-secondary)";
      });
    }
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 20px; display: flex; gap: 10px;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Generate All Clips").setCta().onClick(async () => {
      var _a;
      btn.setButtonText("Generating...");
      btn.setDisabled(true);
      let generated = 0;
      for (const source of sources) {
        const clipsFolder = `${((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || this.plugin.settings.syncFolder}/clips/${source.video_id}`;
        const clipPath = await this.plugin.generateClipOnDemand(
          source.video_id,
          source.timestamp_seconds || 0,
          clipsFolder
        );
        if (clipPath)
          generated++;
      }
      new import_obsidian.Notice(`Generated ${generated}/${sources.length} clips!`, 5e3);
      btn.setButtonText("Done!");
      setTimeout(() => this.close(), 2e3);
    })).addButton((btn) => btn.setButtonText("Try Semantic Search").onClick(async () => {
      this.close();
      new import_obsidian.Notice("Trying semantic search...", 2e3);
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: `${this.plugin.settings.serverUrl}/api/obsidian/explore-video`,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.plugin.settings.apiToken}`
          },
          body: JSON.stringify({ concept: sourcesData.concept })
        });
        const data = response.json;
        if (!data.error) {
          const modal = new VideoExplorerModal(
            this.app,
            this.plugin,
            data,
            this.sourceFile
          );
          modal.open();
        } else {
          new import_obsidian.Notice("No videos found via semantic search", 3e3);
        }
      } catch (error) {
        new import_obsidian.Notice(`Search failed: ${error.message}`, 3e3);
      }
    })).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var VideoExplorerModal = class extends import_obsidian.Modal {
  constructor(app, plugin, videoData, sourceFile) {
    super(app);
    this.plugin = plugin;
    this.videoData = videoData;
    this.sourceFile = sourceFile;
  }
  onOpen() {
    const { contentEl } = this;
    const { videoData } = this;
    contentEl.createEl("h2", { text: `Video: ${videoData.title || "Unknown"}` });
    const metaEl = contentEl.createEl("div", { cls: "video-meta" });
    metaEl.style.cssText = "margin-bottom: 20px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    metaEl.createEl("p", { text: `Instructor: ${videoData.instructor || "Unknown"}` });
    metaEl.createEl("p", { text: `Video ID: ${videoData.video_id}` });
    metaEl.createEl("p", { text: `Found ${videoData.total_techniques || 0} techniques with timestamps` });
    contentEl.createEl("p", {
      text: "Click any timestamp to generate a 60-second WebM clip:",
      cls: "video-explorer-instructions"
    });
    const listEl = contentEl.createEl("div", { cls: "techniques-list" });
    listEl.style.cssText = "max-height: 400px; overflow-y: auto;";
    const techniques = videoData.techniques || [];
    if (techniques.length === 0) {
      listEl.createEl("p", { text: "No timestamped techniques found in this video." });
    }
    for (const tech of techniques) {
      const techEl = listEl.createEl("div", { cls: "technique-item" });
      techEl.style.cssText = "padding: 12px; margin: 8px 0; border-radius: 5px; background: var(--background-secondary); cursor: pointer; border-left: 3px solid var(--interactive-accent);";
      const timestampBadge = techEl.createEl("span", { cls: "timestamp-badge" });
      timestampBadge.style.cssText = "display: inline-block; background: var(--interactive-accent); color: white; padding: 2px 8px; border-radius: 3px; font-family: monospace; margin-right: 10px;";
      timestampBadge.textContent = tech.timestamp || "0:00";
      techEl.createEl("strong", { text: tech.name || "Untitled" });
      if (tech.description) {
        const descEl = techEl.createEl("p", { cls: "technique-description" });
        descEl.style.cssText = "margin-top: 5px; font-size: 0.9em; color: var(--text-muted);";
        descEl.textContent = tech.description.substring(0, 200) + (tech.description.length > 200 ? "..." : "");
      }
      techEl.addEventListener("click", async () => {
        var _a;
        timestampBadge.textContent = "Generating...";
        timestampBadge.style.background = "var(--text-warning)";
        const clipsFolder = `${((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || this.plugin.settings.syncFolder}/clips/${this.videoData.video_id}`;
        const clipPath = await this.plugin.generateClipOnDemand(
          videoData.video_id,
          tech.timestamp_seconds || 0,
          clipsFolder
        );
        if (clipPath) {
          timestampBadge.textContent = "Done!";
          timestampBadge.style.background = "var(--text-success)";
          new import_obsidian.Notice(`Clip saved: ${clipPath}`, 3e3);
          const clipFile = this.app.vault.getAbstractFileByPath(clipPath);
          if (clipFile instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf("split").openFile(clipFile);
          }
        } else {
          timestampBadge.textContent = "Failed";
          timestampBadge.style.background = "var(--text-error)";
          new import_obsidian.Notice("Failed to generate clip", 3e3);
        }
        setTimeout(() => {
          timestampBadge.textContent = tech.timestamp || "0:00";
          timestampBadge.style.background = "var(--interactive-accent)";
        }, 3e3);
      });
      techEl.addEventListener("mouseenter", () => {
        techEl.style.background = "var(--background-modifier-hover)";
      });
      techEl.addEventListener("mouseleave", () => {
        techEl.style.background = "var(--background-secondary)";
      });
    }
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 20px; display: flex; gap: 10px;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Expand to Full Series").onClick(async () => {
      btn.setButtonText("Loading...");
      btn.setDisabled(true);
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: `${this.plugin.settings.serverUrl}/api/obsidian/explore-series`,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.plugin.settings.apiToken}`
          },
          body: JSON.stringify({
            concept: this.videoData.concept_searched || this.videoData.title,
            instructor: this.videoData.instructor
          })
        });
        const seriesData = response.json;
        if (seriesData.error) {
          new import_obsidian.Notice("No series found", 3e3);
          btn.setButtonText("Expand to Full Series");
          btn.setDisabled(false);
          return;
        }
        this.close();
        const seriesModal = new SeriesExplorerModal(
          this.app,
          this.plugin,
          seriesData,
          this.sourceFile
        );
        seriesModal.open();
      } catch (error) {
        new import_obsidian.Notice(`Failed to load series: ${error.message}`, 3e3);
        btn.setButtonText("Expand to Full Series");
        btn.setDisabled(false);
      }
    })).addButton((btn) => btn.setButtonText("Generate All Clips").setCta().onClick(async () => {
      var _a;
      btn.setButtonText("Generating...");
      btn.setDisabled(true);
      const clipsFolder = `${((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || this.plugin.settings.syncFolder}/clips/${this.videoData.video_id}`;
      let generated = 0;
      for (const tech of techniques) {
        const clipPath = await this.plugin.generateClipOnDemand(
          videoData.video_id,
          tech.timestamp_seconds || 0,
          clipsFolder
        );
        if (clipPath)
          generated++;
      }
      new import_obsidian.Notice(`Generated ${generated}/${techniques.length} clips!`, 5e3);
      btn.setButtonText("Done!");
      setTimeout(() => this.close(), 2e3);
    })).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var SeriesExplorerModal = class extends import_obsidian.Modal {
  constructor(app, plugin, seriesData, sourceFile) {
    super(app);
    this.plugin = plugin;
    this.seriesData = seriesData;
    this.sourceFile = sourceFile;
  }
  onOpen() {
    const { contentEl } = this;
    const { seriesData } = this;
    contentEl.createEl("h2", { text: `Series: ${seriesData.series_name || "Unknown"}` });
    const metaEl = contentEl.createEl("div", { cls: "series-meta" });
    metaEl.style.cssText = "margin-bottom: 20px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    metaEl.createEl("p", { text: `Instructor: ${seriesData.instructor || "Unknown"}` });
    metaEl.createEl("p", { text: `Total Volumes: ${seriesData.total_volumes || 0}` });
    const volumesEl = contentEl.createEl("div", { cls: "volumes-list" });
    volumesEl.style.cssText = "max-height: 500px; overflow-y: auto;";
    const volumes = seriesData.volumes || [];
    for (const vol of volumes) {
      const volContainer = volumesEl.createEl("div", { cls: "volume-container" });
      volContainer.style.cssText = "margin-bottom: 10px; border: 1px solid var(--background-modifier-border); border-radius: 5px;";
      const volHeader = volContainer.createEl("div", { cls: "volume-header" });
      volHeader.style.cssText = "padding: 12px; background: var(--interactive-accent); color: white; cursor: pointer; border-radius: 5px 5px 0 0; display: flex; justify-content: space-between; align-items: center;";
      volHeader.createEl("strong", { text: `Volume ${vol.volume}: ${vol.title || ""}` });
      const techCount = volHeader.createEl("span");
      techCount.textContent = `${vol.total_techniques || 0} techniques`;
      techCount.style.cssText = "font-size: 0.85em; opacity: 0.9;";
      const techList = volContainer.createEl("div", { cls: "technique-list" });
      techList.style.cssText = "display: none; padding: 10px; background: var(--background-primary);";
      volHeader.addEventListener("click", () => {
        const isVisible = techList.style.display !== "none";
        techList.style.display = isVisible ? "none" : "block";
        volHeader.style.borderRadius = isVisible ? "5px 5px 0 0" : "5px";
      });
      for (const tech of vol.techniques || []) {
        const techEl = techList.createEl("div", { cls: "technique-item" });
        techEl.style.cssText = "padding: 8px; margin: 4px 0; border-radius: 3px; background: var(--background-secondary); cursor: pointer; border-left: 3px solid var(--text-accent);";
        const timestampBadge = techEl.createEl("span");
        timestampBadge.style.cssText = "display: inline-block; background: var(--text-accent); color: white; padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.85em; margin-right: 8px;";
        timestampBadge.textContent = tech.timestamp || "0:00";
        techEl.createEl("span", { text: tech.name || "Untitled" });
        techEl.addEventListener("click", async (e) => {
          var _a;
          e.stopPropagation();
          timestampBadge.textContent = "...";
          timestampBadge.style.background = "var(--text-warning)";
          const clipsFolder = `${((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || this.plugin.settings.syncFolder}/clips/${vol.video_id}`;
          const clipPath = await this.plugin.generateClipOnDemand(
            vol.video_id,
            tech.timestamp_seconds || 0,
            clipsFolder
          );
          if (clipPath) {
            timestampBadge.textContent = "OK";
            timestampBadge.style.background = "var(--text-success)";
            new import_obsidian.Notice(`Clip saved!`, 2e3);
          } else {
            timestampBadge.textContent = "X";
            timestampBadge.style.background = "var(--text-error)";
          }
          setTimeout(() => {
            timestampBadge.textContent = tech.timestamp || "0:00";
            timestampBadge.style.background = "var(--text-accent)";
          }, 2e3);
        });
        techEl.addEventListener("mouseenter", () => techEl.style.background = "var(--background-modifier-hover)");
        techEl.addEventListener("mouseleave", () => techEl.style.background = "var(--background-secondary)");
      }
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var CoachPushConceptsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, concepts) {
    super(app);
    this.plugin = plugin;
    this.concepts = concepts;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Push Concepts to Athlete" });
    contentEl.createEl("p", { text: `${this.concepts.length} concepts ready to push` });
    let athletes = [];
    try {
      athletes = await this.plugin.coachClient.getAthletes();
    } catch (e) {
      contentEl.createEl("p", { text: "Failed to load athletes" });
      return;
    }
    if (athletes.length === 0) {
      contentEl.createEl("p", { text: "No athletes in roster. Add athletes first." });
      return;
    }
    let selectedAthleteId = null;
    new import_obsidian.Setting(contentEl).setName("Select Athlete").addDropdown((dropdown) => {
      dropdown.addOption("", "Choose athlete...");
      for (const athlete of athletes) {
        dropdown.addOption(
          String(athlete.id),
          athlete.display_name || athlete.discord_username || `Athlete ${athlete.id}`
        );
      }
      dropdown.onChange((value) => {
        selectedAthleteId = value ? parseInt(value) : null;
      });
    });
    const listEl = contentEl.createEl("div", { cls: "concept-list" });
    listEl.createEl("h4", { text: "Concepts:" });
    const ul = listEl.createEl("ul");
    for (const c of this.concepts.slice(0, 10)) {
      ul.createEl("li", { text: `${c.name} (${c.category})` });
    }
    if (this.concepts.length > 10) {
      ul.createEl("li", { text: `... and ${this.concepts.length - 10} more` });
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Push Concepts").setCta().onClick(async () => {
      if (!selectedAthleteId) {
        new import_obsidian.Notice("Select an athlete first");
        return;
      }
      try {
        new import_obsidian.Notice("Pushing concepts...");
        const result = await this.plugin.coachClient.pushConcepts(selectedAthleteId, this.concepts);
        new import_obsidian.Notice(`Pushed! ${result.created} new, ${result.updated} updated`);
        this.close();
      } catch (error) {
        console.error("Push concepts error:", error);
        new import_obsidian.Notice("Failed to push concepts");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var PendingJobsModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-pending-modal");
    contentEl.createEl("h2", { text: "Pending Coach Queries" });
    if (!this.plugin.isRemoteMode()) {
      contentEl.createEl("p", { text: "Remote mode not configured. Enable in settings." });
      return;
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Refresh").onClick(() => this.refresh()));
    const jobsContainer = contentEl.createDiv({ cls: "pending-jobs-list" });
    jobsContainer.style.marginTop = "15px";
    await this.loadJobs(jobsContainer);
  }
  async loadJobs(container) {
    container.empty();
    try {
      const jobs = await this.plugin.queueClient.listJobs();
      if (jobs.length === 0) {
        container.createEl("p", {
          text: "No pending queries",
          cls: "no-jobs"
        });
        return;
      }
      for (const job of jobs) {
        const jobDiv = container.createDiv({ cls: "job-item" });
        jobDiv.style.background = "var(--background-secondary)";
        jobDiv.style.padding = "12px";
        jobDiv.style.borderRadius = "8px";
        jobDiv.style.marginBottom = "10px";
        const statusColors = {
          "pending": "var(--text-muted)",
          "processing": "var(--text-accent)",
          "complete": "var(--text-success)",
          "error": "var(--text-error)"
        };
        const statusEl = jobDiv.createEl("span", {
          text: job.status.toUpperCase(),
          cls: "job-status"
        });
        statusEl.style.color = statusColors[job.status] || "var(--text-muted)";
        statusEl.style.fontWeight = "600";
        statusEl.style.marginRight = "10px";
        const queryEl = jobDiv.createEl("span", {
          text: job.query_text.substring(0, 50) + (job.query_text.length > 50 ? "..." : "")
        });
        const timeEl = jobDiv.createEl("div", {
          text: `Submitted: ${new Date(job.submitted_at).toLocaleString()}`,
          cls: "job-time"
        });
        timeEl.style.fontSize = "0.85em";
        timeEl.style.color = "var(--text-muted)";
        timeEl.style.marginTop = "5px";
      }
    } catch (error) {
      container.createEl("p", {
        text: "Failed to load jobs. Check connection.",
        cls: "error"
      });
    }
  }
  async refresh() {
    const container = this.contentEl.querySelector(".pending-jobs-list");
    if (container) {
      await this.loadJobs(container);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BJJFlipmodeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Flipmode Settings" });
    new import_obsidian.Setting(containerEl).setName("Mode").setDesc("Local: Direct Oracle. Remote: Athlete sending to Oracle. Coach: Process athlete queries.").addDropdown((dropdown) => dropdown.addOption("local", "Local (Direct Oracle)").addOption("remote", "Remote (Athlete)").addOption("coach", "Coach (Process Queries)").setValue(this.plugin.settings.mode).onChange(async (value) => {
      this.plugin.settings.mode = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    containerEl.createEl("h3", { text: "Athlete Identity" });
    new import_obsidian.Setting(containerEl).setName("Athlete Name").setDesc("Your name (used for folder organization: Flipmode/Athletes/{Name}/Sessions/)").addText((text) => text.setPlaceholder("Enter athlete name").setValue(this.plugin.settings.athleteName).onChange(async (value) => {
      this.plugin.settings.athleteName = value || "Athlete";
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Season & Episode Tracking" });
    containerEl.createEl("p", {
      text: `Current: ${this.plugin.settings.athleteName} - S${this.plugin.settings.currentSeason}E${String(this.plugin.settings.currentEpisode).padStart(2, "0")}`,
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Current Season").setDesc("Training season number (e.g., competition prep, off-season)").addText((text) => text.setValue(String(this.plugin.settings.currentSeason)).onChange(async (value) => {
      const num = parseInt(value) || 1;
      this.plugin.settings.currentSeason = Math.max(1, num);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Current Episode").setDesc("Session number within the season").addText((text) => text.setValue(String(this.plugin.settings.currentEpisode)).onChange(async (value) => {
      const num = parseInt(value) || 1;
      this.plugin.settings.currentEpisode = Math.max(1, num);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Start New Season").setDesc("Increment season number and reset episode to 1").addButton((btn) => btn.setButtonText("New Season").onClick(async () => {
      this.plugin.settings.currentSeason += 1;
      this.plugin.settings.currentEpisode = 1;
      await this.plugin.saveSettings();
      this.display();
      new import_obsidian.Notice(`Started Season ${this.plugin.settings.currentSeason}!`);
    }));
    if (this.plugin.settings.mode === "local") {
      containerEl.createEl("h3", { text: "Local Mode Settings" });
      new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("URL of your Flipmode server").addText((text) => text.setPlaceholder("http://localhost:5005").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("API Token").setDesc("Your API token from the Flipmode profile page").addText((text) => text.setPlaceholder("Enter your API token").setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Verify connection to Flipmode server").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
        const connected = await this.plugin.checkConnection();
        new import_obsidian.Notice(connected ? "Successfully connected to Flipmode!" : "Could not connect to Flipmode");
      }));
    } else if (this.plugin.settings.mode === "remote") {
      containerEl.createEl("h3", { text: "Remote Mode Settings (Athlete)" });
      new import_obsidian.Setting(containerEl).setName("Queue Service URL").setDesc("URL of the Oracle queue service (e.g., https://your-app.herokuapp.com)").addText((text) => text.setPlaceholder("https://flipmode-queue.herokuapp.com").setValue(this.plugin.settings.queueServiceUrl).onChange(async (value) => {
        this.plugin.settings.queueServiceUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Connect with Discord").setDesc("Authenticate via Discord to connect with Oracle").addButton((btn) => btn.setButtonText("Connect Discord").setCta().onClick(async () => {
        await this.plugin.connectWithDiscord();
      }));
      new import_obsidian.Setting(containerEl).setName("Athlete Token").setDesc("Your athlete token (obtained after Discord connection)").addText((text) => text.setPlaceholder("Paste token from Discord auth").setValue(this.plugin.settings.athleteToken).onChange(async (value) => {
        this.plugin.settings.athleteToken = value;
        await this.plugin.saveSettings();
        if (value && this.plugin.settings.queueServiceUrl) {
          this.plugin.initRemoteMode();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Poll Interval").setDesc("Seconds between checking for results").addSlider((slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.pollInterval).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.pollInterval = value;
        await this.plugin.saveSettings();
        if (this.plugin.isRemoteMode()) {
          this.plugin.startResultPolling();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Test Queue Connection").setDesc("Verify connection to Oracle queue").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
        if (!this.plugin.settings.queueServiceUrl) {
          new import_obsidian.Notice("Configure Queue Service URL first");
          return;
        }
        try {
          const client = new RemoteQueueClient(
            this.plugin.settings.queueServiceUrl,
            this.plugin.settings.athleteToken
          );
          const healthy = await client.checkHealth();
          new import_obsidian.Notice(healthy ? "Queue service is healthy!" : "Queue service not responding");
        } catch (error) {
          new import_obsidian.Notice("Failed to connect to queue service");
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Pending Queries").setDesc("View your pending Oracle queries").addButton((btn) => btn.setButtonText("View Jobs").onClick(() => {
        this.plugin.showPendingJobsModal();
      }));
      new import_obsidian.Setting(containerEl).setName("Sync Graph").setDesc("Send your research graph to Oracle").addButton((btn) => btn.setButtonText("Sync Now").onClick(async () => {
        await this.plugin.syncGraphToCoach();
      }));
    } else if (this.plugin.settings.mode === "coach") {
      containerEl.createEl("h3", { text: "Coach Mode Settings" });
      new import_obsidian.Setting(containerEl).setName("Queue Service URL").setDesc("URL of the queue service (same as athletes use)").addText((text) => text.setPlaceholder("https://flipmode-queue.herokuapp.com").setValue(this.plugin.settings.queueServiceUrl).onChange(async (value) => {
        this.plugin.settings.queueServiceUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Coach Token").setDesc("Your coach API token (from registration)").addText((text) => text.setPlaceholder("Your coach token").setValue(this.plugin.settings.coachToken).onChange(async (value) => {
        this.plugin.settings.coachToken = value;
        await this.plugin.saveSettings();
        if (value && this.plugin.settings.queueServiceUrl) {
          this.plugin.initCoachMode();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Local Oracle URL").setDesc("Your local Flipmode server for generating articles").addText((text) => text.setPlaceholder("http://localhost:5005").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Verify connection to queue service").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
        if (!this.plugin.settings.queueServiceUrl) {
          new import_obsidian.Notice("Configure Queue Service URL first");
          return;
        }
        try {
          const client = new CoachQueueClient(
            this.plugin.settings.queueServiceUrl,
            this.plugin.settings.coachToken
          );
          const healthy = await client.checkHealth();
          new import_obsidian.Notice(healthy ? "Connected!" : "Service not responding");
        } catch (e) {
          new import_obsidian.Notice("Connection failed");
        }
      }));
      containerEl.createEl("h4", { text: "Quick Actions" });
      new import_obsidian.Setting(containerEl).setName("Sync Athletes").setDesc("Pull all athlete data and pending queries").addButton((btn) => btn.setButtonText("Sync Now").setCta().onClick(() => this.plugin.coachSyncAthletes()));
      new import_obsidian.Setting(containerEl).setName("View Pending").setDesc("Open inbox with pending queries").addButton((btn) => btn.setButtonText("View").onClick(() => this.plugin.coachShowPending()));
      new import_obsidian.Setting(containerEl).setName("Add Athlete").setDesc("Add a new athlete to your roster").addButton((btn) => btn.setButtonText("Add").onClick(() => this.plugin.coachAddAthlete()));
    }
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Sync Folder").setDesc("Folder in your vault for Flipmode content").addText((text) => text.setPlaceholder("Flipmode").setValue(this.plugin.settings.syncFolder).onChange(async (value) => {
      this.plugin.settings.syncFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Concepts Subfolder").setDesc('Subfolder for concept graphs (e.g., "concepts" \u2192 {syncFolder}/concepts/{topic}/)').addText((text) => text.setPlaceholder("concepts").setValue(this.plugin.settings.conceptsSubfolder).onChange(async (value) => {
      this.plugin.settings.conceptsSubfolder = value || "concepts";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync with Flipmode periodically").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.startAutoSync();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("Minutes between automatic syncs").addSlider((slider) => slider.setLimits(5, 120, 5).setValue(this.plugin.settings.syncInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.syncInterval = value;
      await this.plugin.saveSettings();
    }));
  }
};
var ConceptCacheClipsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, sourceNode, sourceFile, cacheData) {
    super(app);
    this.plugin = plugin;
    this.sourceNode = sourceNode;
    this.sourceFile = sourceFile;
    this.cacheData = cacheData;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("concept-cache-clips-modal");
    const { video_id, video_name, instructor, content, timestamps } = this.cacheData;
    contentEl.createEl("h2", { text: "Concept Cache - Click Timestamp to Extract Clip" });
    const infoEl = contentEl.createEl("div", { cls: "video-info" });
    infoEl.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 5px;";
    infoEl.createEl("p", { text: `Video: ${video_name || video_id}` });
    infoEl.createEl("p", { text: `Instructor: ${instructor || "Unknown"}` });
    infoEl.createEl("p", { text: `Timestamps found: ${(timestamps == null ? void 0 : timestamps.length) || 0}` });
    contentEl.createEl("p", {
      text: "Click any timestamp to extract a 60-second clip and add it as a node on the canvas.",
      cls: "instructions"
    }).style.cssText = "color: var(--text-accent); margin-bottom: 15px;";
    if (timestamps && timestamps.length > 0) {
      const listEl = contentEl.createEl("div", { cls: "timestamps-list" });
      listEl.style.cssText = "max-height: 400px; overflow-y: auto;";
      for (const ts of timestamps) {
        const tsEl = listEl.createEl("div", { cls: "timestamp-item" });
        tsEl.style.cssText = "padding: 12px; margin-bottom: 10px; background: var(--background-primary-alt); border-radius: 5px; cursor: pointer; border-left: 3px solid var(--text-accent);";
        const headerEl = tsEl.createEl("div", { cls: "ts-header" });
        headerEl.style.cssText = "display: flex; justify-content: space-between; align-items: center;";
        const timeBtn = headerEl.createEl("span", { cls: "timestamp-btn" });
        timeBtn.style.cssText = "font-weight: bold; font-size: 1.1em; color: var(--text-accent); cursor: pointer;";
        timeBtn.textContent = ts.timestamp || ts.time || "0:00";
        const durationEl = headerEl.createEl("span");
        durationEl.style.cssText = "font-size: 0.85em; color: var(--text-muted);";
        durationEl.textContent = "60s clip";
        if (ts.description || ts.context || ts.text) {
          const descEl = tsEl.createEl("div", { cls: "ts-description" });
          descEl.style.cssText = "margin-top: 8px; font-size: 0.9em; color: var(--text-muted);";
          descEl.textContent = (ts.description || ts.context || ts.text).substring(0, 200);
        }
        tsEl.addEventListener("click", async () => {
          await this.extractClipAtTimestamp(ts.timestamp || ts.time || "0:00", ts.description || ts.context || "");
        });
        tsEl.addEventListener("mouseenter", () => {
          tsEl.style.background = "var(--background-modifier-hover)";
        });
        tsEl.addEventListener("mouseleave", () => {
          tsEl.style.background = "var(--background-primary-alt)";
        });
      }
    } else {
      contentEl.createEl("p", { text: "No structured timestamps found. Showing raw content:" });
      const contentDiv = contentEl.createEl("div", { cls: "raw-content" });
      contentDiv.style.cssText = "max-height: 400px; overflow-y: auto; padding: 10px; background: var(--background-primary-alt); border-radius: 5px; font-size: 0.9em;";
      const timestampRegex = /\[(\d{1,2}:\d{2}(?::\d{2})?)\]/g;
      let lastIndex = 0;
      let match;
      const rawContent = content || "";
      while ((match = timestampRegex.exec(rawContent)) !== null) {
        if (match.index > lastIndex) {
          contentDiv.appendText(rawContent.substring(lastIndex, match.index));
        }
        const tsSpan = contentDiv.createEl("span", { cls: "clickable-timestamp" });
        tsSpan.style.cssText = "color: var(--text-accent); cursor: pointer; font-weight: bold; text-decoration: underline;";
        tsSpan.textContent = match[0];
        const timestamp = match[1];
        tsSpan.addEventListener("click", async (e) => {
          e.stopPropagation();
          await this.extractClipAtTimestamp(timestamp, "");
        });
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < rawContent.length) {
        contentDiv.appendText(rawContent.substring(lastIndex));
      }
    }
    const footerEl = contentEl.createEl("div", { cls: "modal-footer" });
    footerEl.style.cssText = "margin-top: 15px; text-align: right;";
    new import_obsidian.Setting(footerEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  async extractClipAtTimestamp(timestamp, description) {
    var _a;
    const { video_id } = this.cacheData;
    const parts = timestamp.split(":").map((p) => parseInt(p, 10));
    let startSeconds = 0;
    if (parts.length === 3) {
      startSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
    } else if (parts.length === 2) {
      startSeconds = parts[0] * 60 + parts[1];
    }
    new import_obsidian.Notice(`Extracting 60s clip from ${timestamp}...`);
    try {
      const parentPath = ((_a = this.sourceFile.parent) == null ? void 0 : _a.path) || "";
      const vaultFolder = `${parentPath}/clips`;
      const safeName = `${this.sourceFile.basename}_${timestamp.replace(/:/g, "-")}`;
      const clipPath = await this.plugin.doExtractClip(video_id, startSeconds, 60, safeName, vaultFolder);
      if (!clipPath) {
        new import_obsidian.Notice("Failed to extract clip");
        return;
      }
      new import_obsidian.Notice(`Clip extracted: ${clipPath}`);
      const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
      if (!canvasView || canvasView.getViewType() !== "canvas") {
        new import_obsidian.Notice("Canvas not active - clip saved but node not added");
        return;
      }
      const canvas = canvasView.canvas;
      if (!canvas) {
        new import_obsidian.Notice("Could not access canvas");
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
      const clipFile = this.app.vault.getAbstractFileByPath(clipPath);
      if (clipFile && clipFile instanceof import_obsidian.TFile) {
        canvas.createFileNode({
          file: clipFile,
          pos: {
            x: this.sourceNode.x + this.sourceNode.width + 50,
            y: this.sourceNode.y
          },
          size: {
            width: 320,
            height: 240
          }
        });
        canvas.requestSave();
        new import_obsidian.Notice(`Clip node added to canvas at ${timestamp}`);
      } else {
        new import_obsidian.Notice(`Clip saved but file not found in vault: ${clipPath}`);
      }
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Extract clip error:", error);
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};
