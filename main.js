/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BJJFlipmodePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/header-asset.ts
var FLIPMODE_HEADER_BASE64 = `data:image/png;base64,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`;

// src/main.ts
var DEFAULT_SETTINGS = {
  serverUrl: "http://localhost:5005",
  apiToken: "",
  syncFolder: "Flipmode",
  autoSync: false,
  syncInterval: 30,
  userId: "default",
  // Mode defaults
  mode: "local",
  queueServiceUrl: "https://flipmode-d2c51311485b.herokuapp.com",
  athleteToken: "",
  pollInterval: 10,
  // Coach mode defaults
  coachToken: "",
  // Season/Episode tracking
  currentSeason: 1,
  currentEpisode: 1,
  // Athlete identity
  athleteName: "Athlete"
};
var RemoteQueueClient = class {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
  }
  async submitQuery(query, therapyContext) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/submit`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.token}`
      },
      body: JSON.stringify({
        query_text: query,
        therapy_context: therapyContext
      })
    });
    return { jobId: response.json.job_id };
  }
  async checkStatus(jobId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/status/${jobId}`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    return {
      status: response.json.status,
      progress: response.json.started_at ? "Processing..." : "Queued"
    };
  }
  async getResult(jobId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/result/${jobId}`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    const data = response.json;
    if (data.status === "error") {
      return { article: "", sources: [], error: data.error };
    }
    return {
      article: data.result_article || "",
      sources: data.result_sources || [],
      rlm_session_id: data.rlm_session_id
    };
  }
  async listJobs() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/jobs`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    });
    return response.json.jobs || [];
  }
  async syncGraph(graphData) {
    await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/graph/sync`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.token}`
      },
      body: JSON.stringify(graphData)
    });
  }
  async checkHealth() {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/health`,
        method: "GET"
      });
      return response.json.status === "healthy";
    } catch (e) {
      return false;
    }
  }
};
var CoachQueueClient = class {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
  }
  async getAthletes() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/roster`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json.athletes || [];
  }
  async addAthlete(discordId, displayName) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/roster`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ discord_id: discordId, display_name: displayName })
    });
    return response.json;
  }
  async getPendingJobs() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/pending`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json.jobs || [];
  }
  async getAthleteGraph(athleteId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/graph/${athleteId}`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json;
  }
  async claimJob(jobId) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/queue/claim/${jobId}`,
      method: "POST",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json;
  }
  async completeJob(jobId, article, sources) {
    try {
      await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/api/queue/complete/${jobId}`,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          result_article: article,
          result_sources: sources,
          rlm_session_id: `coach_${jobId}`
        })
      });
      return true;
    } catch (e) {
      return false;
    }
  }
  async getStats() {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/coach/stats`,
      method: "GET",
      headers: { "Authorization": `Bearer ${this.token}` }
    });
    return response.json;
  }
  async checkHealth() {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/health`,
        method: "GET"
      });
      return response.json.status === "healthy";
    } catch (e) {
      return false;
    }
  }
};
var BJJFlipmodePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    // Remote mode (athlete)
    this.pendingJobs = /* @__PURE__ */ new Map();
    this.pollIntervalId = null;
    this.queueClient = null;
    // Coach mode
    this.coachClient = null;
  }
  async onload() {
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("Disconnected");
    this.addRibbonIcon("brain-circuit", "Flipmode", async () => {
      await this.showFlipmodeMenu();
    });
    this.addCommand({
      id: "flipmode-voice-note",
      name: "Record training voice note",
      callback: () => this.showVoiceNoteModal()
    });
    this.addCommand({
      id: "flipmode-research",
      name: "Research a technique",
      callback: () => this.showResearchModal()
    });
    this.addCommand({
      id: "flipmode-sync",
      name: "Sync with Flipmode",
      callback: () => this.syncWithFlipmode()
    });
    this.addCommand({
      id: "flipmode-quick-note",
      name: "Quick training note",
      editorCallback: (editor, view) => {
        this.insertTrainingTemplate(editor);
      }
    });
    this.addCommand({
      id: "flipmode-check-connection",
      name: "Check Flipmode connection",
      callback: () => this.checkConnection()
    });
    this.addCommand({
      id: "flipmode-view-pending-jobs",
      name: "View pending coach queries",
      callback: () => this.showPendingJobsModal()
    });
    this.addCommand({
      id: "flipmode-connect-discord",
      name: "Connect with Discord (remote mode)",
      callback: () => this.connectWithDiscord()
    });
    this.addCommand({
      id: "flipmode-coach-sync",
      name: "Coach: Sync all athletes",
      callback: () => this.coachSyncAthletes()
    });
    this.addCommand({
      id: "flipmode-coach-pending",
      name: "Coach: View pending queries",
      callback: () => this.coachShowPending()
    });
    this.addCommand({
      id: "flipmode-coach-generate",
      name: "Coach: Generate article for current query",
      editorCallback: (editor, view) => this.coachGenerateArticle(view)
    });
    this.addCommand({
      id: "flipmode-coach-push",
      name: "Coach: Push article to athlete",
      editorCallback: (editor, view) => this.coachPushArticle(view)
    });
    this.addCommand({
      id: "flipmode-coach-add-athlete",
      name: "Coach: Add athlete to roster",
      callback: () => this.coachAddAthlete()
    });
    this.addCommand({
      id: "flipmode-dive-deeper-session",
      name: "Dive Deeper on this session",
      editorCallback: async (editor, view) => {
        await this.diveDeepOnSession(view);
      }
    });
    this.addCommand({
      id: "flipmode-generate-training-review",
      name: "Generate Training Review (from Training Notes)",
      editorCallback: async (editor, view) => {
        await this.generateTrainingReview(view);
      }
    });
    this.addCommand({
      id: "flipmode-publish-training-review",
      name: "Publish Training Review (send to athlete)",
      editorCallback: async (editor, view) => {
        await this.publishTrainingReview(view);
      }
    });
    this.addCommand({
      id: "flipmode-open-audio-player",
      name: "Open Audio Player",
      editorCallback: async (editor, view) => {
        await this.openAudioPlayer(view);
      }
    });
    this.addSettingTab(new BJJFlipmodeSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const selection = editor.getSelection();
        if (selection && selection.trim().length > 0) {
          menu.addItem((item) => {
            item.setTitle("Generate Training Review").setIcon("graduation-cap").onClick(async () => {
              await this.generateTrainingReviewFromSelection(editor, view, selection);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Generate Skill Development").setIcon("dumbbell").onClick(async () => {
              await this.generateTrainingPlanFromSelection(editor, view, selection);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Dive Deeper").setIcon("search").onClick(async () => {
              await this.diveDeeper(editor, view, selection);
            });
          });
        }
      })
    );
    this.checkConnection();
    if (this.settings.autoSync) {
      this.startAutoSync();
    }
    if (this.settings.mode === "remote" && this.settings.queueServiceUrl && this.settings.athleteToken) {
      this.initRemoteMode();
    }
    if (this.settings.mode === "coach" && this.settings.queueServiceUrl && this.settings.coachToken) {
      this.initCoachMode();
    }
  }
  // Coach mode methods
  initCoachMode() {
    this.coachClient = new CoachQueueClient(
      this.settings.queueServiceUrl,
      this.settings.coachToken
    );
    this.updateStatusBar("Coach Mode");
  }
  isCoachMode() {
    return this.settings.mode === "coach" && !!this.coachClient;
  }
  async coachSyncAthletes() {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    new import_obsidian.Notice("Syncing athletes...");
    try {
      const athletes = await this.coachClient.getAthletes();
      const athletesFolder = `${this.settings.syncFolder}/Athletes`;
      await this.ensureFolder(athletesFolder);
      for (const athlete of athletes) {
        const name = athlete.display_name || athlete.discord_username || `Athlete_${athlete.id}`;
        const safeName = name.replace(/[\\/:*?"<>|]/g, "_");
        const athleteFolder = `${athletesFolder}/${safeName}`;
        await this.ensureFolder(athleteFolder);
        const graphData = await this.coachClient.getAthleteGraph(athlete.id);
        const graph = (graphData == null ? void 0 : graphData.graph_data) || { sessions: [], queries: [], topics: [] };
        const summaryContent = this.createAthleteSummary(name, athlete, graph);
        await this.saveNote(`${athleteFolder}/summary.md`, summaryContent);
      }
      const pending = await this.coachClient.getPendingJobs();
      const inboxFolder = `${this.settings.syncFolder}/Inbox`;
      await this.ensureFolder(inboxFolder);
      for (const job of pending) {
        const filename = `${inboxFolder}/${job.job_id.substring(0, 8)} - ${job.athlete_name || "Unknown"}.md`;
        if (await this.app.vault.adapter.exists(filename))
          continue;
        const content = this.createPendingQueryNote(job);
        await this.saveNote(filename, content);
      }
      new import_obsidian.Notice(`Synced ${athletes.length} athletes, ${pending.length} pending queries`);
    } catch (error) {
      console.error("Sync error:", error);
      new import_obsidian.Notice("Sync failed - check connection");
    }
  }
  createAthleteSummary(name, athlete, graph) {
    const sessions = graph.sessions || [];
    const queries = graph.queries || [];
    const topics = graph.topics || [];
    let content = `---
type: athlete-summary
athlete_id: ${athlete.id}
discord_id: ${athlete.discord_id}
updated: ${new Date().toISOString().split("T")[0]}
---

# ${name}

## Overview

- **Sessions:** ${sessions.length}
- **Queries:** ${queries.length}
- **Topics:** ${topics.length}

## Topics Explored

${topics.length > 0 ? topics.map((t) => `- ${t}`).join("\n") : "*No topics yet*"}

## Recent Queries

`;
    const sortedQueries = [...queries].sort(
      (a, b) => (b.date || "").localeCompare(a.date || "")
    ).slice(0, 10);
    for (const q of sortedQueries) {
      const status = q.pending ? "\u23F3" : "\u2713";
      content += `- [${status}] ${q.topic || "Unknown"} (${q.date || "N/A"})
`;
    }
    content += `
## Recent Sessions

`;
    const sortedSessions = [...sessions].sort(
      (a, b) => (b.date || "").localeCompare(a.date || "")
    ).slice(0, 10);
    for (const s of sortedSessions) {
      const tags = (s.tags || []).join(", ");
      content += `- ${s.date || "Unknown"} - ${tags || "No tags"}
`;
    }
    return content;
  }
  createPendingQueryNote(job) {
    return `---
type: pending-query
job_id: ${job.job_id}
athlete_id: ${job.athlete_id}
athlete_name: ${job.athlete_name || "Unknown"}
submitted: ${job.submitted_at}
status: pending
---

# Query from ${job.athlete_name || "Unknown"}

**Submitted:** ${job.submitted_at}

## Question

${job.query_text}

---

## Actions

1. Run command: **Coach: Generate article for current query**
2. Edit the generated article below
3. Run command: **Coach: Push article to athlete**

---

## Generated Article

*Run "Coach: Generate article" to populate this section*

`;
  }
  async coachShowPending() {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    try {
      const pending = await this.coachClient.getPendingJobs();
      if (pending.length === 0) {
        new import_obsidian.Notice("No pending queries");
        return;
      }
      const inboxFolder = `${this.settings.syncFolder}/Inbox`;
      await this.ensureFolder(inboxFolder);
      for (const job of pending) {
        const filename = `${inboxFolder}/${job.job_id.substring(0, 8)} - ${job.athlete_name || "Unknown"}.md`;
        if (!await this.app.vault.adapter.exists(filename)) {
          const content = this.createPendingQueryNote(job);
          await this.saveNote(filename, content);
        }
      }
      new import_obsidian.Notice(`${pending.length} pending queries in Inbox`);
      const firstFile = this.app.vault.getAbstractFileByPath(
        `${inboxFolder}/${pending[0].job_id.substring(0, 8)} - ${pending[0].athlete_name || "Unknown"}.md`
      );
      if (firstFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(firstFile);
      }
    } catch (error) {
      console.error("Error fetching pending:", error);
      new import_obsidian.Notice("Failed to fetch pending queries");
    }
  }
  async coachGenerateArticle(view) {
    var _a, _b;
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    const file = view.file;
    if (!file)
      return;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!(frontmatter == null ? void 0 : frontmatter.job_id)) {
      new import_obsidian.Notice("Not a pending query note (no job_id in frontmatter)");
      return;
    }
    const jobId = frontmatter.job_id;
    const query = frontmatter.query_text || await this.extractQueryFromNote(view);
    if (!query) {
      new import_obsidian.Notice("Could not find query text");
      return;
    }
    new import_obsidian.Notice("Claiming job and generating article...");
    try {
      await this.coachClient.claimJob(jobId);
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/research`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, user_id: "coach" })
      });
      const article = response.json.article || ((_a = response.json.research) == null ? void 0 : _a.article_raw) || "";
      const sources = response.json.sources || ((_b = response.json.research) == null ? void 0 : _b.sources) || [];
      let content = await this.app.vault.read(file);
      const placeholder = '*Run "Coach: Generate article" to populate this section*';
      if (content.includes(placeholder)) {
        content = content.replace(placeholder, article);
      } else {
        content += `

${article}`;
      }
      content = content.replace("status: pending", "status: draft");
      await this.app.vault.modify(file, content);
      const draftsFolder = `${this.settings.syncFolder}/Drafts`;
      await this.ensureFolder(draftsFolder);
      const newPath = `${draftsFolder}/${file.name}`;
      await this.app.fileManager.renameFile(file, newPath);
      new import_obsidian.Notice("Article generated! Edit and then push to athlete.");
    } catch (error) {
      console.error("Generate error:", error);
      new import_obsidian.Notice("Failed to generate article");
    }
  }
  async extractQueryFromNote(view) {
    const content = view.getViewData();
    const match = content.match(/## Question\n\n([\s\S]*?)(?=\n---|\n##|$)/);
    return match ? match[1].trim() : null;
  }
  async coachPushArticle(view) {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    const file = view.file;
    if (!file)
      return;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!(frontmatter == null ? void 0 : frontmatter.job_id)) {
      new import_obsidian.Notice("Not a query note (no job_id in frontmatter)");
      return;
    }
    const jobId = frontmatter.job_id;
    const content = await this.app.vault.read(file);
    const articleMatch = content.match(/## Generated Article\n\n([\s\S]*?)$/);
    const article = articleMatch ? articleMatch[1].trim() : "";
    if (!article || article.includes('Run "Coach: Generate article"')) {
      new import_obsidian.Notice("No article content to push");
      return;
    }
    new import_obsidian.Notice("Pushing to athlete...");
    try {
      const success = await this.coachClient.completeJob(jobId, article, []);
      if (success) {
        let updatedContent = content.replace("status: draft", "status: sent");
        updatedContent = updatedContent.replace("status: pending", "status: sent");
        await this.app.vault.modify(file, updatedContent);
        const sentFolder = `${this.settings.syncFolder}/Sent`;
        await this.ensureFolder(sentFolder);
        const newPath = `${sentFolder}/${file.name}`;
        await this.app.fileManager.renameFile(file, newPath);
        new import_obsidian.Notice("Pushed to athlete!");
      } else {
        new import_obsidian.Notice("Failed to push - check connection");
      }
    } catch (error) {
      console.error("Push error:", error);
      new import_obsidian.Notice("Failed to push article");
    }
  }
  async coachAddAthlete() {
    if (!this.coachClient) {
      new import_obsidian.Notice("Coach mode not configured");
      return;
    }
    new CoachAddAthleteModal(this.app, this).open();
  }
  async ensureFolder(path) {
    if (!await this.app.vault.adapter.exists(path)) {
      await this.app.vault.createFolder(path);
    }
  }
  async saveNote(path, content) {
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existing, content);
    } else {
      await this.app.vault.create(path, content);
    }
  }
  // Remote mode methods
  initRemoteMode() {
    this.queueClient = new RemoteQueueClient(
      this.settings.queueServiceUrl,
      this.settings.athleteToken
    );
    this.startResultPolling();
    this.updateStatusBar("Remote Mode");
  }
  startResultPolling() {
    if (this.pollIntervalId) {
      window.clearInterval(this.pollIntervalId);
    }
    this.pollIntervalId = window.setInterval(
      () => this.pollPendingJobs(),
      this.settings.pollInterval * 1e3
    );
  }
  async pollPendingJobs() {
    if (!this.queueClient || this.pendingJobs.size === 0)
      return;
    for (const [jobId, job] of this.pendingJobs.entries()) {
      if (job.status === "complete" || job.status === "error")
        continue;
      try {
        const status = await this.queueClient.checkStatus(jobId);
        if (status.status === "complete") {
          const result = await this.queueClient.getResult(jobId);
          if (result.error) {
            job.status = "error";
            new import_obsidian.Notice(`Query failed: ${result.error}`);
          } else {
            job.status = "complete";
            const filename = await this.saveArticleToVault(job.query, result.article);
            new import_obsidian.Notice(`Research ready! Saved to ${filename}`);
            this.pendingJobs.delete(jobId);
          }
        } else if (status.status === "processing") {
          job.status = "processing";
        } else if (status.status === "error") {
          job.status = "error";
          this.pendingJobs.delete(jobId);
        }
      } catch (error) {
        console.error(`Error polling job ${jobId}:`, error);
      }
    }
  }
  async submitToCoach(query, therapyContext) {
    if (!this.queueClient) {
      new import_obsidian.Notice("Remote mode not configured. Check settings.");
      return null;
    }
    try {
      const { jobId } = await this.queueClient.submitQuery(query, therapyContext);
      this.pendingJobs.set(jobId, {
        jobId,
        query,
        submittedAt: new Date(),
        status: "pending"
      });
      await this.createPendingJobNote(jobId, query);
      new import_obsidian.Notice("Query sent to coach! You'll be notified when ready.");
      return jobId;
    } catch (error) {
      console.error("Failed to submit query:", error);
      new import_obsidian.Notice("Failed to send query to coach. Check your connection.");
      return null;
    }
  }
  async createPendingJobNote(jobId, query) {
    const date = new Date().toISOString().split("T")[0];
    const time = new Date().toLocaleTimeString();
    const cleanQuery = query.substring(0, 40).replace(/[\\/:*?"<>|]/g, "-");
    const folder = `${this.settings.syncFolder}/Pending`;
    const folderObj = this.app.vault.getAbstractFileByPath(folder);
    if (!folderObj) {
      await this.app.vault.createFolder(folder);
    }
    const filename = `${folder}/${date} - ${cleanQuery}.md`;
    const content = `---
type: pending-query
job_id: ${jobId}
submitted: ${date} ${time}
status: pending
---

# Pending Query

**Submitted:** ${date} ${time}

**Query:** ${query}

---

*Waiting for coach to process...*

This note will be updated when results are ready.
`;
    await this.app.vault.create(filename, content);
  }
  showPendingJobsModal() {
    new PendingJobsModal(this.app, this).open();
  }
  async connectWithDiscord() {
    if (!this.settings.queueServiceUrl) {
      new import_obsidian.Notice("Configure Queue Service URL in settings first");
      return;
    }
    const authUrl = `${this.settings.queueServiceUrl}/auth/discord`;
    window.open(authUrl, "_blank");
    new import_obsidian.Notice("Complete Discord login in browser, then paste your token in settings");
  }
  async syncGraphToCoach() {
    if (!this.queueClient)
      return;
    try {
      const files = this.app.vault.getMarkdownFiles();
      const flipmodeFiles = files.filter((f) => f.path.startsWith(this.settings.syncFolder));
      const graphData = {
        sessions: [],
        queries: [],
        topics: []
      };
      for (const file of flipmodeFiles) {
        const cache = this.app.metadataCache.getFileCache(file);
        const fm = (cache == null ? void 0 : cache.frontmatter) || {};
        const type = fm.type;
        if (type === "training-session") {
          graphData.sessions.push({
            date: fm.date,
            tags: fm.tags || []
          });
        }
        if (type === "research" && fm.topic) {
          graphData.queries.push({
            topic: fm.topic,
            date: fm.date
          });
          graphData.topics.push(fm.topic);
        }
        if (type === "pending-query") {
          graphData.queries.push({
            topic: fm.query || file.basename,
            date: fm.submitted,
            pending: true
          });
        }
      }
      graphData.topics = [...new Set(graphData.topics)];
      await this.queueClient.syncGraph(graphData);
      new import_obsidian.Notice(`Synced: ${graphData.sessions.length} sessions, ${graphData.queries.length} queries`);
    } catch (error) {
      console.error("Graph sync error:", error);
      new import_obsidian.Notice("Failed to sync graph");
    }
  }
  onunload() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    if (this.pollIntervalId) {
      window.clearInterval(this.pollIntervalId);
    }
  }
  isRemoteMode() {
    return this.settings.mode === "remote" && !!this.queueClient;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  updateStatusBar(status) {
    this.statusBarItem.setText(`Flipmode: ${status}`);
  }
  // API Methods
  async apiRequest(endpoint, method = "GET", body) {
    const url = `${this.settings.serverUrl}/api/obsidian${endpoint}`;
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url,
        method,
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: body ? JSON.stringify(body) : void 0
      });
      return response.json;
    } catch (error) {
      console.error("Flipmode API error:", error);
      throw error;
    }
  }
  // Remote transcription for athletes (uses Heroku OpenAI Whisper)
  async remoteTranscribe(audioBlob) {
    var _a;
    if (!this.settings.queueServiceUrl || !this.settings.athleteToken) {
      throw new Error("Remote transcription requires queue service URL and athlete token");
    }
    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const dataUrl = reader.result;
        const base64Data = dataUrl.split(",")[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(audioBlob);
    });
    console.log("[Flipmode] Sending voice note to:", this.settings.queueServiceUrl);
    console.log("[Flipmode] Audio size:", audioBlob.size, "bytes, base64 length:", base64.length);
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.settings.queueServiceUrl}/api/voice/transcribe`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.athleteToken}`
      },
      body: JSON.stringify({ audio_base64: base64 })
    });
    if (response.status >= 400) {
      throw new Error(((_a = response.json) == null ? void 0 : _a.error) || "Transcription failed");
    }
    return response.json;
  }
  // Check voice note usage for today
  async getVoiceUsage() {
    if (!this.settings.queueServiceUrl || !this.settings.athleteToken) {
      throw new Error("Requires queue service URL and athlete token");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.settings.queueServiceUrl}/api/voice/usage`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.settings.athleteToken}`
      }
    });
    return response.json;
  }
  async checkConnection() {
    try {
      const response = await this.apiRequest("/health");
      if (response.status === "healthy") {
        this.updateStatusBar("Connected");
        return true;
      }
    } catch (error) {
      this.updateStatusBar("Disconnected");
    }
    return false;
  }
  // Save article to vault with frontmatter for graph view
  async saveArticleToVault(topic, articleContent) {
    const cleanTopic = topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
    const timestamp = new Date().toISOString().split("T")[0];
    const filename = `${this.settings.syncFolder}/${timestamp} - ${cleanTopic}.md`;
    const keywords = topic.toLowerCase().split(/\s+/).filter((w) => w.length > 3 && !["when", "from", "with", "that", "this", "what", "how"].includes(w)).slice(0, 5);
    const frontmatter = `---
type: research
topic: "[[${cleanTopic}]]"
date: ${timestamp}
tags: [bjj, flipmode${keywords.map((k) => `, ${k}`).join("")}]
---

`;
    const relatedLinks = `

---
## Related
- Topic: [[${cleanTopic}]]
- Training Plan: [[${timestamp} - ${cleanTopic} Plan]]

*Generated by Flipmode*
`;
    const fullContent = frontmatter + articleContent + relatedLinks;
    const folder = this.app.vault.getAbstractFileByPath(this.settings.syncFolder);
    if (!folder) {
      await this.app.vault.createFolder(this.settings.syncFolder);
    }
    const existingFile = this.app.vault.getAbstractFileByPath(filename);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, fullContent);
    } else {
      await this.app.vault.create(filename, fullContent);
    }
    return filename;
  }
  // Dive Deeper on a training session - uses notes as context
  async diveDeepOnSession(view) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    let topic = "";
    let fileType = "";
    let rlmSessionId = "";
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      const topicMatch = frontmatter.match(/topic:\s*"?\[\[([^\]]+)\]\]"?/) || frontmatter.match(/topic:\s*"([^"]+)"/);
      const typeMatch = frontmatter.match(/type:\s*(\S+)/);
      const rlmMatch = frontmatter.match(/rlm_session_id:\s*"([^"]+)"/);
      if (topicMatch)
        topic = topicMatch[1];
      if (typeMatch)
        fileType = typeMatch[1];
      if (rlmMatch)
        rlmSessionId = rlmMatch[1];
    }
    const reflectionSections = [];
    const whatWorkedMatch = content.match(/\*\*What worked:\*\*\s*\n([^\n*]+)/g);
    const whatToAdjustMatch = content.match(/\*\*What to adjust:\*\*\s*\n([^\n*]+)/g);
    const keyInsightMatch = content.match(/\*\*Key insight:\*\*\s*\n([^\n*]+)/g);
    if (whatWorkedMatch) {
      whatWorkedMatch.forEach((m) => {
        const text = m.replace("**What worked:**", "").trim();
        if (text && text.length > 2)
          reflectionSections.push(`What worked: ${text}`);
      });
    }
    if (whatToAdjustMatch) {
      whatToAdjustMatch.forEach((m) => {
        const text = m.replace("**What to adjust:**", "").trim();
        if (text && text.length > 2)
          reflectionSections.push(`Need to adjust: ${text}`);
      });
    }
    if (keyInsightMatch) {
      keyInsightMatch.forEach((m) => {
        const text = m.replace("**Key insight:**", "").trim();
        if (text && text.length > 2)
          reflectionSections.push(`Key insight: ${text}`);
      });
    }
    const notesMatch = content.match(/## Notes\n([\s\S]*?)(?=\n##|$)/);
    if (notesMatch && notesMatch[1].trim().length > 10) {
      reflectionSections.push(`Notes: ${notesMatch[1].trim().substring(0, 500)}`);
    }
    if (!topic) {
      const titleMatch = content.match(/# (?:Training Plan:|Research:)?\s*(.+)/);
      if (titleMatch)
        topic = titleMatch[1].trim();
    }
    if (!topic) {
      new import_obsidian.Notice("Could not find topic in this file");
      return;
    }
    const sessionContext = reflectionSections.length > 0 ? reflectionSections.join("\n") : "Training session completed";
    const modal = new DiveDeepModal(this.app, this, topic, sessionContext, rlmSessionId);
    modal.open();
    if (rlmSessionId) {
      new import_obsidian.Notice("Deep Dive session loaded!", 2e3);
    }
  }
  // Generate Training Review from Training Notes (coach side)
  async generateTrainingReview(view) {
    var _a;
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Is this a Training Notes file?");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const typeMatch = frontmatter.match(/type:\s*(\S+)/);
    if (!typeMatch || typeMatch[1] !== "training-notes") {
      new import_obsidian.Notice("This command only works on Training Notes files");
      return;
    }
    const sessionIdMatch = frontmatter.match(/session_id:\s*"([^"]+)"/);
    const sessionId = sessionIdMatch ? sessionIdMatch[1] : null;
    const focusMatch = frontmatter.match(/focus:\s*"([^"]+)"/);
    const focus = focusMatch ? focusMatch[1] : "general";
    const dateMatch = frontmatter.match(/date:\s*(\S+)/);
    const dateStr = dateMatch ? dateMatch[1] : new Date().toISOString().split("T")[0];
    const seasonMatch = frontmatter.match(/season:\s*(\d+)/);
    const episodeMatch = frontmatter.match(/episode:\s*(\d+)/);
    const season = seasonMatch ? parseInt(seasonMatch[1]) : this.settings.currentSeason;
    const episode = episodeMatch ? parseInt(episodeMatch[1]) : this.settings.currentEpisode;
    const folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || `${this.settings.syncFolder}/Athletes/Unknown/Season ${season}/Session ${episode}`;
    const notesFilename = file.basename;
    const reviewFilename = notesFilename.replace("TrainingNotes", "TrainingReview");
    const strugglesMatch = content.match(/## Struggles[\s\S]*?(?=##|$)/);
    const struggles = strugglesMatch ? strugglesMatch[0].replace("## Struggles", "").trim() : focus;
    new import_obsidian.Notice("Generating Training Review...", 3e3);
    try {
      const researchResponse = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/coach-review`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          query: struggles || focus,
          session_context: `Training session: ${focus}`
        })
      });
      const research = researchResponse.json;
      const articleContent = research.article || research.article_raw || "Research generation failed.";
      const topic = research.topic || focus;
      const rlmSessionId = research.rlm_session_id || "";
      const conversationUuid = research.conversation_uuid || "";
      const sourceCount = research.source_count || 0;
      const reviewContent = `---
type: training-review
season: ${season}
episode: ${episode}
date: ${dateStr}
focus: "${focus}"
topic: "${topic}"
training_notes: "[[${notesFilename}]]"
rlm_session_id: "${rlmSessionId}"
conversation_uuid: "${conversationUuid}"
source_count: ${sourceCount}
tags: [bjj, training-review, season-${season}, ${focus.replace(/_/g, "-")}]
---

# Training Review: ${topic}

${articleContent}

---
## Deep Dive
${rlmSessionId ? `> [!tip] Deep Dive Available
> Select text and right-click \u2192 "Dive Deeper" to explore specific topics.
> Or [View in Oracle](http://localhost:5002/c/${conversationUuid}) for the full interactive experience.` : "> No RLM session available for Deep Dive."}

## Links
- Training Notes: [[${notesFilename}]]
${conversationUuid ? `- [View in Oracle](http://localhost:5002/c/${conversationUuid})` : ""}
`;
      const reviewPath = `${folderPath}/${reviewFilename}.md`;
      const existingReview = this.app.vault.getAbstractFileByPath(reviewPath);
      if (existingReview instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingReview, reviewContent);
      } else {
        await this.app.vault.create(reviewPath, reviewContent);
      }
      await this.addTrainingReviewLink(file, reviewFilename);
      new import_obsidian.Notice(`Training Review saved: ${reviewFilename}`, 5e3);
      const reviewFile = this.app.vault.getAbstractFileByPath(reviewPath);
      if (reviewFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(reviewFile);
      }
    } catch (error) {
      console.error("Training review generation error:", error);
      new import_obsidian.Notice("Failed to generate Training Review. Check console for details.", 5e3);
    }
  }
  // Generate Training Review from selected text (right-click context menu)
  async generateTrainingReviewFromSelection(editor, view, selection) {
    var _a;
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const query = selection.trim();
    if (!query) {
      new import_obsidian.Notice("No text selected");
      return;
    }
    new import_obsidian.Notice(`Generating Training Review...`, 3e3);
    try {
      const content = await this.app.vault.read(file);
      const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      let sessionContext = "";
      let focus = "research";
      let dateStr = new Date().toISOString().split("T")[0];
      let season = this.settings.currentSeason;
      let episode = this.settings.currentEpisode;
      let athleteName = this.settings.athleteName || "Athlete";
      if (frontmatterMatch) {
        const frontmatter = frontmatterMatch[1];
        const focusMatch = frontmatter.match(/focus:\s*"([^"]+)"/);
        if (focusMatch)
          focus = focusMatch[1];
        const dateMatch = frontmatter.match(/date:\s*(\S+)/);
        if (dateMatch)
          dateStr = dateMatch[1];
        const seasonMatch = frontmatter.match(/season:\s*(\d+)/);
        if (seasonMatch)
          season = parseInt(seasonMatch[1]);
        const episodeMatch = frontmatter.match(/episode:\s*(\d+)/);
        if (episodeMatch)
          episode = parseInt(episodeMatch[1]);
        const strugglesMatch = content.match(/## Struggles[\s\S]*?(?=##|$)/);
        if (strugglesMatch) {
          sessionContext = strugglesMatch[0].replace("## Struggles", "").trim();
        }
      }
      const researchResponse = await (0, import_obsidian.requestUrl)({
        url: `${this.settings.serverUrl}/api/obsidian/coach-review`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiToken}`
        },
        body: JSON.stringify({
          query,
          athlete_name: athleteName,
          session_context: sessionContext
        })
      });
      const research = researchResponse.json;
      const articleContent = research.article_raw || research.article || "Research generation failed.";
      const topic = research.topic || query;
      const rlmSessionId = research.rlm_session_id || "";
      const sourceCount = research.source_count || 0;
      const articleSections = research.article_sections || [];
      const conversationUuid = research.conversation_uuid || "";
      const oracleUrl = conversationUuid ? `http://localhost:5002/c/${conversationUuid}` : `http://localhost:5002/?q=${encodeURIComponent(topic)}`;
      let audioSection = "";
      if (articleSections.length > 0) {
        audioSection = `## Listen to Review
`;
        audioSection += `> [!tip] Audio Player Available
`;
        audioSection += `> **${articleSections.length} audio sections** ready to play.
`;
        audioSection += `> Press \`Ctrl/Cmd + P\` and search "Open Audio Player" to listen.

`;
      }
      const safeQuery = query.substring(0, 40).replace(/[^a-zA-Z0-9]/g, "_").replace(/_+/g, "_");
      const reviewFilename = `TrainingReview-${dateStr}-${safeQuery}`;
      const folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || `${this.settings.syncFolder}/Athletes/${athleteName}/Season ${season}/Session ${episode}`;
      const audioSectionsYaml = articleSections.length > 0 ? `audio_sections_data:
${articleSections.map((s) => `  - title: "${s.title.replace(/"/g, "'")}"
    audio_url: "${s.audio_url}"`).join("\n")}` : "audio_sections_data: []";
      const reviewContent = `---
type: training-review
status: draft
season: ${season}
episode: ${episode}
date: ${dateStr}
query: "${query.replace(/"/g, "'")}"
topic: "${topic.replace(/"/g, "'")}"
source_file: "[[${file.basename}]]"
rlm_session_id: "${rlmSessionId}"
conversation_uuid: "${conversationUuid}"
source_count: ${sourceCount}
audio_sections: ${articleSections.length}
${audioSectionsYaml}
pipeline: "${research.pipeline || "multi_thinker"}"
thinkers_used: ${research.thinkers_used || 0}
tags: [bjj, training-review, season-${season}, research, draft]
---

# Training Review: ${topic}
> [!warning] DRAFT - Review and edit before publishing
> Use command "Flipmode: Publish Training Review" when ready to send to athlete.
> [View with Videos](${oracleUrl}) - Open in Oracle to verify sources

${audioSection}> **Query:** ${query}

${articleContent}

---
## Deep Dive
${rlmSessionId ? `> [!tip] Deep Dive Available
> Select text and right-click \u2192 "Dive Deeper" to explore specific topics.
> Or [View in Oracle](http://localhost:5002/c/${conversationUuid}) for the full interactive experience.` : "> No RLM session available for Deep Dive."}

## Links
- Source: [[${file.basename}]]
${conversationUuid ? `- [View in Oracle](http://localhost:5002/c/${conversationUuid})` : ""}
`;
      const reviewPath = `${folderPath}/${reviewFilename}.md`;
      const existingReview = this.app.vault.getAbstractFileByPath(reviewPath);
      if (existingReview instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingReview, reviewContent);
      } else {
        await this.app.vault.create(reviewPath, reviewContent);
      }
      await this.addTrainingReviewLink(file, reviewFilename);
      new import_obsidian.Notice(`Training Review saved: ${reviewFilename}`, 5e3);
      const reviewFile = this.app.vault.getAbstractFileByPath(reviewPath);
      if (reviewFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf("split").openFile(reviewFile);
      }
    } catch (error) {
      console.error("Training review from selection error:", error);
      new import_obsidian.Notice("Failed to generate Training Review. Check console for details.", 5e3);
    }
  }
  // Add backlink to source file for two-way graph connection
  async addTrainingReviewLink(sourceFile, reviewFilename) {
    try {
      const content = await this.app.vault.read(sourceFile);
      const reviewLink = `[[${reviewFilename}]]`;
      if (content.includes("## Training Reviews")) {
        if (!content.includes(reviewLink)) {
          const updatedContent = content.replace(
            /## Training Reviews\n/,
            `## Training Reviews
- ${reviewLink}
`
          );
          await this.app.vault.modify(sourceFile, updatedContent);
        }
      } else {
        const updatedContent = content + `
## Training Reviews
- ${reviewLink}
`;
        await this.app.vault.modify(sourceFile, updatedContent);
      }
    } catch (error) {
      console.error("Failed to add backlink:", error);
    }
  }
  // Dive Deeper - explore selected text using Oracle's RLM context
  async diveDeeper(editor, view, selection) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const focusText = selection.trim();
    if (!focusText) {
      new import_obsidian.Notice("No text selected");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Dive Deeper requires a Training Review file.");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const sessionIdMatch = frontmatter.match(/rlm_session_id:\s*"([^"]+)"/);
    if (!sessionIdMatch || !sessionIdMatch[1]) {
      new import_obsidian.Notice("No RLM session found. Generate a Training Review first.");
      return;
    }
    const sessionId = sessionIdMatch[1];
    const convUuidMatch = frontmatter.match(/conversation_uuid:\s*"([^"]+)"/);
    const conversationUuid = convUuidMatch ? convUuidMatch[1] : null;
    new import_obsidian.Notice(`Diving deeper on: ${focusText.substring(0, 40)}...`, 3e3);
    try {
      const oracleUrl = "http://localhost:5002";
      const response = await (0, import_obsidian.requestUrl)({
        url: `${oracleUrl}/api/internal/deep-dive`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session_id: sessionId,
          focus_text: focusText,
          conversation_uuid: conversationUuid
        })
      });
      const result = response.json;
      if (result.error) {
        new import_obsidian.Notice(`Deep Dive failed: ${result.error}`, 5e3);
        return;
      }
      const deepDiveContent = result.deep_dive_raw || result.deep_dive_html || "Deep Dive generation failed.";
      const focusArea = result.focus_area || focusText.substring(0, 50);
      const newSourcesCount = result.new_sources_count || 0;
      const timestamp = new Date().toLocaleTimeString();
      const deepDiveSection = `

---
## Deep Dive: ${focusArea}
*Generated at ${timestamp} | ${newSourcesCount} new sources*

${deepDiveContent}
`;
      const updatedContent = content + deepDiveSection;
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian.Notice(`Deep Dive complete: ${focusArea} (${newSourcesCount} new sources)`, 5e3);
      const newCursor = { line: editor.lineCount() - 1, ch: 0 };
      editor.setCursor(newCursor);
      editor.scrollIntoView({ from: newCursor, to: newCursor }, true);
    } catch (error) {
      console.error("Deep Dive error:", error);
      new import_obsidian.Notice("Deep Dive failed. Check console for details.", 5e3);
    }
  }
  // Generate Skill Development sessions from selected text (right-click context menu)
  // Creates 3 separate nodes: SkillDev1, SkillDev2, SkillDev3
  // Uses CLA (Constraints-Led Approach) science via Oracle's skill-dev endpoint
  async generateTrainingPlanFromSelection(editor, view, selection) {
    var _a;
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const fullSelection = selection.trim();
    if (!fullSelection) {
      new import_obsidian.Notice("No text selected");
      return;
    }
    const firstLine = fullSelection.split("\n")[0].replace(/^#+\s*/, "").trim();
    const shortTopic = firstLine.substring(0, 60);
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found. Skill Development requires a Training Review file.");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const sessionIdMatch = frontmatter.match(/rlm_session_id:\s*"([^"]+)"/);
    if (!sessionIdMatch || !sessionIdMatch[1]) {
      new import_obsidian.Notice("No RLM session found. Generate a Training Review first.");
      return;
    }
    const sessionId = sessionIdMatch[1];
    new import_obsidian.Notice(`Generating CLA Skill Development for: ${shortTopic}...`, 5e3);
    try {
      const oracleUrl = "http://localhost:5002";
      const response = await (0, import_obsidian.requestUrl)({
        url: `${oracleUrl}/api/internal/skill-dev`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session_id: sessionId,
          topic: fullSelection
          // Send full selection for Oracle context
        })
      });
      const plan = response.json;
      if (plan.error) {
        new import_obsidian.Notice(`Skill Development failed: ${plan.error}`, 5e3);
        return;
      }
      if (!plan.sessions || plan.sessions.length === 0) {
        new import_obsidian.Notice("Failed to generate skill development sessions");
        return;
      }
      const dateStr = new Date().toISOString().split("T")[0];
      const safeTopic = shortTopic.substring(0, 25).replace(/[^a-zA-Z0-9]/g, "_").replace(/_+/g, "_");
      const folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || this.settings.syncFolder;
      const folderExists = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folderExists) {
        await this.app.vault.createFolder(folderPath);
      }
      const createdFiles = [];
      for (let i = 0; i < plan.sessions.length; i++) {
        const session = plan.sessions[i];
        const sessionNum = session.session_number || i + 1;
        const filename = `SkillDev${sessionNum}-${dateStr}-${safeTopic}`;
        const sessionMarkdown = this.buildCLASkillDevMarkdown(
          shortTopic,
          session,
          file.basename,
          createdFiles
        );
        const filePath = `${folderPath}/${filename}.md`;
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile instanceof import_obsidian.TFile) {
          await this.app.vault.modify(existingFile, sessionMarkdown);
        } else {
          await this.app.vault.create(filePath, sessionMarkdown);
        }
        createdFiles.push(filename);
      }
      await this.addSkillDevLinks(file, createdFiles);
      new import_obsidian.Notice(`Created ${plan.sessions.length} CLA Skill Dev sessions for ${shortTopic}`, 5e3);
      const firstFile = this.app.vault.getAbstractFileByPath(`${folderPath}/${createdFiles[0]}.md`);
      if (firstFile instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf("split").openFile(firstFile);
      }
    } catch (error) {
      console.error("Skill development generation error:", error);
      new import_obsidian.Notice("Failed to generate Skill Development. Check console for details.", 5e3);
    }
  }
  // Build CLA-based skill development markdown from Oracle response
  buildCLASkillDevMarkdown(topic, session, sourceFile, siblingFiles) {
    const dateStr = new Date().toISOString().split("T")[0];
    const cleanTopic = topic.replace(/"/g, "'");
    const sessionNum = session.session_number || 1;
    const prevFile = sessionNum > 1 ? siblingFiles[sessionNum - 2] : null;
    const nextFile = sessionNum < 3 ? siblingFiles[sessionNum] : null;
    const sourceLink = sessionNum === 1 ? `
source: "[[${sourceFile}]]"` : "";
    const sourceLinkBody = sessionNum === 1 ? `- Source: [[${sourceFile}]]
` : "";
    let roundsList = "";
    if (session.rounds_text) {
      roundsList = session.rounds_text;
    } else if (session.rounds && session.rounds.length > 0) {
      for (const round of session.rounds) {
        const desc = round.description || round.start || "Positional sparring";
        const reason = round.reasoning || round.because || "";
        roundsList += `- **Round ${round.round}:** ${desc}`;
        if (reason)
          roundsList += ` \u2014 ${reason}`;
        roundsList += "\n";
      }
    } else {
      roundsList = "See source research for round details.\n";
    }
    const goals = session.goals && session.goals.length > 0 ? session.goals.map((g) => `- [ ] ${g}`).join("\n") : "- [ ] Complete all 5 rounds\n- [ ] Note what worked";
    return `---
type: skill-development
methodology: CLA
session: ${sessionNum}
topic: "${cleanTopic}"
date: ${dateStr}
resistance: "${session.resistance_level || "50%"}"
status: pending${sourceLink}
tags: [bjj, skill-dev, cla, session-${sessionNum}]
---

# SkillDev ${sessionNum}: ${session.title || "Session " + sessionNum}

**Resistance:** ${session.resistance_level || "50%"}
**Focus:** ${session.focus || "Skill development"}

${prevFile ? `Previous: [[${prevFile}]]` : ""}${prevFile && nextFile ? " | " : ""}${nextFile ? `Next: [[${nextFile}]]` : ""}

## Positional Sparring Rounds

${roundsList}

## Goals

${goals}

## Post-Session Notes

**What worked:**


**What to adjust:**


**Key insight:**

---

${sourceLinkBody}
`;
  }
  // Add backlink to source file - ONLY links to SkillDev1 for linear chain
  // Graph structure: TrainingReview  SkillDev1  SkillDev2  SkillDev3
  async addSkillDevLinks(sourceFile, filenames) {
    try {
      const content = await this.app.vault.read(sourceFile);
      const firstLink = `[[${filenames[0]}]]`;
      if (content.includes("## Skill Development")) {
        if (!content.includes(filenames[0])) {
          const updatedContent = content.replace(
            /## Skill Development\n/,
            `## Skill Development
- ${firstLink}
`
          );
          await this.app.vault.modify(sourceFile, updatedContent);
        }
      } else {
        const updatedContent = content + `
## Skill Development
- ${firstLink}
`;
        await this.app.vault.modify(sourceFile, updatedContent);
      }
    } catch (error) {
      console.error("Failed to add skill dev backlinks:", error);
    }
  }
  // Publish Training Review to athlete
  async publishTrainingReview(view) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const content = await this.app.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const frontmatter = frontmatterMatch[1];
    const typeMatch = frontmatter.match(/type:\s*(\S+)/);
    if (!typeMatch || typeMatch[1] !== "training-review") {
      new import_obsidian.Notice("This command only works on Training Review files");
      return;
    }
    const statusMatch = frontmatter.match(/status:\s*(\S+)/);
    if (statusMatch && statusMatch[1] === "published") {
      new import_obsidian.Notice("This review is already published");
      return;
    }
    let updatedContent = content.replace(/status:\s*draft/, "status: published");
    updatedContent = updatedContent.replace(/tags:\s*\[(.*?)\]/, (match, tags) => {
      const tagList = tags.split(",").map((t) => t.trim()).filter((t) => t !== "draft");
      tagList.push("published");
      return `tags: [${tagList.join(", ")}]`;
    });
    updatedContent = updatedContent.replace(/> \[!warning\] DRAFT.*\n> Use command.*\n\n?/g, "");
    updatedContent = updatedContent.replace(/\[([^\]]+)\]\(http[^)]+\)/g, "$1");
    const publishDate = new Date().toISOString().split("T")[0];
    updatedContent = updatedContent.replace(
      /# Training Review:/,
      `> [!success] Published ${publishDate}

# Training Review:`
    );
    await this.app.vault.modify(file, updatedContent);
    new import_obsidian.Notice("Training Review published to athlete!", 5e3);
  }
  // Open Audio Player for Training Review files
  async openAudioPlayer(view) {
    const file = view.file;
    if (!file) {
      new import_obsidian.Notice("No file open");
      return;
    }
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter) {
      new import_obsidian.Notice("No frontmatter found");
      return;
    }
    const audioSectionsData = frontmatter.audio_sections_data;
    if (!audioSectionsData || audioSectionsData.length === 0) {
      new import_obsidian.Notice("No audio sections found in this file");
      return;
    }
    const topic = frontmatter.topic || frontmatter.query || file.basename;
    const rlmSessionId = frontmatter.rlm_session_id || null;
    const audioModal = new AudioPlayerModal(
      this.app,
      this,
      topic,
      audioSectionsData,
      rlmSessionId,
      "",
      // No article content needed - just playing audio
      []
      // No sources needed
    );
    audioModal.open();
  }
  // Sync Methods
  async syncWithFlipmode() {
    const connected = await this.checkConnection();
    if (!connected) {
      new import_obsidian.Notice("Cannot connect to Flipmode server");
      return;
    }
    new import_obsidian.Notice("Syncing with Flipmode...");
    try {
      const userId = this.settings.apiToken.substring(0, 8) || "default";
      const manifest = await this.apiRequest(`/sync/manifest/${userId}`);
      await this.ensureFoldersExist(manifest.directories);
      let syncedCount = 0;
      for (const file of manifest.files) {
        const synced = await this.syncFile(file);
        if (synced)
          syncedCount++;
      }
      new import_obsidian.Notice(`Synced ${syncedCount} files from Flipmode`);
    } catch (error) {
      console.error("Sync error:", error);
      new import_obsidian.Notice("Sync failed - check console for details");
    }
  }
  async ensureFoldersExist(paths) {
    for (const path of paths) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (!folder) {
        await this.app.vault.createFolder(path);
      }
    }
  }
  async syncFile(file) {
    try {
      const existingFile = this.app.vault.getAbstractFileByPath(file.path);
      if (existingFile instanceof import_obsidian.TFile) {
        const currentContent = await this.app.vault.read(existingFile);
        if (this.computeChecksum(currentContent) !== file.checksum) {
          await this.app.vault.modify(existingFile, file.content);
          return true;
        }
        return false;
      } else {
        await this.app.vault.create(file.path, file.content);
        return true;
      }
    } catch (error) {
      console.error(`Error syncing file ${file.path}:`, error);
      return false;
    }
  }
  computeChecksum(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(16).substring(0, 16);
  }
  startAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    this.syncIntervalId = window.setInterval(
      () => this.syncWithFlipmode(),
      this.settings.syncInterval * 60 * 1e3
    );
  }
  // UI Methods
  async showFlipmodeMenu() {
    new FlipmodeMenuModal(this.app, this).open();
  }
  async showResearchModal() {
    new ResearchModal(this.app, this).open();
  }
  async showVoiceNoteModal() {
    new VoiceNoteModal(this.app, this).open();
  }
  // Voice session method - Step 1: transcribe audio
  async startVoiceSession(audioBase64) {
    try {
      const response = await this.apiRequest("/session", "POST", {
        user_id: this.settings.userId,
        audio_base64: audioBase64,
        audio_format: "webm"
      });
      return response;
    } catch (error) {
      console.error("Voice session error:", error);
      throw error;
    }
  }
  // Voice session method - Step 2: confirm/edit transcript and process
  async confirmVoiceSession(confirmedText) {
    try {
      const response = await this.apiRequest("/session", "POST", {
        user_id: this.settings.userId,
        confirmed_text: confirmedText
      });
      return response;
    } catch (error) {
      console.error("Confirm voice session error:", error);
      throw error;
    }
  }
  // Continue conversation - Step 1: send audio for transcription
  async respondToSession(sessionId, text, audioBase64, selectedOption) {
    try {
      const body = {
        session_id: sessionId,
        user_id: this.settings.userId
      };
      if (audioBase64) {
        body.audio_base64 = audioBase64;
        body.audio_format = "webm";
      } else if (text) {
        body.text = text;
      } else if (selectedOption) {
        body.selected_option = selectedOption;
      }
      const response = await this.apiRequest("/respond", "POST", body);
      return response;
    } catch (error) {
      console.error("Respond error:", error);
      throw error;
    }
  }
  // Continue conversation - Step 2: confirm transcript and process
  async confirmRespondToSession(sessionId, confirmedText) {
    try {
      const response = await this.apiRequest("/respond", "POST", {
        session_id: sessionId,
        user_id: this.settings.userId,
        confirmed_text: confirmedText
      });
      return response;
    } catch (error) {
      console.error("Confirm respond error:", error);
      throw error;
    }
  }
  async saveSessionToVault(session) {
    var _a, _b, _c;
    try {
      const date = new Date().toISOString().split("T")[0];
      const folder = this.settings.syncFolder + "/Sessions";
      await this.ensureFoldersExist([folder]);
      let content = `---
type: training-session
date: ${date}
session_id: ${session.session_id}
tags: [bjj, training, voice-note]
---

# Training Session - ${date}

## Your Notes (Transcribed)

${session.transcript}

## Topics Identified

`;
      if (session.extracted_topics) {
        const topics = session.extracted_topics;
        if ((_a = topics.work_on) == null ? void 0 : _a.length) {
          content += `### Work On
`;
          for (const t of topics.work_on) {
            content += `- **${t.topic}**: ${t.context || ""}
`;
          }
          content += "\n";
        }
        if ((_b = topics.wins) == null ? void 0 : _b.length) {
          content += `### Wins
`;
          for (const t of topics.wins) {
            content += `- **${t.topic}**: ${t.context || ""}
`;
          }
          content += "\n";
        }
      }
      content += `## Coach Response

${session.response_text}

`;
      if ((_c = session.options) == null ? void 0 : _c.length) {
        content += `## Next Steps

`;
        for (const opt of session.options) {
          content += `- [ ] ${opt.label}
`;
        }
      }
      const filename = `${folder}/${date}-${session.session_id.substring(0, 8)}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filename);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filename, content);
      }
      const file = this.app.vault.getAbstractFileByPath(filename);
      if (file instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
      return filename;
    } catch (error) {
      console.error("Error saving session:", error);
      throw error;
    }
  }
  insertTrainingTemplate(editor) {
    const date = new Date().toISOString().split("T")[0];
    const template = `---
type: training-note
date: ${date}
tags: [bjj, training]
---

# Training Notes - ${date}

## What Worked Well


## What Needs Work


## Techniques Practiced


## Questions for Flipmode

`;
    editor.replaceSelection(template);
  }
  // Research method
  async research(topic, context = "") {
    try {
      const response = await this.apiRequest("/research", "POST", {
        topic,
        context,
        max_sources: 10
      });
      return response;
    } catch (error) {
      console.error("Research error:", error);
      throw error;
    }
  }
  async saveResearchToVault(topic, research) {
    try {
      const mdResponse = await this.apiRequest("/sync/research", "POST", {
        topic,
        article: research.article,
        sources: research.sources,
        context: research.context
      });
      const folder = this.settings.syncFolder + "/Research";
      await this.ensureFoldersExist([folder]);
      await this.syncFile({
        path: mdResponse.path,
        content: mdResponse.content,
        checksum: mdResponse.checksum
      });
      const file = this.app.vault.getAbstractFileByPath(mdResponse.path);
      if (file instanceof import_obsidian.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
      return mdResponse.path;
    } catch (error) {
      console.error("Error saving research:", error);
      throw error;
    }
  }
};
var FlipmodeMenuModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-modal");
    contentEl.createEl("h2", { text: "Flipmode" });
    const statusEl = contentEl.createEl("p", {
      text: "Checking connection...",
      cls: "flipmode-status"
    });
    this.plugin.checkConnection().then((connected) => {
      statusEl.setText(connected ? "Connected to Flipmode" : "Not connected");
      statusEl.addClass(connected ? "connected" : "disconnected");
    });
    const buttonContainer = contentEl.createDiv({ cls: "flipmode-buttons" });
    new import_obsidian.Setting(buttonContainer).setName("Research Technique").setDesc("Search the Flipmode for technique information").addButton((btn) => btn.setButtonText("Research").setCta().onClick(() => {
      this.close();
      this.plugin.showResearchModal();
    }));
    new import_obsidian.Setting(buttonContainer).setName("Sync with Flipmode").setDesc("Download latest sessions and notes").addButton((btn) => btn.setButtonText("Sync").onClick(() => {
      this.close();
      this.plugin.syncWithFlipmode();
    }));
    new import_obsidian.Setting(buttonContainer).setName("Settings").setDesc("Configure Flipmode connection").addButton((btn) => btn.setButtonText("Open Settings").onClick(() => {
      this.close();
      this.app.setting.open();
      this.app.setting.openTabById("flipmode");
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ResearchModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-research-modal");
    contentEl.createEl("h2", { text: "Research a Technique" });
    new import_obsidian.Setting(contentEl).setName("Technique").setDesc("What technique do you want to research?").addText((text) => {
      this.topicInput = text.inputEl;
      text.setPlaceholder("e.g., knee slice pass, arm drag, berimbolo");
    });
    new import_obsidian.Setting(contentEl).setName("Context (optional)").setDesc("Any specific situation or problem?").addTextArea((text) => {
      this.contextInput = text.inputEl;
      text.setPlaceholder("e.g., defending against it, from closed guard, against bigger opponents");
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Search Flipmode").setCta().onClick(() => this.doResearch()));
    this.resultEl = contentEl.createDiv({ cls: "flipmode-results" });
  }
  async doResearch() {
    const topic = this.topicInput.value.trim();
    if (!topic) {
      new import_obsidian.Notice("Please enter a technique to research");
      return;
    }
    this.resultEl.empty();
    this.resultEl.createEl("p", { text: "Searching Flipmode..." });
    try {
      const research = await this.plugin.research(topic, this.contextInput.value);
      this.resultEl.empty();
      if (research.source_count > 0) {
        this.resultEl.createEl("h3", {
          text: `Found ${research.source_count} sources`
        });
        const previewEl = this.resultEl.createEl("div", { cls: "research-preview" });
        previewEl.createEl("p", {
          text: research.article.substring(0, 300) + "..."
        });
        const sourcesList = this.resultEl.createEl("ul", { cls: "sources-list" });
        for (const source of research.sources.slice(0, 5)) {
          sourcesList.createEl("li", {
            text: `${source.instructor} - ${source.title}`
          });
        }
        new import_obsidian.Setting(this.resultEl).addButton((btn) => btn.setButtonText("Save to Vault").setCta().onClick(async () => {
          try {
            const path = await this.plugin.saveResearchToVault(topic, research);
            new import_obsidian.Notice(`Saved to ${path}`);
            this.close();
          } catch (error) {
            new import_obsidian.Notice("Failed to save research");
          }
        }));
      } else {
        this.resultEl.createEl("p", {
          text: "No sources found. Try a different search term."
        });
      }
    } catch (error) {
      this.resultEl.empty();
      this.resultEl.createEl("p", {
        text: "Research failed. Check your connection settings.",
        cls: "error"
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var VoiceNoteModal = class extends import_obsidian.Modal {
  // Track current session for continuations
  constructor(app, plugin) {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.timerInterval = null;
    this.recordingStartTime = 0;
    this.currentSessionId = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-voice-modal");
    const headerContainer = contentEl.createDiv({ cls: "flipmode-header" });
    headerContainer.style.textAlign = "center";
    headerContainer.style.margin = "0 0 15px 0";
    const headerImg = headerContainer.createEl("img");
    headerImg.src = FLIPMODE_HEADER_BASE64;
    headerImg.alt = "FLIPMODE";
    headerImg.style.maxWidth = "100%";
    headerImg.style.height = "auto";
    this.timerEl = contentEl.createEl("div", {
      text: "00:00",
      cls: "voice-timer"
    });
    this.timerEl.style.fontSize = "2em";
    this.timerEl.style.textAlign = "center";
    this.timerEl.style.margin = "20px 0";
    this.timerEl.style.fontFamily = "monospace";
    this.statusEl = contentEl.createEl("p", {
      text: "Click to start recording",
      cls: "voice-status"
    });
    this.statusEl.style.textAlign = "center";
    this.statusEl.style.color = "var(--text-muted)";
    this.resultEl = contentEl.createDiv({ cls: "voice-results" });
    const btnContainer = contentEl.createDiv({ cls: "voice-btn-container" });
    btnContainer.style.textAlign = "center";
    btnContainer.style.marginTop = "20px";
    this.recordBtn = btnContainer.createEl("button", {
      text: "START RECORDING"
    });
    this.recordBtn.style.cssText = `
            font-size: 16px;
            font-weight: 600;
            padding: 16px 32px;
            min-width: 200px;
            border: none;
            border-radius: 8px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
            transition: background 0.2s;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        `;
    this.recordBtn.onclick = () => this.toggleRecording();
  }
  async toggleRecording() {
    if (this.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  async startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.audioChunks = [];
      this.mediaRecorder = new MediaRecorder(stream, {
        mimeType: "audio/webm;codecs=opus"
      });
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = () => {
        stream.getTracks().forEach((track) => track.stop());
        this.processRecording();
      };
      this.mediaRecorder.start(1e3);
      this.isRecording = true;
      this.recordingStartTime = Date.now();
      this.recordBtn.setText("STOP");
      this.recordBtn.style.background = "var(--text-error)";
      this.statusEl.setText("Recording... speak now");
      this.statusEl.style.color = "var(--text-error)";
      this.timerInterval = window.setInterval(() => {
        const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1e3);
        const mins = Math.floor(elapsed / 60).toString().padStart(2, "0");
        const secs = (elapsed % 60).toString().padStart(2, "0");
        this.timerEl.setText(`${mins}:${secs}`);
      }, 1e3);
    } catch (error) {
      console.error("Recording error:", error);
      new import_obsidian.Notice("Could not access microphone. Please allow microphone access.");
      this.statusEl.setText("Microphone access denied");
    }
  }
  async stopRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.isRecording = false;
      if (this.timerInterval) {
        window.clearInterval(this.timerInterval);
        this.timerInterval = null;
      }
      this.recordBtn.setText("PROCESSING...");
      this.recordBtn.disabled = true;
      this.recordBtn.style.background = "var(--text-muted)";
      this.statusEl.setText("Processing your voice note...");
      this.statusEl.style.color = "var(--text-accent)";
    }
  }
  async processRecording() {
    try {
      const audioBlob = new Blob(this.audioChunks, { type: "audio/webm" });
      if (this.plugin.settings.mode === "remote" && this.plugin.settings.athleteToken) {
        this.statusEl.setText("Transcribing via cloud (30s max, 5/day)...");
        try {
          const result = await this.plugin.remoteTranscribe(audioBlob);
          const usageInfo = `(${result.usage.remaining} voice notes remaining today)`;
          this.statusEl.setText(`Transcribed ${Math.round(result.duration)}s ${usageInfo}`);
          this.showRemoteTranscriptConfirmation(result.text, result.usage);
        } catch (error) {
          if (error.message.includes("Daily limit")) {
            this.statusEl.setText("Daily voice note limit reached (5/day)");
            new import_obsidian.Notice("You have used all 5 voice notes for today. Try again tomorrow!");
          } else if (error.message.includes("too long")) {
            this.statusEl.setText("Recording too long (max 30 seconds)");
            new import_obsidian.Notice("Voice notes are limited to 30 seconds. Please record a shorter message.");
          } else {
            throw error;
          }
          this.recordBtn.setText("TRY AGAIN");
          this.recordBtn.disabled = false;
          this.recordBtn.style.background = "var(--interactive-accent)";
          return;
        }
      } else {
        const base64 = await this.blobToBase64(audioBlob);
        this.statusEl.setText("Transcribing...");
        let response;
        if (this.currentSessionId) {
          response = await this.plugin.respondToSession(
            this.currentSessionId,
            void 0,
            base64,
            void 0
          );
          if (response.awaiting_confirmation) {
            this.showTranscriptConfirmation(response.transcript, response.message, this.currentSessionId);
          } else {
            this.displayResults(response);
          }
        } else {
          response = await this.plugin.startVoiceSession(base64);
          if (response.awaiting_confirmation) {
            this.showTranscriptConfirmation(response.transcript, response.message, null);
          } else {
            this.displayResults(response);
          }
        }
      }
    } catch (error) {
      console.error("Processing error:", error);
      this.statusEl.setText("Error processing recording");
      this.statusEl.style.color = "var(--text-error)";
      this.recordBtn.setText("TRY AGAIN");
      this.recordBtn.disabled = false;
      this.recordBtn.style.background = "var(--interactive-accent)";
      this.resultEl.empty();
      this.resultEl.createEl("p", {
        text: `Error: ${error.message || "Could not process recording"}`,
        cls: "error"
      });
    }
  }
  // Show transcript confirmation for remote (athlete) mode
  showRemoteTranscriptConfirmation(transcript, usage) {
    this.resultEl.empty();
    this.statusEl.setText("Review your transcription");
    this.statusEl.style.color = "var(--text-accent)";
    const usageEl = this.resultEl.createEl("p", {
      text: `Voice notes today: ${usage.count}/${usage.limit} (${usage.remaining} remaining)`
    });
    usageEl.style.textAlign = "center";
    usageEl.style.color = "var(--text-muted)";
    usageEl.style.fontSize = "0.85em";
    usageEl.style.marginBottom = "10px";
    const textarea = this.resultEl.createEl("textarea");
    textarea.value = transcript;
    textarea.style.cssText = `
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-primary);
            color: var(--text-normal);
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        `;
    const btnContainer = this.resultEl.createDiv();
    btnContainer.style.cssText = "display: flex; gap: 10px; justify-content: center;";
    const submitBtn = btnContainer.createEl("button", { text: "Submit to Analyst" });
    submitBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        `;
    submitBtn.onclick = async () => {
      var _a;
      const finalText = textarea.value.trim();
      if (!finalText) {
        new import_obsidian.Notice("Please enter some text");
        return;
      }
      submitBtn.disabled = true;
      submitBtn.setText("Submitting...");
      try {
        await ((_a = this.plugin.remoteClient) == null ? void 0 : _a.submitQuery(finalText));
        new import_obsidian.Notice("Query submitted to analyst!");
        await this.saveRemoteVoiceNote(finalText);
        this.statusEl.setText("Submitted! Your analyst will process this.");
        this.statusEl.style.color = "var(--text-success)";
        this.recordBtn.setText("RECORD ANOTHER");
        this.recordBtn.disabled = false;
        this.recordBtn.style.background = "var(--interactive-accent)";
      } catch (error) {
        new import_obsidian.Notice(`Submit failed: ${error.message}`);
        submitBtn.disabled = false;
        submitBtn.setText("Submit to Analyst");
      }
    };
    const saveOnlyBtn = btnContainer.createEl("button", { text: "Save Only" });
    saveOnlyBtn.style.cssText = `
            padding: 10px 20px;
            background: var(--background-modifier-border);
            color: var(--text-normal);
            border: none;
            border-radius: 6px;
            cursor: pointer;
        `;
    saveOnlyBtn.onclick = async () => {
      const finalText = textarea.value.trim();
      if (finalText) {
        await this.saveRemoteVoiceNote(finalText);
        new import_obsidian.Notice("Voice note saved to vault");
      }
      this.close();
    };
    this.recordBtn.setText("RECORD MORE");
    this.recordBtn.disabled = false;
    this.recordBtn.style.background = "var(--interactive-accent)";
  }
  // Save voice note to vault (for remote mode)
  async saveRemoteVoiceNote(transcript) {
    const date = new Date().toISOString().split("T")[0];
    const time = new Date().toTimeString().split(" ")[0].replace(/:/g, "-");
    const folder = this.plugin.settings.syncFolder + "/VoiceNotes";
    await this.plugin.ensureFoldersExist([folder]);
    const content = `---
type: voice-note
date: ${date}
tags: [bjj, voice-note]
---

# Voice Note - ${date} ${time}

${transcript}
`;
    const fileName = `${folder}/Voice Note ${date} ${time}.md`;
    await this.app.vault.create(fileName, content);
  }
  showTranscriptConfirmation(transcript, message, sessionIdForContinuation) {
    this.resultEl.empty();
    const isContinuation = sessionIdForContinuation !== null;
    this.statusEl.setText("Review your transcription");
    this.statusEl.style.color = "var(--text-accent)";
    const messageEl = this.resultEl.createEl("p", {
      text: message || "Is this transcription correct? Edit if needed, then confirm."
    });
    messageEl.style.textAlign = "center";
    messageEl.style.color = "var(--text-muted)";
    messageEl.style.marginBottom = "15px";
    const textareaContainer = this.resultEl.createDiv({ cls: "transcript-edit-container" });
    textareaContainer.style.marginBottom = "20px";
    const textarea = textareaContainer.createEl("textarea", {
      cls: "transcript-textarea"
    });
    textarea.value = transcript;
    textarea.style.cssText = `
            width: 100%;
            min-height: 120px;
            padding: 12px;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            background: var(--background-primary);
            color: var(--text-normal);
            resize: vertical;
            font-family: inherit;
        `;
    const btnContainer = this.resultEl.createDiv({ cls: "confirm-btn-container" });
    btnContainer.style.textAlign = "center";
    btnContainer.style.display = "flex";
    btnContainer.style.gap = "10px";
    btnContainer.style.justifyContent = "center";
    const reRecordBtn = btnContainer.createEl("button", {
      text: "\u{1F3A4} Re-record"
    });
    reRecordBtn.style.cssText = `
            font-size: 14px;
            padding: 12px 24px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            background: var(--background-secondary);
            color: var(--text-normal);
            cursor: pointer;
        `;
    reRecordBtn.onclick = () => {
      this.isRecording = false;
      this.audioChunks = [];
      if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
        this.mediaRecorder.stop();
      }
      if (this.timerInterval) {
        clearInterval(this.timerInterval);
        this.timerInterval = null;
      }
      this.resultEl.empty();
      this.statusEl.setText(isContinuation ? "Record your answer" : "Click to start recording");
      this.statusEl.style.color = "var(--text-muted)";
      this.recordBtn.setText(isContinuation ? "ANSWER" : "START RECORDING");
      this.recordBtn.disabled = false;
      this.recordBtn.style.display = "inline-block";
      this.recordBtn.style.background = "var(--interactive-accent)";
      this.timerEl.setText("00:00");
    };
    const confirmBtn = btnContainer.createEl("button", {
      text: "\u2713 Confirm & Process"
    });
    confirmBtn.style.cssText = `
            font-size: 14px;
            font-weight: 600;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
        `;
    confirmBtn.onclick = async () => {
      const confirmedText = textarea.value.trim();
      if (!confirmedText) {
        new import_obsidian.Notice("Please enter your training notes");
        return;
      }
      confirmBtn.disabled = true;
      reRecordBtn.disabled = true;
      confirmBtn.setText("Processing...");
      this.statusEl.setText("Processing your training notes...");
      this.statusEl.style.color = "var(--text-accent)";
      try {
        let session;
        if (isContinuation) {
          session = await this.plugin.confirmRespondToSession(sessionIdForContinuation, confirmedText);
        } else {
          session = await this.plugin.confirmVoiceSession(confirmedText);
        }
        this.displayResults(session);
      } catch (error) {
        console.error("Confirm error:", error);
        this.statusEl.setText("Error processing. Try again.");
        this.statusEl.style.color = "var(--text-error)";
        confirmBtn.disabled = false;
        reRecordBtn.disabled = false;
        confirmBtn.setText("\u2713 Confirm & Process");
        new import_obsidian.Notice(`Error: ${error.message || "Could not process"}`);
      }
    };
    this.recordBtn.style.display = "none";
  }
  displayResults(session) {
    var _a, _b;
    this.resultEl.empty();
    this.currentSessionId = session.session_id;
    if ((_b = (_a = session.research) == null ? void 0 : _a.article_sections) == null ? void 0 : _b.length) {
      this.showArticlePlayer(session);
      return;
    }
    if (session.response_audio_url) {
      const audioUrl = `${this.plugin.settings.serverUrl}${session.response_audio_url}`;
      const audio = new Audio(audioUrl);
      audio.play().catch((err) => console.error("Audio error:", err));
      this.statusEl.setText("Coach is speaking...");
      this.statusEl.style.color = "var(--text-accent)";
      audio.onended = () => {
        this.statusEl.setText("Your turn - record your answer");
        this.statusEl.style.color = "var(--text-success)";
      };
    }
    const questionContainer = this.resultEl.createDiv({ cls: "coach-question" });
    questionContainer.style.background = "var(--background-secondary)";
    questionContainer.style.padding = "20px";
    questionContainer.style.borderRadius = "12px";
    questionContainer.style.marginBottom = "20px";
    questionContainer.style.textAlign = "center";
    const questionText = questionContainer.createEl("p", {
      text: session.response_text
    });
    questionText.style.fontSize = "1.2em";
    questionText.style.margin = "0";
    questionText.style.lineHeight = "1.5";
    questionText.style.textAlign = "center";
    if (session.state === "RESEARCHING") {
      const isRemote = this.plugin.isRemoteMode();
      this.statusEl.setText(isRemote ? "Ready to send to coach!" : "Ready to generate wisdom!");
      this.statusEl.style.color = "var(--text-success)";
      const bigBtnContainer = this.resultEl.createDiv();
      bigBtnContainer.style.textAlign = "center";
      bigBtnContainer.style.marginTop = "30px";
      const generateBtn = bigBtnContainer.createEl("button", {
        text: isRemote ? "\u{1F4E4} Send to Coach" : "\u2728 Generate Wisdom",
        cls: "mod-cta"
      });
      generateBtn.style.fontSize = "1.4em";
      generateBtn.style.padding = "20px 40px";
      generateBtn.style.borderRadius = "12px";
      generateBtn.onclick = async () => {
        var _a2, _b2, _c, _d, _e, _f, _g;
        const sessionId = this.currentSessionId;
        const plugin = this.plugin;
        const app = this.app;
        const topic = ((_a2 = session.selected_topic) == null ? void 0 : _a2.name) || "Research";
        if (isRemote) {
          const therapyContext = {
            conversation: session.conversation || [],
            selected_topic: session.selected_topic
          };
          const jobId = await plugin.submitToCoach(topic, therapyContext);
          if (jobId) {
            new import_obsidian.Notice("Query sent to coach! Check back later for results.", 5e3);
          }
          this.close();
          return;
        }
        new import_obsidian.Notice("Generating wisdom in background...", 3e3);
        this.close();
        try {
          const response = await plugin.respondToSession(
            sessionId,
            "generate",
            void 0,
            void 0
          );
          const responseTopic = ((_b2 = response.selected_topic) == null ? void 0 : _b2.name) || ((_c = response.research) == null ? void 0 : _c.topic) || ((_d = session.selected_topic) == null ? void 0 : _d.name) || "Research";
          if ((_e = response.research) == null ? void 0 : _e.article_raw) {
            const filename = await plugin.saveArticleToVault(responseTopic, response.research.article_raw);
            new import_obsidian.Notice(`Wisdom ready! Saved to ${filename}`, 3e3);
          }
          if (((_g = (_f = response.research) == null ? void 0 : _f.article_sections) == null ? void 0 : _g.length) > 0) {
            const articleContent = response.research.article || response.research.article_raw || "";
            const sources = response.research.sources || [];
            const playerModal = new AudioPlayerModal(app, plugin, responseTopic, response.research.article_sections, sessionId, articleContent, sources);
            playerModal.open();
          } else {
            new import_obsidian.Notice("Research complete! Check your Flipmode folder.", 5e3);
          }
        } catch (error) {
          console.error("Generate error:", error);
          new import_obsidian.Notice("Failed to generate wisdom. Try again.", 5e3);
        }
      };
      this.recordBtn.style.display = "none";
      return;
    }
    const answerBtnContainer = this.resultEl.createDiv({ cls: "answer-btn-container" });
    answerBtnContainer.style.textAlign = "center";
    answerBtnContainer.style.marginTop = "20px";
    answerBtnContainer.style.display = "flex";
    answerBtnContainer.style.justifyContent = "center";
    answerBtnContainer.style.gap = "15px";
    answerBtnContainer.appendChild(this.recordBtn);
    this.recordBtn.setText("ANSWER");
    this.recordBtn.disabled = false;
    this.recordBtn.style.display = "inline-flex";
    this.recordBtn.style.background = "var(--interactive-accent)";
    const doneBtn = answerBtnContainer.createEl("button", {
      text: "DONE",
      cls: "mod-cta"
    });
    doneBtn.style.cssText = `
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
        `;
    doneBtn.onclick = async () => {
      if (!this.currentSessionId) {
        new import_obsidian.Notice("No session to save", 3e3);
        this.close();
        return;
      }
      doneBtn.disabled = true;
      doneBtn.setText("Saving...");
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: `${this.plugin.settings.serverUrl}/api/obsidian/sync/session/${this.currentSessionId}`,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${this.plugin.settings.apiToken}`
          }
        });
        const data = response.json;
        if (data.content) {
          const season = this.plugin.settings.currentSeason;
          const episode = this.plugin.settings.currentEpisode;
          const athleteName = this.plugin.settings.athleteName || "Athlete";
          const dateStr = new Date().toISOString().split("T")[0];
          const frontmatter = data.frontmatter || {};
          const topics = frontmatter.topics || [];
          const wins = frontmatter.wins || [];
          let focus = frontmatter.selected_topic || topics[0] || wins[0] || "general";
          focus = focus.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "_").substring(0, 30);
          const baseFilename = `TrainingNotes-${dateStr}-${focus}`;
          const reviewFilename = `TrainingReview-${dateStr}-${focus}`;
          const folderPath = `${this.plugin.settings.syncFolder}/Athletes/${athleteName}/Season ${season}/Session ${episode}`;
          const fullPath = `${folderPath}/${baseFilename}.md`;
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (!folder) {
            await this.app.vault.createFolder(folderPath);
          }
          let previousSessionLink = "";
          if (episode > 1) {
            const prevFolderPath = `${this.plugin.settings.syncFolder}/Athletes/${athleteName}/Season ${season}/Session ${episode - 1}`;
            const prevFolder = this.app.vault.getAbstractFileByPath(prevFolderPath);
            if (prevFolder instanceof import_obsidian.TFolder) {
              const prevFiles = prevFolder.children.filter((f) => f instanceof import_obsidian.TFile && f.name.startsWith("TrainingNotes-"));
              if (prevFiles.length > 0) {
                previousSessionLink = `
previous_session: "[[${prevFiles[0].basename}]]"`;
              }
            }
          }
          const enhancedContent = `---
type: training-notes
season: ${season}
episode: ${episode}
date: ${dateStr}
focus: "${focus}"
session_id: "${this.currentSessionId}"${previousSessionLink}
tags: [bjj, training, season-${season}, ${focus.replace(/_/g, "-")}]
---

${data.content}
`;
          const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
          if (existingFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(existingFile, enhancedContent);
          } else {
            await this.app.vault.create(fullPath, enhancedContent);
          }
          this.plugin.settings.currentEpisode = episode + 1;
          await this.plugin.saveSettings();
          new import_obsidian.Notice(`Session saved: ${baseFilename}`, 3e3);
        } else {
          new import_obsidian.Notice("Session ended", 3e3);
        }
      } catch (error) {
        console.error("Error saving session:", error);
        new import_obsidian.Notice("Session ended (save failed)", 3e3);
      }
      this.close();
    };
  }
  showArticlePlayer(session) {
    this.statusEl.setText("Here's your wisdom");
    this.statusEl.style.color = "var(--text-success)";
    const titleEl = this.resultEl.createEl("h3", {
      text: session.research.topic || "Your Research"
    });
    titleEl.style.textAlign = "center";
    titleEl.style.marginBottom = "20px";
    const sectionsContainer = this.resultEl.createDiv({ cls: "article-sections" });
    sectionsContainer.style.background = "var(--background-secondary)";
    sectionsContainer.style.padding = "15px";
    sectionsContainer.style.borderRadius = "12px";
    sectionsContainer.style.marginBottom = "20px";
    let currentAudio = null;
    for (const section of session.research.article_sections) {
      const sectionDiv = sectionsContainer.createDiv({ cls: "section-item" });
      sectionDiv.style.display = "flex";
      sectionDiv.style.alignItems = "center";
      sectionDiv.style.gap = "12px";
      sectionDiv.style.padding = "10px";
      sectionDiv.style.cursor = "pointer";
      sectionDiv.style.borderRadius = "8px";
      const playBtn = sectionDiv.createEl("span", { text: "\u25B6" });
      playBtn.style.fontSize = "1.2em";
      playBtn.style.width = "24px";
      const titleEl2 = sectionDiv.createEl("span", { text: section.title });
      titleEl2.style.flex = "1";
      titleEl2.style.fontWeight = "500";
      const audioUrl = `${this.plugin.settings.serverUrl}${section.audio_url}`;
      const audio = new Audio(audioUrl);
      const playSection = () => {
        if (currentAudio && currentAudio !== audio) {
          currentAudio.pause();
        }
        currentAudio = audio;
        audio.play();
        playBtn.setText("\u23F8");
        sectionDiv.style.background = "var(--background-modifier-active-hover)";
      };
      sectionDiv.onclick = playSection;
      audio.onended = () => {
        playBtn.setText("\u25B6");
        sectionDiv.style.background = "";
      };
      audio.onpause = () => {
        playBtn.setText("\u25B6");
        sectionDiv.style.background = "";
      };
    }
    if (session.research.article_sections.length > 0) {
      const firstAudioUrl = `${this.plugin.settings.serverUrl}${session.research.article_sections[0].audio_url}`;
      const firstAudio = new Audio(firstAudioUrl);
      firstAudio.play().catch(() => {
      });
    }
    const actionsContainer = this.resultEl.createDiv();
    actionsContainer.style.display = "flex";
    actionsContainer.style.flexDirection = "column";
    actionsContainer.style.gap = "12px";
    actionsContainer.style.marginTop = "20px";
    const diveBtn = actionsContainer.createEl("button", {
      text: "DIVE DEEPER",
      cls: "mod-cta"
    });
    diveBtn.style.fontSize = "1.2em";
    diveBtn.style.padding = "15px 30px";
    diveBtn.onclick = () => {
      this.statusEl.setText("Record a follow-up question...");
      this.recordBtn.setText("RECORD FOLLOW-UP");
      this.recordBtn.disabled = false;
      this.recordBtn.style.display = "inline-block";
      this.recordBtn.scrollIntoView({ behavior: "smooth" });
    };
    const planBtn = actionsContainer.createEl("button", {
      text: "CREATE TRAINING PLAN"
    });
    planBtn.style.padding = "12px 24px";
    planBtn.onclick = async () => {
      var _a, _b, _c, _d;
      planBtn.disabled = true;
      planBtn.setText("Creating...");
      try {
        const topic = ((_a = session.research) == null ? void 0 : _a.topic) || ((_b = session.selected_topic) == null ? void 0 : _b.name) || "Training";
        const article = ((_c = session.research) == null ? void 0 : _c.article) || ((_d = session.research) == null ? void 0 : _d.article_raw) || "";
        const response = await this.plugin.apiRequest("/training-plan", "POST", {
          session_id: this.currentSessionId,
          user_id: this.plugin.settings.userId,
          topic,
          article
          // Pass article for training recommendations extraction
        });
        if (response.markdown) {
          const cleanTopic = topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 40);
          const date = new Date().toISOString().split("T")[0];
          const filename = `${this.plugin.settings.syncFolder}/Plans/${date} - ${cleanTopic} Plan.md`;
          const planFolder = `${this.plugin.settings.syncFolder}/Plans`;
          const folder = this.app.vault.getAbstractFileByPath(planFolder);
          if (!folder) {
            await this.app.vault.createFolder(planFolder);
          }
          const existingFile = this.app.vault.getAbstractFileByPath(filename);
          if (existingFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(existingFile, response.markdown);
          } else {
            await this.app.vault.create(filename, response.markdown);
          }
          const file = this.app.vault.getAbstractFileByPath(filename);
          if (file instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
          }
          new import_obsidian.Notice(`Training plan saved to ${filename}`);
        } else {
          new import_obsidian.Notice("Plan created but no content returned");
        }
      } catch (error) {
        console.error("Plan error:", error);
        new import_obsidian.Notice("Failed to create plan");
        planBtn.disabled = false;
        planBtn.setText("CREATE TRAINING PLAN");
      }
    };
    this.recordBtn.style.display = "none";
  }
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64 = reader.result.split(",")[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  onClose() {
    if (this.isRecording && this.mediaRecorder) {
      this.mediaRecorder.stop();
    }
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DiveDeepModal = class extends import_obsidian.Modal {
  constructor(app, plugin, topic, sessionContext, rlmSessionId = "") {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.plugin = plugin;
    this.topic = topic;
    this.sessionContext = sessionContext;
    this.rlmSessionId = rlmSessionId;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-dive-deep-modal");
    const titleEl = contentEl.createEl("h2", { text: "Dive Deeper" });
    titleEl.style.textAlign = "center";
    const topicEl = contentEl.createEl("p", { text: `Topic: ${this.topic}` });
    topicEl.style.textAlign = "center";
    topicEl.style.color = "var(--text-accent)";
    topicEl.style.fontWeight = "600";
    const contextContainer = contentEl.createDiv();
    contextContainer.style.background = "var(--background-secondary)";
    contextContainer.style.padding = "15px";
    contextContainer.style.borderRadius = "8px";
    contextContainer.style.marginBottom = "20px";
    contextContainer.style.maxHeight = "150px";
    contextContainer.style.overflowY = "auto";
    const contextLabel = contextContainer.createEl("p", { text: "Session Notes:" });
    contextLabel.style.fontWeight = "600";
    contextLabel.style.marginBottom = "8px";
    const contextText = contextContainer.createEl("p", { text: this.sessionContext });
    contextText.style.fontSize = "0.9em";
    contextText.style.whiteSpace = "pre-wrap";
    this.statusEl = contentEl.createEl("p", { text: "Record your follow-up question" });
    this.statusEl.style.textAlign = "center";
    this.statusEl.style.color = "var(--text-muted)";
    const btnContainer = contentEl.createDiv();
    btnContainer.style.textAlign = "center";
    btnContainer.style.marginTop = "20px";
    this.recordBtn = btnContainer.createEl("button", { text: "RECORD QUESTION", cls: "mod-cta" });
    this.recordBtn.style.padding = "16px 32px";
    this.recordBtn.style.fontSize = "1.1em";
    this.recordBtn.onclick = () => this.toggleRecording();
  }
  async toggleRecording() {
    if (this.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  async startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.audioChunks = [];
      this.mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });
      this.mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0)
          this.audioChunks.push(e.data);
      };
      this.mediaRecorder.onstop = async () => {
        stream.getTracks().forEach((t) => t.stop());
        await this.processRecording();
      };
      this.mediaRecorder.start();
      this.isRecording = true;
      this.recordBtn.setText("STOP");
      this.recordBtn.style.background = "var(--text-error)";
      this.statusEl.setText("Recording... speak your question");
    } catch (error) {
      new import_obsidian.Notice("Could not access microphone");
    }
  }
  async stopRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.isRecording = false;
    }
  }
  async processRecording() {
    var _a, _b;
    this.recordBtn.setText("PROCESSING...");
    this.recordBtn.disabled = true;
    this.statusEl.setText("Sending to Flipmode...");
    try {
      const audioBlob = new Blob(this.audioChunks, { type: "audio/webm" });
      const base64Audio = await this.blobToBase64(audioBlob);
      const sessionResponse = await this.plugin.apiRequest("/session", "POST", {
        user_id: this.plugin.settings.userId
      });
      const response = await this.plugin.apiRequest("/respond", "POST", {
        session_id: sessionResponse.session_id,
        audio_base64: base64Audio,
        audio_format: "webm",
        context: `Follow-up on ${this.topic}. Session notes: ${this.sessionContext}`
      });
      new import_obsidian.Notice("Researching in background...", 3e3);
      this.close();
      if (((_b = (_a = response.research) == null ? void 0 : _a.article_sections) == null ? void 0 : _b.length) > 0) {
        const articleContent = response.research.article || response.research.article_raw || "";
        const sources = response.research.sources || [];
        const playerModal = new AudioPlayerModal(
          this.app,
          this.plugin,
          this.topic + " - Follow-up",
          response.research.article_sections,
          sessionResponse.session_id,
          articleContent,
          sources
        );
        playerModal.open();
      }
    } catch (error) {
      console.error("Dive deep error:", error);
      new import_obsidian.Notice("Failed to process - try again");
      this.recordBtn.setText("RECORD QUESTION");
      this.recordBtn.disabled = false;
    }
  }
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result.split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  onClose() {
    if (this.isRecording && this.mediaRecorder) {
      this.mediaRecorder.stop();
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AudioPlayerModal = class extends import_obsidian.Modal {
  constructor(app, plugin, topic, sections, sessionId, articleContent, sources) {
    super(app);
    // Video sources with timestamps
    this.currentIndex = 0;
    this.currentAudio = null;
    this.isPlaying = false;
    this.volume = 0.8;
    this.sectionItems = [];
    this.savedFilePath = null;
    this.plugin = plugin;
    this.topic = topic;
    this.sections = sections;
    this.sessionId = sessionId || null;
    this.articleContent = articleContent || "";
    this.sources = sources || [];
  }
  async saveResearchToVault() {
    if (!this.articleContent) {
      return null;
    }
    try {
      const cleanTopic = this.topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
      const date = new Date().toISOString().split("T")[0];
      const baseFolder = this.plugin.settings.syncFolder;
      const researchFolder = `${baseFolder}/Research`;
      const topicAudioFolder = `${researchFolder}/audio/${cleanTopic}`;
      for (const folder of [baseFolder, researchFolder, `${researchFolder}/audio`, topicAudioFolder]) {
        const existing = this.app.vault.getAbstractFileByPath(folder);
        if (!existing) {
          await this.app.vault.createFolder(folder);
        }
      }
      const audioEmbeds = [];
      for (let i = 0; i < this.sections.length; i++) {
        const section = this.sections[i];
        const sectionNum = String(i + 1).padStart(2, "0");
        const cleanSectionTitle = section.title.replace(/[\\/:*?"<>|]/g, "-").substring(0, 40);
        const audioFilename = `${sectionNum}-${cleanSectionTitle}.mp3`;
        const audioPath = `${topicAudioFolder}/${audioFilename}`;
        try {
          const audioUrl = `${this.plugin.settings.serverUrl}${section.audio_url}`;
          const response = await fetch(audioUrl, {
            headers: {
              "Authorization": `Bearer ${this.plugin.settings.apiToken}`
            }
          });
          if (response.ok) {
            const audioBlob = await response.blob();
            const arrayBuffer = await audioBlob.arrayBuffer();
            const existingAudio = this.app.vault.getAbstractFileByPath(audioPath);
            if (existingAudio instanceof import_obsidian.TFile) {
              await this.app.vault.modifyBinary(existingAudio, arrayBuffer);
            } else {
              await this.app.vault.createBinary(audioPath, arrayBuffer);
            }
            audioEmbeds.push(`### ${section.title}
![[${audioPath}]]`);
          }
        } catch (err) {
          console.error(`Failed to download audio for section ${i}:`, err);
          audioEmbeds.push(`### ${section.title}
*Audio not available*`);
        }
      }
      const markdownContent = `---
topic: "${this.topic}"
date: ${date}
type: research
---

# ${this.topic}

${this.articleContent}

---

## \u{1F3A7} Audio Sections

${audioEmbeds.join("\n\n")}
`;
      const filename = `${researchFolder}/${date} - ${cleanTopic}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(filename);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, markdownContent);
      } else {
        await this.app.vault.create(filename, markdownContent);
      }
      this.savedFilePath = filename;
      return filename;
    } catch (error) {
      console.error("Error saving research to vault:", error);
      return null;
    }
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-audio-player");
    const titleEl = contentEl.createEl("h2", { text: this.topic || "Research" });
    titleEl.style.textAlign = "center";
    titleEl.style.marginBottom = "10px";
    this.statusEl = contentEl.createEl("p", { text: this.articleContent ? "Saving to vault..." : "Ready to play" });
    this.statusEl.style.textAlign = "center";
    this.statusEl.style.color = "var(--text-muted)";
    this.statusEl.style.marginBottom = "20px";
    if (this.articleContent) {
      this.saveResearchToVault().then((savedPath) => {
        if (savedPath) {
          new import_obsidian.Notice(`Research saved to ${savedPath}`, 3e3);
        }
      });
    }
    const sectionsContainer = contentEl.createDiv({ cls: "audio-sections" });
    sectionsContainer.style.background = "var(--background-secondary)";
    sectionsContainer.style.padding = "15px";
    sectionsContainer.style.borderRadius = "12px";
    sectionsContainer.style.marginBottom = "20px";
    sectionsContainer.style.maxHeight = "300px";
    sectionsContainer.style.overflowY = "auto";
    this.sections.forEach((section, index) => {
      const sectionDiv = sectionsContainer.createDiv({ cls: "section-item" });
      sectionDiv.style.display = "flex";
      sectionDiv.style.alignItems = "center";
      sectionDiv.style.gap = "12px";
      sectionDiv.style.padding = "10px";
      sectionDiv.style.borderRadius = "8px";
      sectionDiv.style.cursor = "pointer";
      const indicator = sectionDiv.createEl("span", { text: "\u25CB" });
      indicator.style.fontSize = "1em";
      indicator.style.width = "20px";
      indicator.addClass("section-indicator");
      const titleSpan = sectionDiv.createEl("span", { text: section.title });
      titleSpan.style.flex = "1";
      sectionDiv.onclick = () => this.playSection(index);
      this.sectionItems.push(sectionDiv);
    });
    const controlsContainer = contentEl.createDiv();
    controlsContainer.style.display = "flex";
    controlsContainer.style.justifyContent = "center";
    controlsContainer.style.alignItems = "center";
    controlsContainer.style.gap = "10px";
    controlsContainer.style.marginTop = "20px";
    const transportControls = controlsContainer.createDiv();
    transportControls.style.display = "flex";
    transportControls.style.alignItems = "center";
    transportControls.style.gap = "5px";
    transportControls.style.background = "var(--background-secondary)";
    transportControls.style.borderRadius = "25px";
    transportControls.style.padding = "5px 10px";
    const prevBtn = transportControls.createEl("button", { text: "\u23EE" });
    prevBtn.style.padding = "10px 15px";
    prevBtn.style.fontSize = "1.2em";
    prevBtn.style.border = "none";
    prevBtn.style.background = "transparent";
    prevBtn.style.cursor = "pointer";
    prevBtn.title = "Previous section";
    prevBtn.onclick = () => {
      if (this.currentIndex > 0) {
        this.playSection(this.currentIndex - 1);
      }
    };
    const pauseBtn = transportControls.createEl("button", { text: "\u23F8" });
    pauseBtn.style.padding = "10px 20px";
    pauseBtn.style.fontSize = "1.4em";
    pauseBtn.style.border = "none";
    pauseBtn.style.background = "var(--interactive-accent)";
    pauseBtn.style.color = "var(--text-on-accent)";
    pauseBtn.style.borderRadius = "50%";
    pauseBtn.style.width = "50px";
    pauseBtn.style.height = "50px";
    pauseBtn.style.cursor = "pointer";
    pauseBtn.title = "Pause/Resume";
    pauseBtn.onclick = () => {
      if (this.currentAudio) {
        if (this.isPlaying) {
          this.currentAudio.pause();
          pauseBtn.setText("\u25B6");
          this.isPlaying = false;
        } else {
          this.currentAudio.play();
          pauseBtn.setText("\u23F8");
          this.isPlaying = true;
        }
      }
    };
    const nextBtn = transportControls.createEl("button", { text: "\u23ED" });
    nextBtn.style.padding = "10px 15px";
    nextBtn.style.fontSize = "1.2em";
    nextBtn.style.border = "none";
    nextBtn.style.background = "transparent";
    nextBtn.style.cursor = "pointer";
    nextBtn.title = "Next section";
    nextBtn.onclick = () => {
      if (this.currentIndex < this.sections.length - 1) {
        this.playSection(this.currentIndex + 1);
      }
    };
    const volumeContainer = controlsContainer.createDiv();
    volumeContainer.style.display = "flex";
    volumeContainer.style.alignItems = "center";
    volumeContainer.style.gap = "8px";
    const volumeIcon = volumeContainer.createEl("span", { text: "\u{1F50A}" });
    volumeIcon.style.fontSize = "1.2em";
    const volumeSlider = volumeContainer.createEl("input");
    volumeSlider.type = "range";
    volumeSlider.min = "0";
    volumeSlider.max = "100";
    volumeSlider.value = String(this.volume * 100);
    volumeSlider.style.width = "80px";
    volumeSlider.style.cursor = "pointer";
    volumeSlider.oninput = () => {
      this.volume = parseInt(volumeSlider.value) / 100;
      if (this.currentAudio) {
        this.currentAudio.volume = this.volume;
      }
      if (this.volume === 0) {
        volumeIcon.setText("\u{1F507}");
      } else if (this.volume < 0.5) {
        volumeIcon.setText("\u{1F509}");
      } else {
        volumeIcon.setText("\u{1F50A}");
      }
    };
    if (!this.articleContent) {
    } else {
      const planBtn = controlsContainer.createEl("button", { text: "TRAINING PLAN" });
      planBtn.style.padding = "12px 24px";
      planBtn.onclick = async () => {
        var _a, _b, _c;
        planBtn.disabled = true;
        planBtn.setText("Creating plan...");
        try {
          const response = await this.plugin.apiRequest("/training-plan", "POST", {
            session_id: this.sessionId,
            user_id: this.plugin.settings.userId,
            topic: this.topic,
            article: this.articleContent,
            sources: this.sources,
            // Pass sources for video clip extraction
            include_video_refs: true
          });
          if (response.markdown) {
            const cleanTopic = this.topic.replace(/[\\/:*?"<>|]/g, "-").substring(0, 40);
            const date = new Date().toISOString().split("T")[0];
            const planFilename = `${this.plugin.settings.syncFolder}/Plans/${date} - ${cleanTopic} Plan.md`;
            const planFolder = `${this.plugin.settings.syncFolder}/Plans`;
            const folder = this.app.vault.getAbstractFileByPath(planFolder);
            if (!folder) {
              await this.app.vault.createFolder(planFolder);
            }
            const clipsBaseFolder = `${planFolder}/clips`;
            const clipsBaseFolderObj = this.app.vault.getAbstractFileByPath(clipsBaseFolder);
            if (!clipsBaseFolderObj) {
              await this.app.vault.createFolder(clipsBaseFolder);
            }
            const clipsFolder = `${clipsBaseFolder}/${cleanTopic}`;
            const clipsFolderObj = this.app.vault.getAbstractFileByPath(clipsFolder);
            if (!clipsFolderObj) {
              await this.app.vault.createFolder(clipsFolder);
            }
            let videoSection = "";
            if (response.clips && response.clips.length > 0) {
              planBtn.setText(`Downloading ${response.clips.length} clips...`);
              const clipEmbeds = [];
              for (const clip of response.clips) {
                try {
                  const clipResponse = await (0, import_obsidian.requestUrl)({
                    url: `${this.plugin.settings.serverUrl}${clip.clip_url}`,
                    method: "GET",
                    headers: {
                      "Authorization": `Bearer ${this.plugin.settings.apiToken}`
                    }
                  });
                  const clipFilename = `${clip.instructor.replace(/[\\/:*?"<>|]/g, "-")} - ${clip.timestamp.replace(/:/g, "-")}.mp4`;
                  const clipPath = `${clipsFolder}/${clipFilename}`;
                  const existingClip = this.app.vault.getAbstractFileByPath(clipPath);
                  if (!existingClip) {
                    await this.app.vault.createBinary(clipPath, clipResponse.arrayBuffer);
                  }
                  clipEmbeds.push(`#### ${clip.instructor} @ ${clip.timestamp}
![[${clipPath}]]`);
                } catch (clipError) {
                  console.error("Failed to download clip:", clipError);
                }
              }
              if (clipEmbeds.length > 0) {
                videoSection = `

## Reference Video Clips

These clips show the actual techniques from the research sources. Watch them to see how the moves should look:

${clipEmbeds.join("\n\n")}
`;
              }
            }
            let researchLink = "";
            if (this.savedFilePath) {
              const researchFileName = ((_a = this.savedFilePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "";
              researchLink = `> \u{1F4DA} **Based on research:** [[${researchFileName}]]

`;
            }
            const planContent = `---
topic: "${this.topic}"
date: ${date}
type: training-plan
research: "${this.savedFilePath || ""}"
clips: ${((_b = response.clips) == null ? void 0 : _b.length) || 0}
---

${researchLink}${response.markdown}${videoSection}`;
            const existingFile = this.app.vault.getAbstractFileByPath(planFilename);
            if (existingFile instanceof import_obsidian.TFile) {
              await this.app.vault.modify(existingFile, planContent);
            } else {
              await this.app.vault.create(planFilename, planContent);
            }
            const file = this.app.vault.getAbstractFileByPath(planFilename);
            if (file instanceof import_obsidian.TFile) {
              await this.app.workspace.getLeaf().openFile(file);
            }
            const clipMsg = ((_c = response.clips) == null ? void 0 : _c.length) ? ` with ${response.clips.length} video clips` : "";
            new import_obsidian.Notice(`Training plan saved${clipMsg}`);
            planBtn.setText("TRAINING PLAN");
            planBtn.disabled = false;
          } else {
            new import_obsidian.Notice("Plan created but no content returned");
            planBtn.setText("TRAINING PLAN");
            planBtn.disabled = false;
          }
        } catch (error) {
          console.error("Plan error:", error);
          new import_obsidian.Notice("Failed to create plan");
          planBtn.disabled = false;
          planBtn.setText("TRAINING PLAN");
        }
      };
      const viewBtn = controlsContainer.createEl("button", { text: "VIEW IN VAULT" });
      viewBtn.style.padding = "12px 24px";
      viewBtn.onclick = async () => {
        if (this.savedFilePath) {
          const file = this.app.vault.getAbstractFileByPath(this.savedFilePath);
          if (file instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
            this.close();
          }
        } else {
          new import_obsidian.Notice("Still saving... please wait");
        }
      };
    }
    const closeBtn = controlsContainer.createEl("button", { text: "CLOSE" });
    closeBtn.style.padding = "12px 24px";
    closeBtn.onclick = () => this.close();
    if (this.sections.length > 0) {
      this.playSection(0);
    }
  }
  playSection(index) {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio = null;
    }
    if (index >= this.sections.length) {
      this.isPlaying = false;
      this.statusEl.setText("\u2713 Playback complete - click any section to replay");
      this.sectionItems.forEach((item) => {
        const indicator = item.querySelector(".section-indicator");
        indicator.setText("\u2713");
        item.style.opacity = "1";
        item.style.background = "";
      });
      return;
    }
    this.currentIndex = index;
    this.sectionItems.forEach((item, i) => {
      const indicator = item.querySelector(".section-indicator");
      if (i < index) {
        indicator.setText("\u2713");
        item.style.opacity = "0.7";
        item.style.background = "";
      } else if (i === index) {
        indicator.setText("\u25B6");
        item.style.background = "var(--background-modifier-active-hover)";
        item.style.opacity = "1";
      } else {
        indicator.setText("\u25CB");
        item.style.background = "";
        item.style.opacity = "1";
      }
    });
    const section = this.sections[index];
    this.statusEl.setText(`Playing: ${section.title}`);
    const audioUrl = `${this.plugin.settings.serverUrl}${section.audio_url}`;
    this.currentAudio = new Audio(audioUrl);
    this.currentAudio.volume = this.volume;
    this.isPlaying = true;
    this.currentAudio.play().catch((err) => {
      console.error("Audio play error:", err);
      this.statusEl.setText(`Error playing ${section.title} - click to retry`);
    });
    this.currentAudio.onended = () => {
      this.sectionItems[index].style.background = "";
      this.playSection(index + 1);
    };
    this.currentAudio.onerror = () => {
      console.error("Audio load error for section:", section.title);
      this.statusEl.setText(`Error loading audio - click section to retry`);
    };
  }
  onClose() {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio = null;
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CoachAddAthleteModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Add Athlete to Roster" });
    let discordId = "";
    let displayName = "";
    new import_obsidian.Setting(contentEl).setName("Discord ID").setDesc("The athlete's Discord user ID (18-digit number)").addText((text) => text.setPlaceholder("123456789012345678").onChange((value) => discordId = value));
    new import_obsidian.Setting(contentEl).setName("Display Name").setDesc("Optional friendly name").addText((text) => text.setPlaceholder("John Doe").onChange((value) => displayName = value));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Add Athlete").setCta().onClick(async () => {
      if (!discordId) {
        new import_obsidian.Notice("Discord ID is required");
        return;
      }
      try {
        await this.plugin.coachClient.addAthlete(discordId, displayName || void 0);
        new import_obsidian.Notice("Athlete added to roster!");
        this.close();
      } catch (error) {
        new import_obsidian.Notice("Failed to add athlete");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var PendingJobsModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flipmode-pending-modal");
    contentEl.createEl("h2", { text: "Pending Coach Queries" });
    if (!this.plugin.isRemoteMode()) {
      contentEl.createEl("p", { text: "Remote mode not configured. Enable in settings." });
      return;
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Refresh").onClick(() => this.refresh()));
    const jobsContainer = contentEl.createDiv({ cls: "pending-jobs-list" });
    jobsContainer.style.marginTop = "15px";
    await this.loadJobs(jobsContainer);
  }
  async loadJobs(container) {
    container.empty();
    try {
      const jobs = await this.plugin.queueClient.listJobs();
      if (jobs.length === 0) {
        container.createEl("p", {
          text: "No pending queries",
          cls: "no-jobs"
        });
        return;
      }
      for (const job of jobs) {
        const jobDiv = container.createDiv({ cls: "job-item" });
        jobDiv.style.background = "var(--background-secondary)";
        jobDiv.style.padding = "12px";
        jobDiv.style.borderRadius = "8px";
        jobDiv.style.marginBottom = "10px";
        const statusColors = {
          "pending": "var(--text-muted)",
          "processing": "var(--text-accent)",
          "complete": "var(--text-success)",
          "error": "var(--text-error)"
        };
        const statusEl = jobDiv.createEl("span", {
          text: job.status.toUpperCase(),
          cls: "job-status"
        });
        statusEl.style.color = statusColors[job.status] || "var(--text-muted)";
        statusEl.style.fontWeight = "600";
        statusEl.style.marginRight = "10px";
        const queryEl = jobDiv.createEl("span", {
          text: job.query_text.substring(0, 50) + (job.query_text.length > 50 ? "..." : "")
        });
        const timeEl = jobDiv.createEl("div", {
          text: `Submitted: ${new Date(job.submitted_at).toLocaleString()}`,
          cls: "job-time"
        });
        timeEl.style.fontSize = "0.85em";
        timeEl.style.color = "var(--text-muted)";
        timeEl.style.marginTop = "5px";
      }
    } catch (error) {
      container.createEl("p", {
        text: "Failed to load jobs. Check connection.",
        cls: "error"
      });
    }
  }
  async refresh() {
    const container = this.contentEl.querySelector(".pending-jobs-list");
    if (container) {
      await this.loadJobs(container);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BJJFlipmodeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Flipmode Settings" });
    new import_obsidian.Setting(containerEl).setName("Mode").setDesc("Local: Direct Oracle. Remote: Athlete sending to coach. Coach: Process athlete queries.").addDropdown((dropdown) => dropdown.addOption("local", "Local (Direct Oracle)").addOption("remote", "Remote (Athlete)").addOption("coach", "Coach (Process Queries)").setValue(this.plugin.settings.mode).onChange(async (value) => {
      this.plugin.settings.mode = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    containerEl.createEl("h3", { text: "Athlete Identity" });
    new import_obsidian.Setting(containerEl).setName("Athlete Name").setDesc("Your name (used for folder organization: Flipmode/Athletes/{Name}/Sessions/)").addText((text) => text.setPlaceholder("Enter athlete name").setValue(this.plugin.settings.athleteName).onChange(async (value) => {
      this.plugin.settings.athleteName = value || "Athlete";
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Season & Episode Tracking" });
    containerEl.createEl("p", {
      text: `Current: ${this.plugin.settings.athleteName} - S${this.plugin.settings.currentSeason}E${String(this.plugin.settings.currentEpisode).padStart(2, "0")}`,
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Current Season").setDesc("Training season number (e.g., competition prep, off-season)").addText((text) => text.setValue(String(this.plugin.settings.currentSeason)).onChange(async (value) => {
      const num = parseInt(value) || 1;
      this.plugin.settings.currentSeason = Math.max(1, num);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Current Episode").setDesc("Session number within the season").addText((text) => text.setValue(String(this.plugin.settings.currentEpisode)).onChange(async (value) => {
      const num = parseInt(value) || 1;
      this.plugin.settings.currentEpisode = Math.max(1, num);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Start New Season").setDesc("Increment season number and reset episode to 1").addButton((btn) => btn.setButtonText("New Season").onClick(async () => {
      this.plugin.settings.currentSeason += 1;
      this.plugin.settings.currentEpisode = 1;
      await this.plugin.saveSettings();
      this.display();
      new import_obsidian.Notice(`Started Season ${this.plugin.settings.currentSeason}!`);
    }));
    if (this.plugin.settings.mode === "local") {
      containerEl.createEl("h3", { text: "Local Mode Settings" });
      new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("URL of your Flipmode server").addText((text) => text.setPlaceholder("http://localhost:5005").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("API Token").setDesc("Your API token from the Flipmode profile page").addText((text) => text.setPlaceholder("Enter your API token").setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Verify connection to Flipmode server").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
        const connected = await this.plugin.checkConnection();
        new import_obsidian.Notice(connected ? "Successfully connected to Flipmode!" : "Could not connect to Flipmode");
      }));
    } else if (this.plugin.settings.mode === "remote") {
      containerEl.createEl("h3", { text: "Remote Mode Settings (Athlete)" });
      new import_obsidian.Setting(containerEl).setName("Queue Service URL").setDesc("URL of the coach queue service (e.g., https://your-app.herokuapp.com)").addText((text) => text.setPlaceholder("https://flipmode-queue.herokuapp.com").setValue(this.plugin.settings.queueServiceUrl).onChange(async (value) => {
        this.plugin.settings.queueServiceUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Connect with Discord").setDesc("Authenticate with your coach via Discord").addButton((btn) => btn.setButtonText("Connect Discord").setCta().onClick(async () => {
        await this.plugin.connectWithDiscord();
      }));
      new import_obsidian.Setting(containerEl).setName("Athlete Token").setDesc("Your athlete token (obtained after Discord connection)").addText((text) => text.setPlaceholder("Paste token from Discord auth").setValue(this.plugin.settings.athleteToken).onChange(async (value) => {
        this.plugin.settings.athleteToken = value;
        await this.plugin.saveSettings();
        if (value && this.plugin.settings.queueServiceUrl) {
          this.plugin.initRemoteMode();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Poll Interval").setDesc("Seconds between checking for results").addSlider((slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.pollInterval).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.pollInterval = value;
        await this.plugin.saveSettings();
        if (this.plugin.isRemoteMode()) {
          this.plugin.startResultPolling();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Test Queue Connection").setDesc("Verify connection to coach queue").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
        if (!this.plugin.settings.queueServiceUrl) {
          new import_obsidian.Notice("Configure Queue Service URL first");
          return;
        }
        try {
          const client = new RemoteQueueClient(
            this.plugin.settings.queueServiceUrl,
            this.plugin.settings.athleteToken
          );
          const healthy = await client.checkHealth();
          new import_obsidian.Notice(healthy ? "Queue service is healthy!" : "Queue service not responding");
        } catch (error) {
          new import_obsidian.Notice("Failed to connect to queue service");
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Pending Queries").setDesc("View your pending coach queries").addButton((btn) => btn.setButtonText("View Jobs").onClick(() => {
        this.plugin.showPendingJobsModal();
      }));
      new import_obsidian.Setting(containerEl).setName("Sync Graph").setDesc("Send your research graph to your coach").addButton((btn) => btn.setButtonText("Sync Now").onClick(async () => {
        await this.plugin.syncGraphToCoach();
      }));
    } else if (this.plugin.settings.mode === "coach") {
      containerEl.createEl("h3", { text: "Coach Mode Settings" });
      new import_obsidian.Setting(containerEl).setName("Queue Service URL").setDesc("URL of the queue service (same as athletes use)").addText((text) => text.setPlaceholder("https://flipmode-queue.herokuapp.com").setValue(this.plugin.settings.queueServiceUrl).onChange(async (value) => {
        this.plugin.settings.queueServiceUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Coach Token").setDesc("Your coach API token (from registration)").addText((text) => text.setPlaceholder("Your coach token").setValue(this.plugin.settings.coachToken).onChange(async (value) => {
        this.plugin.settings.coachToken = value;
        await this.plugin.saveSettings();
        if (value && this.plugin.settings.queueServiceUrl) {
          this.plugin.initCoachMode();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Local Oracle URL").setDesc("Your local Flipmode server for generating articles").addText((text) => text.setPlaceholder("http://localhost:5005").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Verify connection to queue service").addButton((btn) => btn.setButtonText("Test").onClick(async () => {
        if (!this.plugin.settings.queueServiceUrl) {
          new import_obsidian.Notice("Configure Queue Service URL first");
          return;
        }
        try {
          const client = new CoachQueueClient(
            this.plugin.settings.queueServiceUrl,
            this.plugin.settings.coachToken
          );
          const healthy = await client.checkHealth();
          new import_obsidian.Notice(healthy ? "Connected!" : "Service not responding");
        } catch (e) {
          new import_obsidian.Notice("Connection failed");
        }
      }));
      containerEl.createEl("h4", { text: "Quick Actions" });
      new import_obsidian.Setting(containerEl).setName("Sync Athletes").setDesc("Pull all athlete data and pending queries").addButton((btn) => btn.setButtonText("Sync Now").setCta().onClick(() => this.plugin.coachSyncAthletes()));
      new import_obsidian.Setting(containerEl).setName("View Pending").setDesc("Open inbox with pending queries").addButton((btn) => btn.setButtonText("View").onClick(() => this.plugin.coachShowPending()));
      new import_obsidian.Setting(containerEl).setName("Add Athlete").setDesc("Add a new athlete to your roster").addButton((btn) => btn.setButtonText("Add").onClick(() => this.plugin.coachAddAthlete()));
    }
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Sync Folder").setDesc("Folder in your vault for Flipmode content").addText((text) => text.setPlaceholder("Flipmode").setValue(this.plugin.settings.syncFolder).onChange(async (value) => {
      this.plugin.settings.syncFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync with Flipmode periodically").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.startAutoSync();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("Minutes between automatic syncs").addSlider((slider) => slider.setLimits(5, 120, 5).setValue(this.plugin.settings.syncInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.syncInterval = value;
      await this.plugin.saveSettings();
    }));
  }
};
